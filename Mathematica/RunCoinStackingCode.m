(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];(*Get["CoinStackingCode.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}]
*)
Get["LatticePhyllotaxis.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}];



(* ::Input::Initialization:: *)
makeCappedArena[run_,runParameters_] := Module[{initialRadius,finalRadius,hBase,hStart,hEnd,rOfH,arenaAssociation},

initialRadius= smallestRadius[run] ;

hBase=highestCentre[run];
finalRadius= initialRadius/runParameters["rScale"];
{hStart,hEnd} = hBase + {0,hRangeNeeded[{initialRadius,finalRadius},runParameters["rSlope"]]};
rOfH =linearInterpolator[{hStart,hEnd},{initialRadius,-runParameters["rSlope"]}] ;

bulgeFunction = makeBulgeFunction[finalRadius,1/4,hEnd,hEnd+2];
rFunction = Piecewise[ {
{rOfH,h<= hEnd}
,{bulgeFunction,True}
}];
zMax=runParameters["zMax"]+ 1;

arenaAssociation=runParameters;
If[KeyMemberQ[arenaAssociation,"Lattice"],arenaAssociation=KeyDrop[arenaAssociation,"Lattice"]];
arenaAssociation = Append[arenaAssociation,
<| 
"rFunction"->rFunction
,"zMax"->zMax
,"rFixedBefore"-> hStart
,"rFixedAfter"-> hEnd
,"CylinderLU"-> {0,runParameters["zMax"]}
|>];
arenaAssociation
];


makeBulgeFunction[rMin_,rMax_,zMin_,zMax_] := Module[{zRange,bulgeScale},

bulgeScale =  Cos[ArcSin[rMin/rMax]]/zMax;

zRange=zMax-zMin;

<|"rFunction"->Function[z, Piecewise[
{{rMin,z<=  zMin}
,{ rMin/Sin[ArcCos[bulgeScale*(z-zMin)]],z<=zMax}
,{rMax,True}
}]]
,"rMin"->rMin,"rMax"->rMax,"zMin"->zMin,"zMax"->zMax
|>
];



(* ::Input::Initialization:: *)


doParameterRun[experimentParameter_] := Module[{run},
run = makeRunFromParameter[experimentParameter];
run= CheckAbort[executeRun[run],Missing["Aborted run"]];
debugLastRun= run;
run
]

makeRunFromParameter[experimentParameter_] := Module[{lattice,run,arena,g,chainNumber},
lattice=experimentParameter["Lattice"];
If[MissingQ[lattice],
lattice = latticeOrthogonal[{0,1}]];
run = runFromLattice[lattice];
If[MissingQ[run],Print["mRFP Not implemented"];Abort[]];
run["Arena"] = makeArena[run,experimentParameter];

run
];

runFromRun[run_] :=  Module[{g,d,chain},
chain = Last[run["Chains"]];
g= chain["Chain"];

d = Map[ <|#->run["DiskData"][#]|>&,VertexList[g]];
<|"Arena"->run["Arena"],"ContactGraph"->g,"DiskData"->d|>

];

runFromLattice[lattice_] :=  Module[{g,d},
If[!(lattice["d"]==0 && lattice["h"] == 1),
Return[graphFromTCLattice[lattice]]];
g= Graph[ {left[1]\[UndirectedEdge]1,1\[UndirectedEdge]right[1]}];
d = <|1-><|"DiskNumber"->1,"Disk"->Disk[{0,0},0.5]|>|>;
<|"ContactGraph"->g,"DiskData"->d|>
];

graphFromTCLattice[lattice_] := Module[{m,n,r,disks,diskx,diskxy,disknxy,disksOn,disksOf,diskData,g},
{m,n}=First@Keys[lattice["parastichyNumbers"]];

r=Sqrt[N@lattice["parastichyNumbers"][{m,n}]] ;
disks= Map[Disk[#,r/2]&,lattice["namedLatticePoints"]];
diskx[Disk[{x_,_},_]]:=x;
diskxy[Disk[xy_,_]]:=xy;
disknxy[node_] := diskxy[disks[node]];
disknxy[left[node_]] := diskxy[disks[node]]+{-1,0};
disknxy[right[node_]] := diskxy[disks[node]]+{1,0};
disksOn= Flatten[Map[{#\[DirectedEdge]#-m,#\[DirectedEdge]#-n}&,Keys[lattice["namedLatticePoints"]]]];
disksOf[a_\[DirectedEdge]b_] := Module[ {d1,d2},
If[b<0,Return[Nothing[]]];
d1=disks[a];d2=disks[b];
If[Abs[diskx[d2]-diskx[d1]] <1/2, Return[a\[UndirectedEdge]b]];
If[diskx[d1]> 0,Return[a\[UndirectedEdge]right[b]], Return[a\[UndirectedEdge]left[b]]]
];
g=Graph[Map[disksOf,disksOn]];
g= Graph[g,VertexCoordinates->Map[disknxy[#]&,VertexList[g]],VertexLabels->"Name"];

diskData = Association@KeyValueMap[#1-><|"DiskNumber"->#1,"Disk"->#2|>&,disks];
<|"ContactGraph"->g,"DiskData"->diskData|>
];




(* ::Input::Initialization:: *)
smallestRadius[run_] := Min@Map[diskR[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];
highestCentre[run_] := Max@Map[diskZ[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];


makeArena[run_,runParameters_] := Module[{initialRadius,finalRadius,hBase,hStart,hEnd,rOfH,arenaAssociation},
initialRadius  = 0.5;
initialRadius= smallestRadius[run] ;
(*hBase =1;*)
hBase=highestCentre[run];
finalRadius= initialRadius/runParameters["rScale"];
{hStart,hEnd} = hBase + {0,hRangeNeeded[{initialRadius,finalRadius},runParameters["rSlope"]]};
rOfH =linearInterpolator[{hStart,hEnd},{initialRadius,-runParameters["rSlope"]}] ;

arenaAssociation=runParameters;
If[KeyMemberQ[arenaAssociation,"Lattice"],arenaAssociation=KeyDrop[arenaAssociation,"Lattice"]];
arenaAssociation = Append[arenaAssociation,
<| 
"rFunction"->rOfH
,"rFixedBefore"-> hStart
,"rFixedAfter"-> hEnd
,"CylinderLU"-> {0,runParameters["zMax"]}
|>];
arenaAssociation
];


linearInterpolator[{hStart_,hEnd_},{r_,rSlope_}] := 
Function[{h}, r+ Piecewise[ {
{0,h< hStart}
,{(h-hStart) * rSlope , h< hEnd}
, { (hEnd-hStart) * rSlope ,True}
}]];


hRangeNeeded[{rStart_,rEnd_},rSlope_] := Module[{hSlopeRange},
hSlopeRange = -(rEnd-rStart)/rSlope ;
hSlopeRange
];




(* ::Input::Initialization:: *)

makeExperimentParameters[rScaleRange_,rSlopeRange_,zMaxRange_] := Module[{experimentParameters},
experimentParameters = Flatten@Outer[<|"rScale"->#1,"rSlope"->#2,"zMax"-> #3,"diskMax"->\[Infinity]|>&,rScaleRange,rSlopeRange,zMaxRange];
experimentParameters = MapIndexed[Append[#1,"runNumber"->First[#2]]&,experimentParameters];
experimentParameters
];

runParameterSets[experimentParameters_] := 
Map[
Monitor[Append[#,"Results"->doParameterRun[#]],#]&,experimentParameters]
