(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];(*Get["CoinStackingCode.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}]
*)
Get["LatticePhyllotaxis.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}];



(* ::Input::Initialization:: *)


doParameterRun[experimentParameter_] := Module[{run},
run = makeRunFromParameter[experimentParameter];
run= CheckAbort[executeRun[run],Missing["Aborted run"]];
debugLastRun= run;
run
]

makeRunFromParameter[experimentParameter_] := Module[{lattice,run,arena,g,chainNumber},
lattice = latticeOrthogonal[{0,1}];
run = runFromLattice[lattice];
If[MissingQ[run],Print["mRFP Not implemented"];Abort[]];
run["Arena"] = makeArena[run,experimentParameter];

run
];
runFromLattice[lattice_] :=  Module[{g,d},
If[!(lattice["d"]==0 && lattice["h"] == 1),Return[Missing["Unimplemented"]]];
g= Graph[ {left[1]\[UndirectedEdge]1,1\[UndirectedEdge]right[1]}];
d = <|1-><|"DiskNumber"->1,"Disk"->Disk[{0,0},0.5]|>|>;
<|"ContactGraph"->g,"DiskData"->d|>
];





(* ::Input::Initialization:: *)
smallestRadius[run_] := Min@Map[diskR[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];


makeArena[run_,runParameters_] := Module[{initialRadius,finalRadius,hBase,hStart,hEnd,rOfH,arenaAssociation},
initialRadius  = 0.5;
hBase =1;
finalRadius= initialRadius/runParameters["rScale"];
{hStart,hEnd} = hBase + {0,hRangeNeeded[{initialRadius,finalRadius},runParameters["rSlope"]]};
rOfH =linearInterpolator[{hStart,hEnd},{0.5,-runParameters["rSlope"]}] ;

arenaAssociation = <| 
"rFunction"->rOfH
,"rFixedAfter"-> hEnd
,"zMax"->runParameters["zMax"]
,"CylinderLU"-> Missing[]
,"diskMax"-> runParameters["diskMax"]
|>;
arenaAssociation
];


linearInterpolator[{hStart_,hEnd_},{r_,rSlope_}] := 
Function[{h}, r+ Piecewise[ {
{0,h< hStart}
,{(h-hStart) * rSlope ,h>=hStart && h< hEnd}
, { (hEnd-hStart) * rSlope ,h>hEnd}
}]];


hRangeNeeded[{rStart_,rEnd_},rSlope_] := Module[{hSlopeRange},
hSlopeRange = -(rEnd-rStart)/rSlope ;
hSlopeRange
];




(* ::Input::Initialization:: *)

makeExperimentParameters[rScaleRange_,rSlopeRange_,zMaxRange_] := Module[{experimentParameters},
experimentParameters = Flatten@Outer[<|"rScale"->#1,"rSlope"->#2,"zMax"-> #3,"diskMax"->\[Infinity]|>&,rScaleRange,rSlopeRange,zMaxRange];
experimentParameters = MapIndexed[Append[#1,"runNumber"->First[#2]]&,experimentParameters];
experimentParameters
];

runParameterSets[experimentParameters_] := 
Map[
Monitor[Append[#,"Results"->doParameterRun[#]],#]&,experimentParameters]
