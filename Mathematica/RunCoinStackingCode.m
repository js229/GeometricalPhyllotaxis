(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];(*Get["CoinStackingCode.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}]
*)
Get["LatticePhyllotaxis.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}];



(* ::Input::Initialization:: *)


doParameterRun[experimentParameter_] := Module[{run},
run = makeRunFromParameter[experimentParameter];
run= CheckAbort[executeRun[run],Missing["Aborted run"]];
debugLastRun= run;
run
]

makeRunFromParameter[experimentParameter_] := Module[{lattice,run,arena,g,chainNumber},
lattice = latticeOrthogonal[{0,1}];
run = runFromLattice[lattice];
If[MissingQ[run],Print["mRFP Not implemented"];Abort[]];
run["Arena"] = makeArena[run,experimentParameter];

run
];
runFromLattice[lattice_] :=  Module[{g,d},
If[!(lattice["d"]==0 && lattice["h"] == 1),Return[Missing["Unimplemented"]]];
g= Graph[ {left[1]\[UndirectedEdge]1,1\[UndirectedEdge]right[1]}];
d = <|1-><|"DiskNumber"->1,"Disk"->Disk[{0,0},0.5]|>|>;
<|"ContactGraph"->g,"DiskData"->d|>
];





(* ::Input::Initialization:: *)
smallestRadius[run_] := Min@Map[diskR[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];


makeArena[run_,runParameters_] := Module[{arenaAssociation,cylinderLU
,r,hBase,hStart,hEnd},
r= smallestRadius[run];

{hBase,hStart,hEnd} =  hRangeNeeded[highestDiskZ[run],smallestRadius[run],runParameters["rSlope"],runParameters["rScale"]];
If[hEnd> runParameters["zMax"],
Print["run stops while r still changing"]
,
Print["r fixed after",hEnd]

];
cylinderLU = {hBase- 2 r, runParameters["zMax"]};

arenaAssociation = <| 
"rFunction"->createRofH[highestDiskZ[run],smallestRadius[run],runParameters["rSlope"],runParameters["rScale"]]
,"rFixedAfter"-> hEnd
,"CylinderLU"-> cylinderLU
,"diskMax"-> runParameters["diskMax"]
|>;
arenaAssociation
];

createRofH[zMax_,rStart_,rSlope_,rScale_] := Module[{r,hBase,hStart,hEnd},
{hBase,hStart,hEnd} = hRangeNeeded[zMax,rStart,rSlope,rScale];
linearInterpolator[{hStart,hEnd},{rStart,-rSlope}] 
];

linearInterpolator[{hStart_,hEnd_},{r_,rSlope_}] := 
Function[{h}, r+ Piecewise[ {
{0,h< hStart}
,{(h-hStart) * rSlope ,h>=hStart && h< hEnd}
, { (hEnd-hStart) * rSlope ,h>hEnd}
}]];


hRangeNeeded[zBase_,rStart_,rSlope_,rScale_] := Module[{r,rEnd,hBase,hStart,hEnd,hSlopeRange},
r = rStart;
rEnd = r/rScale;
hSlopeRange = -(rEnd-r)/rSlope ;
hBase = zBase; 
hStart = hBase + 2 * r;
hEnd = hStart+ hSlopeRange;
{hBase,hStart,hEnd} 

];




(* ::Input::Initialization:: *)

makeExperimentParameters[rScaleRange_,rSlopeRange_,zMaxRange_] := Module[{experimentParameters},
experimentParameters = Flatten@Outer[<|"rScale"->#1,"rSlope"->#2,"zMax"-> #3,"diskMax"->\[Infinity]|>&,rScaleRange,rSlopeRange,zMaxRange];
experimentParameters = MapIndexed[Append[#1,"runNumber"->First[#2]]&,experimentParameters];
experimentParameters
];

runParameterSets[experimentParameters_] := 
Map[
Monitor[Append[#,"Results"->doParameterRun[#]],#]&,experimentParameters]
