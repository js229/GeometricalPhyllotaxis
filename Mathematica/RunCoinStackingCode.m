(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];Get["CoinStackingCode.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}]
Get["LatticePhyllotaxis.m",Path->{PersistentSymbol["persistentGitHubPath","Local"]}];



(* ::Input::Initialization:: *)
makeArena[run_,runParameters_] := Module[{arenaAssociation,cylinderLU
,r,hBase,hStart,hEnd},
r= smallestRadius[run];
{hBase,hStart,hEnd} =  hRangeNeeded[highestDiskZ[run],smallestRadius[run],runParameters["rSlope"],runParameters["rScale"]];
If[hEnd> runParameters["zMax"],
Print["run stops while r still changing"];];
cylinderLU = {hBase- 2 r, runParameters["zMax"]};

arenaAssociation = <| 
"rFunction"->createRofH[highestDiskZ[run],smallestRadius[run],runParameters["rSlope"],runParameters["rScale"]]
,"ChainMax"-> "Fill"
,"rFixedAfter"-> hEnd
,"CylinderLU"-> cylinderLU
,"ExcludePreviousIntersectors"->False (* if r is fixed changing this optimises but can fail for r variable *)
|>;
arenaAssociation
];



(* ::Input::Initialization:: *)


runFromLattice[lattice_] := Module[{graphXY,graphR,nodesAsDisks,run,g,lNode,lrNodePath,subg,cylinderLU,rFunction,arenaAssociation,bareNodes},
g = graphFromLattice[lattice];
graphXY[node_] := AnnotationValue[{g,node},VertexCoordinates];
graphR[node_] :=  AnnotationValue[{g,node},"DiskRadius"];
nodesAsDisks = Map[Disk[graphXY[#],graphR[#]]&,VertexList[g]];
nodesAsDisks = SortBy[nodesAsDisks,graphXY[#]&];
nodesAsDisks = Association@MapIndexed[(First[#2]-> #1)&,nodesAsDisks];
run = <|"CurrentDisks"->nodesAsDisks|>;

lNode = First[Cases[VertexList[g],left[_]]];
lrNodePath = First@FindPath[g,lNode,bareNumber[lNode]];
subg = Subgraph[g,lrNodePath];
bareNodes = Select[lrNodePath,#==bareNumber[#]&];
run["CurrentDisks"] = KeyTake[run["CurrentDisks"] ,bareNodes];
run ["ContactGraph"] = subg;
run ["ContactGraph"] = g;

run
];

linearInterpolator[{hStart_,hEnd_},{r_,rSlope_}] := 
Function[{h}, r+ Piecewise[ {
{0,h< hStart}
,{(h-hStart) * rSlope ,h>=hStart && h< hEnd}
, { (hEnd-hStart) * rSlope ,h>hEnd}
}]];

createRofH[zMax_,rStart_,rSlope_,rScale_] := Module[{r,hBase,hStart,hEnd},
{hBase,hStart,hEnd} = hRangeNeeded[zMax,rStart,rSlope,rScale];
linearInterpolator[{hStart,hEnd},{rStart,-rSlope}] 
];


hRangeNeeded[zBase_,rStart_,rSlope_,rScale_] := Module[{r,rEnd,hBase,hStart,hEnd,hSlopeRange},
r = rStart;
rEnd = r/rScale;
hSlopeRange = -(rEnd-r)/rSlope ;
hBase = zBase; 
hStart = hBase + 2 * r;
hEnd = hStart+ hSlopeRange;
{hBase,hStart,hEnd} 

];




(* ::Input::Initialization:: *)


graphFromLattice[lattice_] := Module[{r,primary,run,lefts,rights,nodes,isConnected,edges,g},
If[lattice["d"]==0 && lattice["h"] == 1,
g= Graph[ {left[1]\[UndirectedEdge]1,1\[UndirectedEdge]right[1]},VertexCoordinates->{{-1,0},{0,0},{1,0}}];
(*g= Graph[ {1\[UndirectedEdge]right[1]},VertexCoordinates->{{0,0},{1,0}}];
*)(*g= Graph[ {left[1]\[UndirectedEdge]1,left[1]\[UndirectedEdge]2,1\[UndirectedEdge]2},VertexCoordinates->{{-1,0},{0,0},{-1/2,Sqrt[3]/2}}];
*)
AnnotationValue[{g,VertexList[g]},"DiskRadius"] = 1.0;
,Return[Missing["Unimplemented"]];
];
g = Graph[g,PlotTheme->"Labeled",
VertexStyle->Directive[EdgeForm[None],FaceForm[None]],
VertexLabels->Placed[Automatic,Center]];
g = Graph[g,AnnotationRules->Map[#->{EdgeStyle->Gray}&,EdgeList[g]]];
g

];






(* ::Input::Initialization:: *)

doParameterRun[experimentParameter_] := Module[{run},
run = makeRunFromParameter[experimentParameter];

run= CheckAbort[executeRun[run],Missing["Aborted run"]];
debugLastRun= run;
run
]

makeRunFromParameter[experimentParameter_] := Module[{lattice,run,arena,g,chainNumber},
lattice = latticeOrthogonal[{0,1}];
run = runFromLattice[lattice];
If[MissingQ[run],Print["mRFP Not implemented"];Abort[]];
run["Arena"] = makeArena[run,experimentParameter];

g=run["ContactGraph"];
chainNumber=1;

run = Append[run,
<|

"PastDisks"-> Association[]
,"Parastichy"-> Association[]
,"CompletedChainGraphs"-> <|chainNumber->g|>
,"CompletedChainNodePaths" -> <|chainNumber->{}|>
,"UsedOverlaps"->{}
,"CurrentChain"->{}
,"CurrentChainGraph"->Missing[]
|>
];
run
];




(* ::Input::Initialization:: *)

makeExperimentParameters[rScaleRange_,rSlopeRange_,zMaxRange_] := Module[{experimentParameters},
experimentParameters = Flatten@Outer[<|"rScale"->#1,"rSlope"->#2,"zMax"-> #3|>&,rScaleRange,rSlopeRange,zMaxRange];
experimentParameters = MapIndexed[Append[#1,"runNumber"->First[#2]]&,experimentParameters];
experimentParameters
];

runParameterSets[experimentParameters_] := 
Map[
Monitor[Append[#,"Results"->doParameterRun[#]],#]&,experimentParameters]
