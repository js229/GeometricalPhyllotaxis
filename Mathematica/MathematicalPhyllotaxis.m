(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic]


(* ::Input::Initialization:: *)
mpEuclideanQCoefficients[{m_,n_}] := Module[{r,q,i,j},
	i=0;
	r[-1]=n; 
	r[0] = m;
	While[r[i] > 0  , 
		q[i] = Floor[r[i-1]/r[i]];
		r[i+1] = r[i-1] - q[i]*r[i];
		i++;
	];
 Table[q[j],{j,0,i-1}]
];

mpEuclideanMatrixProduct[mn_] := Module[{q,res,eMatrix,sMatrix},
eMatrix = ({
 {1, 1},
 {0, 1}
});sMatrix=({
 {0, 1},
 {1, 0}
});
q = mpEuclideanQCoefficients[mn];
res= (Map[  MatrixPower[eMatrix,#] . sMatrix &,q]);
res= If[Length[res]>0,Dot@@res,IdentityMatrix[2]];
res
];

mpWindingNumberPair[mn_] := Module[{m,n,u,v},
{{n,v},{m,u}}=mpEuclideanMatrixProduct[mn];
{u,v}
];

mpDelta[mn_]:= -1 * If[EvenQ[Length[mpEuclideanQCoefficients[mn]]],1,-1];



(* ::Input::Initialization:: *)
mpTouchingCircleCentre[{m_,n_}] := Module[{u,v},
{u,v}=mpWindingNumberPair[{m,n}];
{Abs[ m u - n v]/(n^2-m^2),0}
];
mpTouchingCircleRadius[{m_,n_}] := Module[{},
1/(n^2-m^2)
];
mpTouchingCircle[mn_] := Circle[mpTouchingCircleCentre[mn],mpTouchingCircleRadius[mn],{0,\[Pi]}];

mpTouchingCircleTanPsiOfTheta[{m_,n_}][\[Theta]_] := ((m^2-n^2) Sin[\[Theta]])/(-2 m n+(m^2+n^2) Cos[\[Theta]]);
mpTouchingCirclePsiOfTheta[{m_,n_}][\[Theta]_] := Module[{atan},
atan=ArcTan[mpTouchingCircleTanPsiOfTheta[{m,n}][\[Theta]]];
If[atan<0,atan=atan+\[Pi]];
atan
] ;
mpTouchingCircleHexagonalPointPsiOne[{m_,n_}] := 
mpTouchingCirclePsiOfTheta[{m,n}][\[Pi]/3]
mpTouchingCircleHexagonalPointPsiTwo[{m_,n_}] := 
mpTouchingCirclePsiOfTheta[{m,n}][2 \[Pi]/3]

(* needs to be Delta aware to get the right orientation *)
mpTouchingCirclePrimary[{m_,n_}] :=Module[{},
If[mpDelta[{m,n}]==1,
psione= \[Pi]- mpTouchingCircleHexagonalPointPsiOne[{m,n}];
psitwo = \[Pi]- mpTouchingCircleHexagonalPointPsiTwo[{m,n}];
,
psione= mpTouchingCircleHexagonalPointPsiOne[{m,n}];
psitwo = mpTouchingCircleHexagonalPointPsiTwo[{m,n}];
];
Circle[mpTouchingCircleCentre[{m,n}],mpTouchingCircleRadius[{m,n}],{psione,psitwo}]
];

mpTouchingCirclePrimaryNonOpposed[mn_]:= vanItersonTouchingCirclePrimaryNonOpposed[mn];

Clear[mpTouchingCirclePrimaryOpposed];
mpTouchingCirclePrimaryOpposed[{m_,n_}]:= mpTouchingCirclePrimaryOpposed[{n,m}] /; m>n
mpTouchingCirclePrimaryOpposed[{m_,n_}] := mpTouchingCirclePrimary[{m,n}] /; m> n/2
mpTouchingCirclePrimaryOpposed[{m_,n_}] := Module[{centre,radius,psis,psilower,psihigher},
{centre,radius,psis}= List@@ mpTouchingCirclePrimary[{m,n}];
{psilower,psihigher}=psis;
psi=ArcCos[m/n];
If[!IntervalMemberQ[Interval[psis],psi],psi=\[Pi]-psi];
Circle[centre,radius,{psi,psihigher}]
]

mpTouchingCirclePrimaryNonOpposed[{m_,n_}]:= mpTouchingCirclePrimaryNonOpposed[{n,m}] /; m>n
mpTouchingCirclePrimaryNonOpposed[{m_,n_}] := Nothing[] /; m> n/2
mpTouchingCirclePrimaryNonOpposed[{m_,n_}] := Module[{centre,radius,psis,psilower,psihigher},
{centre,radius,psis}= List@@ mpTouchingCirclePrimary[{m,n}];
{psilower,psihigher}=psis;
psi=ArcCos[m/n];
If[!IntervalMemberQ[Interval[psis],psi],psi=\[Pi]-psi];
Circle[centre,radius,{psi,psilower}]
]



