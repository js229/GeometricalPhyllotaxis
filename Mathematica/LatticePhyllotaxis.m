(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
euclideanQCoefficients[{0,1}] := {}; (* actually this is implied by algo anyway, but being explicit *)

euclideanQCoefficients[{m_,n_}] := Module[{r,q,i},
i=0;
r[-1]=n; (* in this order so that if m<n then get no initial zero *)
r[0] = m;
While[r[i] > 0  ,
q[i] = Floor[r[i-1]/r[i]];
r[i+1] = r[i-1] - q[i] r[i];
i++;
];
 Table[q[j],{j,0,i-1}]
];

euclideanUVcoefficients[{}] := {{1,0}}; (* ie for m,n=0,1 ; m v - n u = -1 *)
euclideanUVcoefficients[q_] := Module[{i,u,v,qfunc},
i=0;
u[-1]=1; v[-1]=0; 
u[0] = 0; v[0]=1;
qfunc[i_] := q[[i+1]]; (* qfunc indexes from 0, just to match recurrence used in text  *)
For[i=1,i<= Length[q], i++,
u[i] = u[i-2] + qfunc[i-1] u[i-1];
v[i] = v[i-2] + qfunc[i-1] v[i-1];
];(*u[1] = 1; v[1] = q[0];*)
Table[{u[i],v[i]},{i,0,Length[q]}]
];

makeEuclideanProductMatrix[q_] := Module[{A,P,qfunc,i},
qfunc[i_] := q[[i+1]]; (* qfunc indexes from 0 *)
A[i_] := {{ 0,1},{1,-qfunc[i]}};
P = IdentityMatrix[2];
For[i=0,i<Length[q],i++,
P = A[i] . P;
];
P
];

euclideanProductMatrix[mn_] :=   makeEuclideanProductMatrix[euclideanQCoefficients[mn]];

euclideanHCF[mn_] := Module[{res},
res =  euclideanProductMatrix[mn]  .  Reverse[mn ]; (* because of the r-order above *) 
If[res[[2]] !=0 , Abort[]];
First[res]
];

euclideanDelta[mn_] := Module[{q,res},
q = euclideanQCoefficients[mn];
If[OddQ[Length[q]],1,-1]
];


(* ::Input::Initialization:: *)
euclideanUVDirect[mn_] :=Module[{q,uvList},
q = euclideanQCoefficients[mn];
uvList = euclideanUVcoefficients[q]; (* length 1 + length[q], unless q={} when {0,1}} *)
uv= uvList[[ Max[1,Length[q]] ]] ;
uv
];

(*  m v - n u = hcf(m,n); 0\[LessEqual]u<m, 0\[LessEqual]v<n apart from the m=0 case *) 
(* in particular wnp has m v - n u = +1 regardless of euclideanDelta *)
windingNumberPair[{0,0}] := {\[Infinity],\[Infinity]};
windingNumberPair[{0,n_}] := {-1,0};
windingNumberPair[{m_,0}] := {0,1};
windingNumberPair[{m_,n_}] := Module[{u,v,Delta},
{u,v} = euclideanUVDirect[{m,n}];
Delta = m v - n u;
If[Delta>0,Return[{u,v}]];
{u,v} = {m - u, n - v};
Return[{u,v}]
];

euclideanUV[mn_] := euclideanUVDirect[mn]; 
euclideanUV[mn_,ForDelta_] := Module[{mnDelta,uv},
(* Euclid yields a pair with mv - nu= \[PlusMinus] 1 but we don't know the sign *)
If[euclideanDelta[mn]==ForDelta,
uv= euclideanUVDirect[mn],
uv = Reverse[ euclideanUVDirect[Reverse[mn]]]
];
uv
];


(* ::Input::Initialization:: *)
(*euclideanProof[mn_] := Module[{uv,str},
uv = euclideanUV[mn];str = StringTemplate["``*``-``*``=``"][mn[[1]],uv[[2]],mn[[2]],uv[[1]],mn[[1]]*uv[[2]]-mn[[2]]*uv[[1]]];{str,euclideanDelta[mn]}
];

*)


(* ::Input::Initialization:: *)
mnuvi[m_,n_,u_,v_] := Module[{dmaster,minterval,ninterval},
(* interval on which [md]=u and [nd]=v *)
dmaster = Interval[{0,1/2}];
minterval =  (u+Interval[ {-1/2,1/2}])/m;
ninterval =  (v+Interval[ {-1/2,1/2}])/n;
IntervalIntersection[dmaster,minterval,ninterval]
];generatingInterval[{m_,n_}] :=  Module[{u,v,up,vp,resplus,resminus,res,dmaster},
dmaster = Interval[{0,1/2}];
{u,v }= windingNumberPair[{m,n}];

resplus=mnuvi[m,n,u,v];
vp = n-v; up = m- u;
resminus =mnuvi[m,n,up,vp];
res = IntervalUnion[resminus,resplus];
res];
generatingOpposedInterval[{m_,n_}] := Module[{res,u,v},
{u,v}=windingNumberPair[{m,n}];
res  = If[m==1, Interval[{1/(2n),1/n}],
Interval[{u/m,v/n}]
];
If[Min[res]>= 1/2,res = 1-res];
res
];


(* ::Input::Initialization:: *)
euclideanReduction[pq_]  := Module[{uv,it,firstShorter,dotPositive,reduceSecond,isPrincipal,positiveRise,positiveVec},
firstShorter[{u_,v_}] := Module[{u2=Simplify[u . u],v2=Simplify[v . v]},If [ u2 < v2, {u,v},{v,u}]];
dotPositive[{u_,v_}] := If [ u . v > 0, {u,v},{u,-v}];
reduceSecond[{u_,v_}] := If[ Abs[u . (v-u)]  >  Abs[u . v ],{u,v},{u,u-v}];	
isPrincipal[{u_,v_}] := Module[{u2=Simplify[u . u],v2=Simplify[v . v]},
u2  <=  v2 && 0  <= u . v && u . v <= u2 /2
] ;
positiveRise[uvp_] := Map[positiveVec,uvp];
positiveVec[{ud_,uh_}] := If[uh>0,{ud,uh},
If[uh<0,{-ud,-uh}, (* h=0 *) {Abs[ud],0}]];
uv = pq;
it=1;While[!isPrincipal[uv], 
{
it++;  If[it>20,Break[]];
uv = firstShorter[uv];
uv = dotPositive[uv];
uv = reduceSecond[uv];
uv = Simplify /@uv ;
}];

uv = firstShorter[uv]; (* not needed but just to be clear *) 
uv = positiveRise[uv]; (* only do this at the end ! *)
uv
];


(* ::Input::Initialization:: *)
euclideanShortestPair[{pm_,pn_}] := 
(* in the lattice generated by pm and pn, what is the shortest pair ? *)
euclideanReduction[{pm,pn}];

tgetPrincipalVectorsDH[{d_,h_}] := Module[{uv},
uv= {{d,h}, {1-d,-h}}; (* (1,0) and (d,h) are a generating pair *)
euclideanShortestPair[uv]
];

vectorNorm2[x_] := Simplify[x . x]; 

tgetThreeParastichyVectorsDH[{d_,h_}] := 
Module[{pv,psum,pdiff,pthird,pvectors},
pv=tgetPrincipalVectorsDH[{d,h}];
psum = pv[[1]]+pv[[2]];
pdiff = pv[[1]]-pv[[2]]; If[pdiff[[2]] <0, pdiff = -pdiff];
pthird = If[vectorNorm2[psum]<= vectorNorm2[pdiff],psum,pdiff];
pvectors = Append[pv,pthird]; (* sometimes the fourth can be the same length as the third but we don't need to mark this *)
numberate[pvectors, h]
];
rawpnumber[v_,h_] :=  Module[{m,d},
If[v=={1,0},Return[0]];

m =Abs[Round[v[[2]]/h ]];
d = v[[1]];
(* if d=-1/2, then there is another parastichy vector with d=1/2; if d not in [-1/2,1/2] also a complementary vector *)
If[d== -1/2 || Round[d] != 0, m = hat[m]];
m
];
numberate[pvectors_, h_] := Module[{pnumbers,onepos,hatpos},pnumbers = Map[rawpnumber[#,h]&,pvectors];
onepos = Position[pnumbers,1,1];If[Length[onepos]>= 2, hatpos = onepos[[2]]; pnumbers[[hatpos]] = hat[1]];Association[Map[#[[1]]->#[[2]] &,Transpose[{pnumbers,pvectors}]]]
];



(* ::Input::Initialization:: *)
latticeCreateDH[{d_,0}] := Nothing; (* silently drop from lists *) 

latticeCreateDH[{d_,h_},cylinderLU_:{-0.2,3.2},firstnEqual_:1]  :=  Module[{lattice},
lattice = Association [
"d"-> d
,"h"-> h
,"cylinder" -> { {-1/2,1/2},cylinderLU} 
(* always has periodicity (1,0); this is how much of it we display *) ,"parastichyVectors" ->  tgetThreeParastichyVectorsDH[{d,h}]
,"scalings"-> <||>
];
lattice =Prepend[lattice,{ "parastichyNumbers"-> tgetParastichyNumbersGroupedByLength[lattice,firstnEqual]}];
lattice
];




(* ::Input::Initialization:: *)

tgetParastichyNumbersGroupedByLength[lattice_,firstnEqual_] := Module[{pv,pvlengths,pva,i}, 
pv = latticeParastichyVectors[lattice];pvlengths =Map[vectorNorm2,pv];
pvlengths = SortBy[pvlengths,N];
(*  only if we make eg hexagonal lattices, the lengths may be algebraically but not numerically equal so we force them *)
For[i=2,i<=firstnEqual,i++,
pvlengths[[i]] = pvlengths[[1]]
];
pva = GroupBy[pvlengths,Identity,Sort[Keys[#]]&];Association[Map[ pva[#]-> # &, Keys[pva]]]
];

latticeParastichyNumbersGroupedByLength[lattice_] := Keys[lattice["parastichyNumbers"]];

latticeParastichyNumbers[lattice_] := Module[{pnumbers}, 
pnumbers =latticeParastichyNumbersGroupedByLength[lattice];Flatten[Map[Sort,pnumbers]]
];




(* ::Input::Initialization:: *)
latticeGetCylinder[lattice_] := lattice["cylinder"];
latticeGetCylinderLU[lattice_] := lattice["cylinder"][[2]];
latticeSetCylinderLU[lattice_,cylinderLU_] := Module[{res,cyl},
res =lattice;
cyl= lattice["cylinder"];
cyl[[2]] = cylinderLU;
res["cylinder"] = cyl;
res
];



(* ::Input::Initialization:: *)
latticeLabel[lattice_] := latticeParastichyNumbersGroupedByLength[lattice];
latticeLabelText[lattice_] := Module[{ll,tos},
ll =  latticeLabel[lattice] ;

tos[hat[n_]] := "\!\(\*OverscriptBox[\(" <> ToString[n] <> "\), \(^\)]\)";
tos[n_] := ToString[n];

(*tos[x_] := If[x===hat[1],"\!\(\*OverscriptBox[\(1\), \(^\)]\)",ToString[x]];*)
ll = Map[tos,ll,{2}];ll = Map[StringRiffle[#,"="]&,ll];ll = StringRiffle[Take[ll,UpTo[2]],","]
];


latticeLabelPosition[lattice_] := Module[{cyl},
cyl=latticeGetCylinder[lattice];
{cyl[[1,1]],cyl[[2,2]]} (* top left *)
];

latticeParastichyVectors[lattice_] := lattice["parastichyVectors"];

latticePrincipalParastichyPair[lattice_] := Take[latticeParastichyNumbers[lattice],2];
latticePrincipal3ParastichyNumbers[lattice_] :=Take[latticeParastichyNumbers[lattice],3]


(* ::Input::Initialization:: *)
latticePoints[lattice_] :=  Module[{nmin,nmax,irange,points,h,cylinderLU},h = lattice["h"];cylinderLU=lattice["cylinder"][[2]];{nmin,nmax}= {Ceiling[Min[cylinderLU]/h],Floor[Max[cylinderLU]/h]};irange = {nmin,nmax};points = N@Flatten[Table[latticePointWithCopies[lattice,i],{i,nmin,nmax}],1];
points
];

latticeGraphicPoints[lattice_] :=  Point[latticePoints[lattice]];
latticeGraphicsPoint[lattice_,m_] :=  Point[latticePoint[lattice,m]];



(* ::Input::Initialization:: *)
mod[x_] :=  x - Round[x];

lpoint[{d_,h_},m_] := { mod [d m] , m h};
lpoint[{d_,h_},hat[m_]] := Module[{j,jp,jm},
j = lpoint[{d,h},m]; jp = j - {1,0}; jm = j+ {1,0}; (* should just test j[[1]]>0... *) 
If[ jp . jp < jm . jm, jp,jm]
];



latticePoint[lattice_,m_] :=lpoint[{lattice["d"],lattice["h"]},m];
latticePointWithCopies[lattice_,m_] := Module[{cylinder,lp,i,x},
(* including periodic copies within the display cylinder *) 
cylinder = latticeGetCylinder[lattice];
lp = latticePoint[lattice,m];
If[cylinder[[1]]== {-1/2,1/2},Return[{lp}]]; (* should be the same *)
x = lp[[1]];
Return[Table[lp + i {1,0},{i,Ceiling[cylinder[[1,1]]-x],Floor[cylinder[[1,2]]-x]}]]
];

latticeVector[lattice_,m_] :=If[zeroParastichyQ[m],{1,0},latticePoint[lattice,m]];


(* ::Input::Initialization:: *)
latticePointH[lattice_,m_] := latticePoint[lattice,m][[2]];
latticePointD[lattice_,m_] := latticePoint[lattice,m][[1]];
latticeRise[lattice_] := latticePointH[lattice,1]; (* will be the same as lattice["h"] for h > 0 *) 
latticeDivergence[lattice_] := latticePointD[lattice,1]; (* will be the same as lattice["d"] for -1/2<d<1/2 *) 
latticeVectorLength[lattice_,m_] :=  Norm[ latticeVector[lattice,m]];


(* ::Input::Initialization:: *)
latticePrincipal3ParastichyLines[lattice_] := Map[latticeParastichyLines[lattice,#]&,latticePrincipal3ParastichyNumbers[lattice]];

latticePrincipalParastichyLines[lattice_] := Map[latticeParastichyLines[lattice,#]&,latticePrincipalParastichyPair[lattice]];

barem[m_] :=m /. hat -> Identity;
zeroParastichyQ[m_] := barem[m] == 0;

latticeParastichySlope[lattice_,m_] := Module[{parastichyVectorM,pSlope},
parastichyVectorM = latticePoint[lattice,m];
 If[parastichyVectorM[[1]]==0 ,Return[\[Infinity]]];
parastichyVectorM[[2]]/parastichyVectorM[[1]]
];

latticeParastichyVerticalSeparation[lattice_,m_] := Module[{parastichyVectorM,pSlope},
 If[zeroParastichyQ[m],Return[latticeRise[lattice]]];
parastichyVectorM = latticePoint[lattice,m];
 If[parastichyVectorM[[1]]==0 ,Return[0]];
pSlope = parastichyVectorM[[2]]/parastichyVectorM[[1]];
latticeRise[lattice]/pSlope
];

latticeParastichyHorizontalSeparation[lattice_,m_] := Module[{},
If[zeroParastichyQ[m],Return[1]];
1/barem[m]
];



(* ::Input::Initialization:: *)
linelineIntersection[line1_,line2_] := Module[{x1,y1,x2,y2,x3,y3,x4,y4,x,y,m1,m2},
{ {x1,y1},{x2,y2} } = line1;
{{ x3,y3},{x4,y4}} = line2;
m1 = { {x,y,1},{x1,y1,1},{x2,y2,1}};
m2 = {{ x,y,1},{x3,y3,1},{x4,y4,1}};
{x,y}  /. Solve[{Det[m1]==0,Det[m2]==0},{x,y}][[1]]
];



(* ::Input::Initialization:: *)
latticeParastichyCylinderIntersection[lattice_,m_,type_] :=Module[{arena,arenaBottomIntersection,arenaTopIntersection},
If[zeroParastichyQ[m],Abort[]];
arena = latticeGetCylinder[lattice];
arenaBottomIntersection = linelineIntersection[
{{  arena[[1,1]], arena[[2,1]]},{ arena[[1,2]],arena[[2,1]]}},
{ {0,0},  latticeVector[lattice,m]}][[1]];
arenaTopIntersection = linelineIntersection[
{{  arena[[1,1]], arena[[2,2]]},{ arena[[1,2]],arena[[2,2]]}},
{ {0,0},  latticeVector[lattice,m]}][[1]];
If[type===Bottom,
arenaBottomIntersection,arenaTopIntersection]
];


(* ::Input::Initialization:: *)

latticeParastichyXZThrough[lattice_,m_] :=  Module[{arena,ilowerB, iupperB,translationD,arenaBottomIntersection},
arena = latticeGetCylinder[lattice];
If[zeroParastichyQ[m],
translationD = latticeParastichyVerticalSeparation[lattice,0];ilowerB = -Floor[(  - arena[[2,1]])/translationD];iupperB = Floor[(arena[[2,2]])/ translationD];
Return[Table[{arena[[1,1]],i *  translationD},{i,ilowerB,iupperB}]]
];
(* or a slope *)
translationD= Abs[latticeParastichyHorizontalSeparation[lattice,m]];

arenaBottomIntersection = linelineIntersection[{{  arena[[1,1]], arena[[2,1]]},{ arena[[1,2]],arena[[2,1]]}},{ {0,0},  latticeVector[lattice,m]}][[1]];ilowerB = -Floor[( arenaBottomIntersection - arena[[1,1]])/translationD];iupperB = Floor[(arena[[1,2]]- arenaBottomIntersection )/ translationD];Return[Table[{arenaBottomIntersection+ i *  translationD,arena[[2,1]]},{i,ilowerB,iupperB}]]

];


(* ::Input::Initialization:: *)
latticeParastichyLines[lattice_,m_] :=  Module[{xtable },
xtable= latticeParastichyXZThrough[lattice,m];
 Map[latticeParastichyLinesThroughXZ[lattice,m,#]&,xtable]
];
latticeParastichyLines[lattice_,m_,k_] := latticeParastichyLinesThroughXZ[lattice,m,latticePoint[lattice,k]];


(* ::Input::Initialization:: *)
latticeParastichyLinesThroughXZ[lattice_,m_,throughxz_] := Module[{pvecslope,bottom,top,cylinder,cylinderLU,line,i,lastXZ,nextX,nextZ,v},

cylinder = latticeGetCylinder[lattice];cylinderLU = cylinder[[2]];If[zeroParastichyQ[m], (* parastichy is horizontal *)
line = {{cylinder[[1,1]],throughxz[[2]]},{cylinder[[1,2]],throughxz[[2]]}},
(* or *) 
If[latticePoint[lattice,m][[1]]==0, (* parastichy is vertical *) 
line ={ {throughxz[[1]],cylinder[[2,1]]},{throughxz[[1]],cylinder[[2,2]]}},
(* or general case *) 
pvecslope = latticeParastichySlope[lattice,m];bottom = { (cylinderLU[[1]]-throughxz[[2]])/pvecslope +throughxz[[1]], cylinderLU[[1]]};top        = { (cylinderLU[[2]]-throughxz[[2]])/pvecslope+throughxz[[1]],cylinderLU[[2]]};
line = {};
lastXZ = bottom;
i=0;
While[
nextX = If[pvecslope>0, cylinder[[1,2]],cylinder[[1,1]] ];
nextZ = lastXZ[[2]]+(nextX-lastXZ[[1]])* pvecslope; (* assumes cylinder width a multiple of 1 *)
If[nextZ> cylinder[[2,2]],
nextZ =  cylinder[[2,2]];
nextX = lastXZ[[1]]+(nextZ-lastXZ[[2]])/pvecslope
];
line = Append[line,{lastXZ,{nextX,nextZ}}];
i++;
i< 50 && nextZ  < cylinder[[2,2]],
(* While body *)
lastXZ = Last@Last[line];
lastXZ[[1]] = If[pvecslope>0, cylinder[[1,1]],cylinder[[1,2]] ]
]
]
];

Line[line]
];




(* ::Input::Initialization:: *)
latticeParallelogram[lattice_,m_,n_,through_] :=Module[{origin,pm,pn},
origin = latticePoint[lattice,through]; pm=latticePoint[lattice,m];pn=latticePoint[lattice,n];
 { origin, origin+pm,origin+pm+pn,origin+pn,origin}
];


latticeGraphicsCylinder[lattice_] :=  Rectangle @@ Transpose[latticeGetCylinder[lattice]];
latticeGraphicsPlotRange[lattice_] :=  latticeGetCylinder[lattice];



(* ::Input::Initialization:: *)
latticeSetScaling[lattice_,funcNameValue_] := 
Module[{res},
res = lattice;
res["scalings"] = AppendTo[res["scalings"],funcNameValue];
res
];
latticeScaling[lattice_,type_] :=lattice["scalings"][type];


latticeDisk[lattice_] := Module[{cylinderLU,func,innerOuter},
cylinderLU = latticeGetCylinderLU[lattice];
func[z_] := latticeScaling[lattice,"Disk"][{0,z}][[1]];
innerOuter = Map[func,Reverse[cylinderLU]];
innerOuter= Map[Ramp,innerOuter];
innerOuter = Sort[innerOuter];
If[First@innerOuter==0,Disk[{0,0},Last[innerOuter]],Annulus[{0,0},innerOuter]]
];

latticeArenaRegion[lattice_] := Module[{region,cylinder},
cylinder= latticeGetCylinder[lattice];
region =ParametricRegion[latticeScaling[lattice,"Arena"][{x,z}],{{x,cylinder[[1,1]],cylinder[[1,2]]},{z,cylinder[[2,1]],cylinder[[2,2]]}}];
region
];

(* for stem, same as euclidean lattice *)
latticeStemRegion[lattice_] :=  Rectangle@@Transpose@latticeGetCylinder[lattice]



latticePoints[lattice_,type_] :=  Map[latticeScaling[lattice,type],latticePoints[lattice]]



latticeParastichyFunction[lattice_,m_,k_,type_] := Module[{cylinderLU,xInner,xOuter,data,xzfunc,scalefunc,func},
scalefunc = latticeScaling[lattice,type];
If[type=="Disk", (* mapping to periodic coordinates *)
cylinderLU= latticeGetCylinderLU[lattice];
xOuter = latticeParastichyCylinderIntersection[lattice,m,Bottom]+ k * latticeParastichyHorizontalSeparation[lattice,m];
xInner = xOuter + (cylinderLU[[2]]-cylinderLU[[1]])/latticeParastichySlope[lattice,m];
data = { { {0}, {xOuter,cylinderLU[[1]]}},{{1},{xInner,cylinderLU[[2]]}}};
xzfunc = Interpolation[data,InterpolationOrder->1];
func = Function[{t},scalefunc[xzfunc[t]]];
, (* for "Arena", "Stem", need the image of the parastichy line in the cylinder *) 
segments =First[List@@latticeParastichyLines[lattice,m,k]];
segments = Take[segments,1];
(* only until the first periodic transform *)
interp[seg_][t_] :={Interpolation[{{{seg[[1,2]]},seg[[1]]},{{seg[[2,2]]},seg[[2]]}},InterpolationOrder->1][t],
seg[[1,2]]<= t < seg[[2,2]]};
func = Function[{t},scalefunc[Piecewise[Map[interp[#][t]&,segments]]]];
];

func
];

latticeDiskParastichyFunction[lattice_,m_,k_] := latticeParastichyFunction[lattice,m,k,"Disk"]





(* ::Input::Initialization:: *)

latticeStemStretch[lattice_,sOfT_] := Module[
{zMin,zMax,tOfZ,sOfZ,wOfZ,res},

{zMin,zMax}= latticeGetCylinderLU[lattice];
tOfZ[z_] := (z - zMin )/(zMax - zMin ); (* in 0,1 *)
sOfZ[z_]:= tOfZ[z]*sOfT[tOfZ[z]]; (* z s(z) in normalised coords *)
wOfZ[z_] := zMin *(1- sOfZ[z]/sOfT[1] )+  zMax* sOfZ[z]/sOfT[1]; (* goes from zmin to zmax *)



res = latticeSetScaling[lattice,"StemStretch"->wOfZ];
res
];





(* ::Input::Initialization:: *)

latticeDiskProjection[lattice_,type_] := Module[{h,diskscaling,zMin,zMax,rAtZMax,r1,res,arenascaling,stemscaling,zNormalise , zToR,zScale},
h = latticeRise[lattice];
r1 = 1 - 2 \[Pi] h; 

Switch[type,
"EqualArea",
zToR = Function[z,Ramp@Sqrt[1- (1-r1^2) z /h]];
{zMin,zMax} = {0,  h / (1-r1^2)},
"Logarithmic",
zToR = Function[z, Exp[-z Log[1/r1] /h]];
{zMin,zMax}  = latticeGetCylinderLU[lattice],
_, Print[" lDP type ",type];Abort[]
];
zNormalise[z_] := (z - zMin )/(zMax - zMin );


diskscaling = Function[{xz},Module[{x,z,r},
{x,z}=xz;
r = zToR[z];
r * { Cos[2 \[Pi] x], Sin[2\[Pi] x]} 
]];

res =  latticeSetCylinderLU[lattice,{0,zMax}];
res =  latticeSetScaling[res,"Disk"->diskscaling];

res = latticeSetScaling[res,"ZNormalise"->zNormalise];


arenascaling = Function[{xz},Module[{x,z,r},{x,z}=xz; 
r =  zToR[z];
{r * x ,z}
]];
res = latticeSetScaling[res,"Arena"->arenascaling];

(* we want the z-coordinate to be r(z) z 
for the logarithmic scaling that is z exp[-z] so we further scale
z so as to only be in the region where zexp[-z) is increasing
Solve[D[ z Exp[-z Log[1/r1] /h],z]\[Equal]0,z]*)
zScale = h/Log[1/r1];
rAtZMax = zToR[zScale];

stemexpscaling = Function[{xz},Module[{x,z,r,scaledZ,fz},{x,z}=xz; 
scaledZ = z * zScale/ zMax; (* 0 to zscale *)
r =  zToR[scaledZ]; (*  0 to rAtZMax *)
fz = r * scaledZ * zMax /(zScale * rAtZMax); (* 0 to zMax *) 
{ x ,  fz}
]];


res = latticeSetScaling[res,"StemExponential"->stemexpscaling];

stemscaling = Function[{xz},Module[{x,z,zinf,f1,zNorm,fz},{x,z}=xz; 
(* through (0,1), (1, n h ) and ( k, infinity ) so two params *)
zinf = 1.1; f1 = 10 ;
zNorm = 1-zNormalise[z];
fz =  ( zinf +  (- f1+ zinf ( f1  -1) )zNorm)/(zinf  - zNorm);
{x , z*  fz }
]];
res = latticeSetScaling[res,"Stem"->stemscaling];
res
];





(* ::Input::Initialization:: *)
latticeRenormalised[lattice_] := Module[{tran,zn,w1,pm,pn},
(* rotate and scale so that the old m-th parastichy vector is now (1,0) *){pm,pn} = latticePrincipalParastichyPair[lattice];tran = latticeRenormalisationTransformation[lattice,pm] ;(* that maps m to 0. we need a linearly independent n *)zn = latticePoint[lattice,pn];w1 = tran [ zn]; 
 (* should already have -1/2<d<1/2; role of this is to change w_-1 to w1 *)  
w1 = dhPrincipalPoint[w1];
latticeCreateDH[w1]
];

dhPrincipalPoint[{d_,h_}] := Module[{principaldh},
	principaldh = {mod[d],h};
If[h>0,principaldh,-principaldh]
];

latticeRenormalisationTransformation[lattice_,mvec_] := Module[{mEnd,mVectorLength,rot,sca,tran},
mEnd = latticePoint[lattice,mvec];mVectorLength = latticeVectorLength[lattice,mvec];rot = RotationTransform[{mEnd,{1,0}}];sca = ScalingTransform[{1/mVectorLength,1/mVectorLength}];tran = Composition[sca,rot];tran
];




(* ::Input::Initialization:: *)

(* relative to (0,1 ) not used *) 
hMN[{m_,n_}][w_]:= Module[{u,v},{u,v}= windingNumberPair[{m,n}];hMNUV[m,n,u,v,w]];
hMNRealPair[{m_,n_}] := Function[{xy},Module[{x,y},{x,y}=xy; ReIm[hMN[{m,n}][x +  I y]]]];
hMNRealPairReflection[{m_,n_}] := Function[{xy},Module[{x,y},
{x,y} = hMNRealPair[{m,n}][xy];
{1-x,y}
]];
hMNInDHalf[{m_,n_}] := If[euclideanDelta[{m,n}]==1,hMNRealPair[{m,n}],hMNRealPairReflection[{m,n}]];

hMNUV[m_,n_,u_,v_,w_]:=(-u w + v)/(-m w + n);
hMNUV[m_,n_,u_,v_,DirectedInfinity[_]]:=u/m;


(* ::Input::Initialization:: *)
(* relative to (1,0)  *) 

gMN[{m_,n_}][w_]:= Module[{u,v},{u,v}= windingNumberPair[{m,n}];gMNUV[m,n,u,v,w]];
gMNRealPair[{m_,n_}] := Function[{xy},Module[{x,y},{x,y}=xy; ReIm[gMN[{m,n}][x +  I y]]]];
gMNRealPairReflection[{m_,n_}] := Function[{xy},Module[{x,y},
{x,y} = gMNRealPair[{m,n}][xy];
{1-x,y}
]];
gMNInDHalf[{m_,n_}] :=Function[{xy},
Module[{x,y},
{x,y} = N@gMNRealPair[{m,n}][xy];
x = x-Round[x];
If[x<0,x=-x];
{x,y}
]];
(*gMNInDHalf[{m_,n_}]  := 
 If[euclideanDelta[{m,n}]\[Equal]1,gMNRealPair[{m,n}],gMNRealPairReflection[{m,n}]];
*)
gMNUV[m_,n_,u_,v_,w_]:=(v w + u)/(n w + m);
gMNUV[m_,n_,u_,v_,DirectedInfinity[_]]:=v/n;


(* ::Input::Initialization:: *)
viiMoebiusTransform[{{m_,n_},{u_,v_}}][{d_,h_}] := 
{(d^2 m u+h^2 m u+n v-d (n u+m v))/(d^2 m^2+h^2 m^2-2 d m n+n^2),h/(d^2 m^2+h^2 m^2-2 d m n+n^2)}




(* ::Input::Initialization:: *)

Module[{mvnu1,z1d,z1h},
Block[{d,h,m,v,n,u},
mvnu1 = Solve[ m v - n u ==1, v][[1]];
{z1d,z1h} = 
 Simplify/@( ComplexExpand@ ReIm [gMNUV[{m,n},{u,v}][d+ I h]] );{z1d,z1h} - viiMoebiusTransform[{{m,n},{u,v}}][{d,h}] /. mvnu1]
]


(* ::Input::Initialization:: *)
latticeMoebiusTransform[mn_][dh_] := gMNInDHalf[mn][dh];


latticeMoebiusTransform[{1,0}][{0,0}] := {1/2,\[Infinity]};
latticeMoebiusTransform[{1,0}][{0.,0.}] := {1/2,\[Infinity]};
latticeMoebiusTransform[{0,1}][{d_,h_}]  := {d,h};



(* ::Input::Initialization:: *)


latticeHexagonal [{m_,n_},cylinderLU_:{-0.2,3.2}] := 
latticeCreateDH[latticeDHHexagonal[{m,n}],cylinderLU,3];




(* ::Input::Initialization:: *)
latticeDHNonOpposedTC[{m_,n_}]  := Module[{xy,r,angles,circle},
circle =  viiPrimaryNonOpposed[{m,n}];
If[circle==Nothing,Return[Nothing]];
{xy,r,angles} = List @@ circle;
angles = Mean[angles];
xy + r * {Cos[angles],Sin[angles]}
]


latticeTriplePoint[{m_,n_}] := latticeDHHexagonal[{m,n}];latticeDHHexagonal[{m_,n_}]  := latticeMoebiusTransform[{m,n}][ { 1/2,Sqrt[3]/2}];


latticeTouchingCircle[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[
latticeMoebiusTransform[{m,n}][ {Cos[5\[Pi]/12],Sin[5\[Pi]/12]}],cylinderLU,2];
latticeEquiLength[{m_,n_},cylinderLU_:{-0.2,3.2}] := (* ie p numbers are (m+n),m=n *)latticeCreateDH[latticeMoebiusTransform[{m,n}][ {Cos[\[Pi]/6],Sin[\[Pi]/6]}],cylinderLU];
latticeOrthogonal[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[latticeMoebiusTransform[{m,n}][ { 0,1}],cylinderLU,2];
latticeWithMN[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[
latticeMoebiusTransform[{m,n}][{0.1,(Sqrt[3]/(2)-.25)}],cylinderLU];




(* ::Input::Initialization:: *)
latticeCircles[lattice_] := Module[{latticeMargin,lplus,lminus,r,cylinderLU,latticep},cylinderLU = latticeGetCylinder[lattice][[2]];cylinderLU = cylinderLU + {-latticeRise[lattice],latticeRise[lattice]};latticeMargin = latticeSetCylinderLU[lattice,cylinderLU];latticep =  latticePoints[latticeMargin] ;lplus = latticep+ Table[{1,0},Length[latticep]];lminus =  latticep + Table[{-1,0},Length[latticep]];r =latticeDiskRadius[latticeMargin];Map[Circle[#,r]&,Join[ latticep,lplus,lminus]]
];

latticeDiskRadius[lattice_] := Module[{pv1},
	pv1 = latticeParastichyVectors[lattice][First[latticePrincipalParastichyPair[lattice]]];
	Norm[pv1 ]/2
];


(* ::Input::Initialization:: *)
viiPrimaryIsEverNonOpposed[mn_] := Module[{m,n},
{m,n} = Sort[mn];
m < n - m 
];
viiPrimaryOpposed[mn_]  := getCircleBranch[mn,"Opposed"];
viiPrimaryNonOpposed[mn_]  := getCircleBranch[mn,"NonOpposed"];

getCircleBranch[{m_,n_},type_] := Module[{mn,angle,upperpt,lowerpt,res,centre,r,theta12,branch},
mn = Sort[{m,n}];
branch = viiPrimarySegment[mn];
If[!viiPrimaryIsEverNonOpposed[mn],
	If[type=="Opposed", Return[branch],Return[Nothing[]]]];
angle = circleAngleAtLine[branch,viiOrthostichyD[mn]];
upperpt = viiTriplePoint[viiUpperPair[mn]];
lowerpt = viiTriplePoint[mn];

{centre,r,theta12} = Apply[List,branch];
If[type=="NonOpposed",
res = Circle[centre,r,Sort@{xyToArg[branch,upperpt],angle}]
,
res = Circle[centre,r,Sort@{xyToArg[branch,lowerpt],angle}]
];
Return[res];
];
viiOrthostichyD[{m_,n_}] := Module[{u,v,res},
{u,v} = euclideanUV[{m,n}];
res = v/n;
 If[res>1/2,res = 1-res];
res
]

xyToArg[Circle[centre_,r_,theta_],xy_ ]:= ArcTan @@ ( xy - centre)


circleAngleAtLine[circle_,d_] := xyToArg[circle, linecircleIntersectionDH[d,circle]]
linecircleIntersectionDH[d_,circle_] := {d,linecircleIntersection[d,circle]}
linecircleIntersection[lineD_,Circle[centre_,r_,theta_]] := Sqrt[r^2 - (lineD-centre[[1]])^2];




(* ::Input::Initialization:: *)
viiMNSemiCircle[mn_] := Module[{r,m,n,u,v,dbar},
{m,n}= Sort[mn];
If[m==1 && n==1,Return[InfiniteLine[{{1/2,0},{1/2,1}}]]];
r = 1/(n^2-m^2);
{u,v} = euclideanUV[{m,n}]; (* not winding number pair *) 
dbar = ( n v - m u )/(n^2-m^2);
Circle[ { dbar, 0},r,{0,\[Pi]}]
];

viiUpperPair[{m_,n_}] := {Abs[n-m],Min[m,n]}

viiPrimaryBoundingBox[mn_] :=  Module[{upperTP,lowerTP,m,n},
{m,n}= mn;
upperTP = viiTriplePoint[viiUpperPair[{m,n}]];
lowerTP = viiTriplePoint[{m,n}];
{lowerTP,upperTP}
];

viiPrimarySegment[mn_] :=  Module[{upperTP,lowerTP,m,n},
{lowerTP,upperTP} = viiPrimaryBoundingBox[mn];
subSegment[viiMNSemiCircle[mn],upperTP,lowerTP]
];
viiPrimarySegment[{1,1}] = Line[{{1/2,(\[Sqrt]3)/2},{1/2,1/(2 \[Sqrt]3)}}];
viiPrimarySegment[{0,1}] = Circle[{0,0},1,{\[Pi]/3,\[Pi]/2}];


viiNonPrimarySegments[mn_] :=  Module[{upperTP,lowerTP,m,n,circle},
{lowerTP,upperTP} = viiPrimaryBoundingBox[mn];
remainderSegments[viiMNSemiCircle[mn],upperTP,lowerTP]
];

viiNonPrimarySegments[{0,1}] = Circle[{1,0},1,{2\[Pi]/3,\[Pi]}];
viiNonPrimarySegments[{1,1}] = {Line[{{1/2,0},{1/2,1/(2 \[Sqrt]3)}}],Line[{{1/2,(\[Sqrt]3)/2},{1/2,\[Infinity]}}]}; (* 1.2 = \[Infinity] *) 
viiNonPrimarySegments[{1,2}] ={
 Circle[{1/3,0},1/3,{\[Pi]/3,\[Pi]}], Circle[{2/3,0},1/3,{5\[Pi]/6,\[Pi]}]};

(* split  half circle  at points p1 and p2 *)
subSegment[Circle[xy_,r_,angles___],p1_,p2_] := Module[{angle1,angle2},
{angle1,angle2} = Sort@N[ {ArcTan @@ (p1-xy),ArcTan @@ (p2-xy)}];
Circle[xy,r,{angle1,angle2}]
];
remainderSegments[Circle[xy_,r_,angles___],p1_,p2_] := Module[{angle1,angle2},
{angle1,angle2} = Sort@N[ {ArcTan @@ (p1-xy),ArcTan @@ (p2-xy)}];
{Circle[xy,r,{0,angle1}],Circle[xy,r,{angle2,\[Pi]}]}
];
subSegment[InfiniteLine[_],p1_,p2_] := Line[{p1,p2}];
(* by angles *)




viiMNOrthoCircle[mn_] := Module[{m,n,u,v,um,vn},
{m,n}= mn;
{u,v} = euclideanUV[mn];
{um,vn} = {u/m,v/n};
Circle[ { (um+vn)/2, 0},Abs[vn-um]/2,{0,\[Pi]}]
];

dr[r_] := DiscretizeRegion[r];
Clear[viiRegion]
viiRegion[{0,1},"Ordered","Plus",hmax_:20]  := RegionDifference[
Rectangle[{0,0},{1/2,hmax}],Disk[{0,0},1,{0,\[Pi]}]];
viiRegion[{0,1},"Ordered","Minus",hmax_:20] :=RegionDifference[
Rectangle[{-1/2,0},{0,hmax}],Disk[{0,0},1,{0,\[Pi]}]];
viiRegion[{0,1},"Ordered"] :=RegionUnion[viiRegion[{0,1},"Ordered","Plus"],viiRegion[{0,1},"Ordered","Minus"]];

viiRegion[{1,0},"Ordered","Plus"]  := RegionDifference[
RegionIntersection[Rectangle[{0,0},{1,1}],Disk[{0,0},1,{0,\[Pi]}]],
Disk[{1,0},1,{0,\[Pi]}]
];
viiRegion[{1,0},"Ordered","Minus"] := RegionDifference[
RegionIntersection[Rectangle[{-1,0},{0,1}],Disk[{0,0},1,{0,\[Pi]}]],
Disk[{-1,0},1,{0,\[Pi]}]
];

viiRegion[{1,0},"Ordered"] :=RegionUnion[viiRegion[{1,0},"Ordered","Plus"],viiRegion[{1,0},"Ordered","Minus"]];

viiRegion[{0,1},"All"] := RegionUnion[viiRegion[{0,1},"Ordered"],viiRegion[Reverse@{0,1},"Ordered"]];
viiRegion[{1,0},"All"] = viiRegion[{0,1},"All"];viiRegion[{1,1},"All"] := viiRegion[{1,1},"Ordered"];
viiRegion[{1,0}] := viiRegion[{1,0},"Ordered"]

viiRegion[mn_,"All"] := RegionUnion[viiRegion[mn,"Ordered"],viiRegion[Reverse@mn,"Ordered"]];

(* 1,1 *) 
If["Fix bug with region order",
(
viiRegion[{1,1},"Ordered","Minus"]  :=   
RegionIntersection[ Rectangle[{0,0},{1/2,1}]
,RegionDifference[Disk[{1,0},1,{0,\[Pi]}],
viiMNOrthoCircle[{1,1}] /. Circle-> Disk
]
];

viiRegion[{1,1},"Ordered","Plus"]  :=   
RegionIntersection[ Rectangle[{0,0},{1/2,1}]
,RegionDifference[
viiMNOrthoCircle[{1,1}] /. Circle-> Disk
,Disk[{1/3,0},1/3,{0,\[Pi]}]
]
];
viiRegion[{1,1},"Ordered"] :=RegionUnion[viiRegion[{1,1},"Ordered","Plus"],viiRegion[{1,1},"Ordered","Minus"]];


viiRegion[{2,1},"Ordered"] := Module[{m,n,outer,inner1,inner2},
outer = Rectangle[{0,0},{1/2,1}];
inner1 = Disk[{2/3,0},1/3,{0,\[Pi]}];
inner2 = viiMNSemiCircle[{1,3}]/. Circle->Disk;
RegionDifference[ RegionIntersection[outer,inner1],inner2]
];
viiRegion[{1,2},"Ordered"] := Module[{m,n,outer,inner1,inner2},
outer = Disk[{1/3,0},1/3,{0,\[Pi]}];
inner1 =Disk[{2/3,0},1/3,{0,\[Pi]}];
inner2 = viiMNSemiCircle[{2,3}]/. Circle->Disk;
RegionDifference[outer,RegionUnion[inner1,inner2]]
];

(* this is the bit that will probably work if i concentrate. but it doesn't *)
viiRegion[mn_,"All"] := Module[{m,n,outer,inner,outer1,outer2,inner1,inner2},
{m,n}= Sort[mn];
outer1 = viiMNSemiCircle[{Abs[n-m],m}]/. Circle->Disk;outer2 = viiMNSemiCircle[{Abs[n-m],n}]/. Circle->Disk;
If[euclideanDelta[{m,n}]==1,
outer = RegionDifference[outer2,outer1],
outer = RegionIntersection[outer1,outer2]
];
inner1 = viiMNSemiCircle[{m,n+m}]/. Circle->Disk;
inner2 = viiMNSemiCircle[{n,n+m}]/. Circle->Disk;
inner = RegionUnion[inner1,inner2];
RegionDifference[outer,inner]
];

viiRegion[mn_,"Ordered"] := Module[{m,n,outer,inner},
{m,n}=mn;
outer = viiRegion[mn,"All"];
inner = viiMNSemiCircle[{m,n}]/. Circle->Disk;
If[m<n,
RegionDifference[outer,inner]
,
RegionIntersection[outer,inner]
]
];

viiRegion[mn_,"Ordered",sign_] := Module[{m,n,outer,inner},
outer =  viiRegion[mn,"Ordered"];inner = viiMNOrthoCircle[mn]/. Circle->Disk;
If[sign=="Minus",
RegionDifference[outer,inner]
,
RegionIntersection[outer,inner]
]
]
)(* end of code unused cos of bug *)];

base["Ordered", sign_] :=  base["Ordered", sign] = regionToPolygon[DiscretizeRegion[viiRegion[{1,0},"Ordered",sign]]];
base["Ordered"] :=  base["Ordered"] = regionToPolygon[DiscretizeRegion[viiRegion[{1,0},"Ordered"]]];
base["All"] :=  base["All"] = regionToPolygon[
DiscretizeRegion[viiRegion[{1,0},"All"]]];

transformPolygon[poly_,function_] := Polygon[ function  /@ (First@Apply[List,poly])];

(* special case *) 
viiPolygon[{0,1},args__] :=  regionToPolygon[DiscretizeRegion[viiRegion[{0,1},args]]];
(* base case *)
viiPolygon[{1,0},args__] :=  base[args]
(* transform case *)
viiPolygon[mn_,args__] :=  transformPolygon[base[args],gMNInDHalf[mn]]
viiPolygon[mn_] := viiPolygon[mn,"All"]

regionToPolygon[r_] := Module[{rb,g,cblines,x,y,xy,c},
rb=RegionBoundary[r];
cblines = MeshCells[rb,1] /. Line[{x_,y_}] -> UndirectedEdge[x,y];
g = Graph[MeshCells[rb,0]/. Point[xy_]->xy,cblines,
VertexCoordinates->MeshPrimitives[rb,0]/. Point[xy_]->xy];
c = First@ConnectedGraphComponents[g];
Polygon[AnnotationValue[{c,FindHamiltonianPath[c]},VertexCoordinates]]
];



viiTriplePoint[mn_] := gMNInDHalf[mn][{1/2,Sqrt[3]/2}];
viiTriplePoint[{0,1}] := {-1/2,Sqrt[3]/2}; (* algo gives (3/2,Sqrt[3]/2) *)

viiLabelPoint[mn_] := gMNInDHalf[mn][{0,Sqrt[3]/(2.5)}];
viiTouchingCircleLabel[mn_] :=  gMNInDHalf[mn][{0,1}];
viiTouchingCircleLabelNonPrimary[mn_] :=  gMNInDHalf[mn][{-Sqrt[3]/2,1/2}];


(* ::Input::Initialization:: *)
viiTouchingCircleLabelNonPrimary[{1,2}] = gMNInDHalf[{1,2}][{Sqrt[3]/2,1/2}];



(* ::Input::Initialization:: *)
(* https://mathematica.stackexchange.com/questions/11430/why-doesnt-normal-work-on-geometrictransformation *)
(* at one point this was needed - may not be at present *) 

NormalizeGraphics[g_]:=Internal`InheritedBlock[{System`Private`InternalNormal},Unprotect[System`Private`InternalNormal];
System`Private`InternalNormal[gr:_Rotate|_Translate|_Scale|_GeometricTransformation,_]:=Module[{tmp=Quiet[transform2D[gr],TransformedRegion::reg]},tmp/;Head[tmp]=!=TransformedRegion];
Normal[g,{Rotate,Scale,Translate,GeometricTransformation}]]

transform2D[Rotate[g_,r_,p___]]:=TransformedRegion[g,RotationTransform[r,absolutePosition[g,p]]]

transform2D[Translate[g_,t_]]:=TransformedRegion[g,TranslationTransform[t]]

transform2D[Scale[g_,s_,p___]]:=TransformedRegion[g,ScalingTransform[s,absolutePosition[g,p]]]

transform2D[GeometricTransformation[g_,tf_]]:=TransformedRegion[g,tf/.Except[_TransformationRegion]:>AffineTransform[tf]]

absolutePosition[g_]:=absolutePosition[g,{Center,Center}]
absolutePosition[g_,{h:(Left|Center|Right),v:(Top|Center|Bottom)}]:=Module[{hrange,vrange},{hrange,vrange}=RegionBounds[g][[;;2]];
{Replace[h,{Left->Min,Center->Mean,Right->Max}][hrange],Replace[v,{Bottom->Min,Center->Mean,Top->Max}][vrange]}]
absolutePosition[g_,spec_]:=spec


(* ::Input::Initialization:: *)
latticeAddStem[lattice_,shape_] := Module[{res},
res = Append[lattice,spline3D-> shape];
shapeLU = MinMax@{shape[0,0][[3]],shape[0,1][[3]]};
res = latticeSetCylinderLU[res,shapeLU];
res
];
lattice3DradiusFunction[lattice_,v_] := Module[{xy},
xy=Take[lattice[spline3D][0,v],2];Sqrt[xy . xy]
];
(*
lattice3DZFunction[lattice_,v_] := lattice[spline3D][0,v][[3]];
*)
lattice3DDHToUV[lattice_][{d_,h_}] := Module[{shapeLU},
(* d maps to u as this is periodic in spline,  v goes from 0 to 1 as h goes over shapeLU of spline z values *) 
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
vofh[hp_] := (hp-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]); (* v from 0 to 1 over shape *)
{d,vofh[h]}
];
lattice3DPosition[lattice_,{d_,h_}] := lattice[spline3D] @@lattice3DDHToUV[lattice][{d,h}];

lattice3DPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
cylinderLU= latticeGetCylinder[lattice][[2]];
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[lattice3DPosition[lattice,#]&,latticePoints[subLattice]]
]
lattice3DParastichyOfV[lattice_,m_,n_][v_] := Module[{dL,pslope,h,vscale},
dL = latticeParastichyCylinderIntersection[lattice,m,Bottom]+
n*latticeParastichyHorizontalSeparation[lattice,m];
pslope = latticeParastichySlope[lattice,m];
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
vscale = shapeLU[[2]]-shapeLU[[1]]; (* h ranges over this as v goes from 0 to 1 *) 
h =  v * vscale ; 
lattice3DPosition[lattice,{ dL +h /pslope,h}] 
];
lattice3DParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[lattice3DParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
lattice3DPointsUpToV[lattice_,v_] := Module[{pts},
pts = lattice3DPoints[lattice];
Select[pts, Last[#] <   lattice[spline3D][0,v][[3]]&]
];



(* ::Input::Initialization:: *)
stemSmoothRadiusFunctionV[radiusF_,nPoints_:12] := Module[{stemPoints,radiusFunction},
(* helper smooth function for v in [0,1] *)
stemPoints = Table[radiusF[v/nPoints],{v,0,nPoints}];
radiusFunction=BSplineFunction[stemPoints];
radiusFunction
];


(* ::Input::Initialization:: *)
stemMakeSurfaceFunctionUV[lattice_,circumferenceFunction_,nPoints_:12] := Module[{cylinderLU,r},
cylinderLU =latticeGetCylinderLU[lattice];
r[v_] := circumferenceFunction[v]/(2\[Pi]); (* a radius function of 1 will correspond to a cylinder with circumference  2 pi  .. *) 
Function[{u,v}, {r[v] * Cos[ 2 \[Pi] u], r[v] * Sin[ 2 \[Pi] u], stemHeightFunction[lattice,v]} ]
];

stemArcLengthOfV[stem_][v_] := Module[{},
N@ArcLength[stemRadiusFunctionV[stem][s],{s,0,v}]
];
stemVInverseArcLengthFunctionS[stem_] := Module[{sofVTable},
(* maps (0,arclength[v=1] ) to (0,1)  *) 
sofVTable = Table[{stemArcLengthOfV[stem][v],v},{v,0,1,0.01}];
Interpolation[sofVTable] (* store this result in the stem<||> so we don't recalculate *) 
];
stemAreaDifferentialOfV[stem_][v_] :=Module[{x},2 \[Pi] stemRadiusFunctionV[stem][v] *
Sqrt[ 1 + ( D[stemRadiusFunctionV[stem][x],x])^2 /. x->v]];
stemSurfaceAreaBelowV[stem_][v_] := 
NIntegrate[stemAreaDifferentialOfV[stem][w],{w,0,v}];

stemVConstantAreaFunctionT[stem_] :=  Module[{tofVTable},
(* maps (0,shape surface area ) to (0,1)  *) 
tofVTable = Table[{stemSurfaceAreaBelowV[stem][v],v},{v,0,1,0.01}];
Interpolation[tofVTable] 
];

stemAddShape[lattice_,circumferenceFunction_] := Module[{stem,surfaceFunctionUV,shapeLU,vFunctionArcLength},
surfaceFunctionUV = stemMakeSurfaceFunctionUV[lattice,circumferenceFunction];
stem = Append[lattice,{
"surfaceXYZofUV"-> surfaceFunctionUV,"circumferenceFunctionV"->circumferenceFunction
}];
shapeLU = MinMax@{surfaceFunctionUV[0,0][[3]],surfaceFunctionUV[0,1][[3]]};
stem = latticeSetCylinderLU[stem,shapeLU];
vFunctionArcLength = stemVInverseArcLengthFunctionS[stem];
stem = Append[stem,{
"vArcLengthInverseS"-> vFunctionArcLength
}];
vFunctionArea = stemVConstantAreaT[stem];
stem = Append[stem,{"arcLengthSRange"-> N@{0,stemArcLengthOfV[stem][1]}}];
stem
];
stemRadiusFunctionV[stem_] := Function[v,stem["circumferenceFunctionV"][v]/(2\[Pi])]
stemShapeFunctionUV[stem_] := stem["surfaceXYZofUV"]; 
stemShapeFunctionUS[stem_] := Function[{u,s},
stemShapeFunctionUV[stem][u,stem["vArcLengthInverseS"][s]]
];

stemShapeLU[lattice_] := MinMax@{stemShapeFunctionUV[lattice][0,0][[3]],stemShapeFunctionUV[lattice][0,1][[3]]};
stemHeightFunction[lattice_,v_] := Module[{cylinderLU=latticeGetCylinderLU[lattice]},
cylinderLU[[1]] + v (cylinderLU[[2]] -cylinderLU[[1]])
];





(* ::Input::Initialization:: *)
stemPointsUpToV[lattice_,v_] := Module[{pts},
pts = stemPoints[lattice];
Select[pts, Last[#] <   stemShapeFunctionUV[lattice][0,v][[3]]&]
];
stemArcPointsUpToV[lattice_,v_] := Module[{pts},
pts = stemArcPoints[lattice];
Select[pts, Last[#] <   stemShapeFunctionUV[lattice][0,v][[3]]&]
];

stemPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
cylinderLU= latticeGetCylinderLU[lattice];
shapeLU = MinMax@{ stemShapeFunctionUV[lattice][0,0][[3]], stemShapeFunctionUV[lattice][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[stemPositionDH[lattice,#]&,latticePoints[subLattice]]
];

stemArcPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
(* display points with 0<v< 1 
but map h to arclength s, not v, so need a slightly taller lattice *)
cylinderLU= latticeGetCylinderLU[lattice];
shapeLU = MinMax@{ stemShapeFunctionUV[lattice][0,0][[3]], stemShapeFunctionUV[lattice][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[stemArcPositionDH[lattice,#]&,latticePoints[subLattice]]
];


stemPositionDH[lattice_,{d_,h_}] := stemShapeFunctionUV[lattice] @@stemDHToUV[lattice][{d,h}];
stemArcPositionDH[lattice_,{d_,h_}] := stemShapeFunctionUS[lattice] @@stemDHToUS[lattice][{d,h}];


stemDHToUV[lattice_][{d_,h_}] := Module[{shapeLU},
(* d maps to u as this is periodic in spline,  v goes from 0 to 1 as h goes over shapeLU of spline z values *) 
shapeLU = stemShapeLU[lattice];
vofh[hp_] := (hp-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]); (* v from 0 to 1 over shape height, not over arc length ! *)
{d,vofh[h]}
];

stemDHToUS[lattice_][{d_,h_}] := Module[{shapeLU,s,v},
(* d maps to u as this is periodic in spline, 
v from 0 to 1 ,  s from 0 to arclength  which is the top of the lattice cylinder *) 
shapeLU = stemShapeLU[lattice];
s =  (h-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]);
(* v from 0 to 1 over shape height, not over arc length ! *)
{d,s}
];


stemParastichyOfS[stem_,m_,n_][v_] := Module[{},
stemParastichyOfV[stem,m,n][stemVInverseArcLengthFunctionS[stem][v] ]
];


(* ::Input::Initialization:: *)
stemParastichyOfV[stem_,m_,n_][v_] := Module[{dL,pslope,h,vscale,shapeLU},
dL = latticeParastichyCylinderIntersection[stem,m,Bottom]+
n*latticeParastichyHorizontalSeparation[stem,m];
pslope = latticeParastichySlope[stem,m];
shapeLU =stemShapeLU[stem];
vscale = shapeLU[[2]]-shapeLU[[1]]; (* h ranges over this as v goes from 0 to 1 *) 
h =  v * vscale ; 
stemPositionDH[stem,{ dL +h /pslope,h}] 
];

stemArcLengthParastichyOfV[stem_,m_,n_][v_] := Module[{dL,pslope,h,vscale,shapeLU},
dL = latticeParastichyCylinderIntersection[stem,m,Bottom]+
n*latticeParastichyHorizontalSeparation[stem,m];
pslope = latticeParastichySlope[stem,m];
shapeLU =stemShapeLU[stem];
vscale = shapeLU[[2]]-shapeLU[[1]]; 
h =  v * vscale *stem["arcLengthSRange"][[2]]; 
stemArcPositionDH[stem,{ dL +h /pslope,h}] 
];

stemParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[stemParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
stemArcLengthParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[stemArcLengthParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
