(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
euclideanQCoefficients[{0,1}] := {}; (* actually this is implied by algo anyway, but being explicit *)

euclideanQCoefficients[{m_,n_}] := Module[{r,q,i},
i=0;
r[-1]=n; (* in this order so that if m<n then get no initial zero *)
r[0] = m;
While[r[i] > 0  ,
q[i] = Floor[r[i-1]/r[i]];
r[i+1] = r[i-1] - q[i] r[i];
i++;
];
 Table[q[j],{j,0,i-1}]
];

euclideanUVcoefficients[{}] := {{1,0}}; (* ie for m,n=0,1 ; m v - n u = -1 *)
euclideanUVcoefficients[q_] := Module[{i,u,v,qfunc},
i=0;
u[-1]=1; v[-1]=0; 
u[0] = 0; v[0]=1;
qfunc[i_] := q[[i+1]]; (* qfunc indexes from 0, just to match recurrence used in text  *)
For[i=1,i<= Length[q], i++,
u[i] = u[i-2] + qfunc[i-1] u[i-1];
v[i] = v[i-2] + qfunc[i-1] v[i-1];
];(*u[1] = 1; v[1] = q[0];*)
Table[{u[i],v[i]},{i,0,Length[q]}]
];

makeEuclideanProductMatrix[q_] := Module[{A,P,qfunc,i},
qfunc[i_] := q[[i+1]]; (* qfunc indexes from 0 *)
A[i_] := {{ 0,1},{1,-qfunc[i]}};
P = IdentityMatrix[2];
For[i=0,i<Length[q],i++,
P = A[i] . P;
];
P
];

euclideanProductMatrix[mn_] :=   makeEuclideanProductMatrix[euclideanQCoefficients[mn]];

euclideanHCF[mn_] := Module[{res},
res =  euclideanProductMatrix[mn]  .  Reverse[mn ]; (* because of the r-order above *) 
If[res[[2]] !=0 , Abort[]];
First[res]
];

euclideanDelta[mn_] := Module[{q,res},
q = euclideanQCoefficients[mn];
If[OddQ[Length[q]],1,-1]
];


(* ::Input::Initialization:: *)
euclideanUVDirect[mn_] :=Module[{q,uvList},
q = euclideanQCoefficients[mn];
uvList = euclideanUVcoefficients[q]; (* length 1 + length[q], unless q={} when {0,1}} *)
uv= uvList[[ Max[1,Length[q]] ]] ;
uv
];

(*  m v - n u = hcf(m,n); 0\[LessEqual]u<m, 0\[LessEqual]v<n apart from the m=0 case *) 
windingNumberPair[{0,0}] := {\[Infinity],\[Infinity]};
windingNumberPair[{0,n_}] := {-1,0};
windingNumberPair[{m_,0}] := {0,1};
windingNumberPair[{m_,n_}] := Module[{u,v,Delta},
{u,v} = euclideanUVDirect[{m,n}];
Delta = m v - n u;
If[Delta>0,Return[{u,v}]];
{u,v} = {m - u, n - v};
Return[{u,v}]
];

euclideanUV[mn_] := euclideanUVDirect[mn]; 
euclideanUV[mn_,ForDelta_] := Module[{mnDelta,uv},
(* Euclid yields a pair with mv - nu= \[PlusMinus] 1 but we don't know the sign *)
If[euclideanDelta[mn]==ForDelta,
uv= euclideanUVDirect[mn],
uv = Reverse[ euclideanUVDirect[Reverse[mn]]]
];
uv
];


(* ::Input::Initialization:: *)
(*euclideanProof[mn_] := Module[{uv,str},
uv = euclideanUV[mn];str = StringTemplate["``*``-``*``=``"][mn[[1]],uv[[2]],mn[[2]],uv[[1]],mn[[1]]*uv[[2]]-mn[[2]]*uv[[1]]];{str,euclideanDelta[mn]}
];

*)


(* ::Input::Initialization:: *)
euclideanReduction[pq_]  := Module[{uv,it,firstShorter,dotPositive,reduceSecond,isPrincipal,positiveRise,positiveVec},
firstShorter[{u_,v_}] := Module[{u2=Simplify[u . u],v2=Simplify[v . v]},If [ u2 < v2, {u,v},{v,u}]];
dotPositive[{u_,v_}] := If [ u . v > 0, {u,v},{u,-v}];
reduceSecond[{u_,v_}] := If[ Abs[u . (v-u)]  >  Abs[u . v ],{u,v},{u,u-v}];	
isPrincipal[{u_,v_}] := Module[{u2=Simplify[u . u],v2=Simplify[v . v]},
u2  <=  v2 && 0  <= u . v && u . v <= u2 /2
] ;
positiveRise[uvp_] := Map[positiveVec,uvp];
positiveVec[{ud_,uh_}] := If[uh>0,{ud,uh},
If[uh<0,{-ud,-uh}, (* h=0 *) {Abs[ud],0}]];
uv = pq;
it=1;While[!isPrincipal[uv], 
{
it++;  If[it>20,Break[]];
uv = firstShorter[uv];
uv = dotPositive[uv];
uv = reduceSecond[uv];
uv = Simplify /@uv ;
}];

uv = firstShorter[uv]; (* not needed but just to be clear *) 
uv = positiveRise[uv]; (* only do this at the end ! *)
uv
];


(* ::Input::Initialization:: *)
euclideanShortestPair[{pm_,pn_}] := 
(* in the lattice generated by pm and pn, what is the shortest pair ? *)
euclideanReduction[{pm,pn}];

tgetPrincipalVectorsDH[{d_,h_}] := Module[{uv},
uv= {{d,h}, {1-d,-h}}; (* (1,0) and (d,h) are a generating pair *)
euclideanShortestPair[uv]
];

vectorNorm2[x_] := Simplify[x . x]; 

tgetThreeParastichyVectorsDH[{d_,h_}] := 
Module[{pv,psum,pdiff,pthird,pvectors},
pv=tgetPrincipalVectorsDH[{d,h}];
psum = pv[[1]]+pv[[2]];
pdiff = pv[[1]]-pv[[2]]; If[pdiff[[2]] <0, pdiff = -pdiff];
pthird = If[vectorNorm2[psum]<= vectorNorm2[pdiff],psum,pdiff];
pvectors = Append[pv,pthird]; (* sometimes the fourth can be the same length as the third but we don't need to mark this *)
numberate[pvectors, h]
];
rawpnumber[v_,h_] :=  Module[{m,d},
If[v=={1,0},Return[0]];

m =Abs[Round[v[[2]]/h ]];
d = v[[1]];
(* if d=-1/2, then there is another parastichy vector with d=1/2; if d not in [-1/2,1/2] also a complementary vector *)
If[d== -1/2 || Round[d] != 0, m = hat[m]];
m
];
numberate[pvectors_, h_] := Module[{pnumbers,onepos,hatpos},pnumbers = Map[rawpnumber[#,h]&,pvectors];
onepos = Position[pnumbers,1,1];If[Length[onepos]>= 2, hatpos = onepos[[2]]; pnumbers[[hatpos]] = hat[1]];Association[Map[#[[1]]->#[[2]] &,Transpose[{pnumbers,pvectors}]]]
];



(* ::Input::Initialization:: *)
latticeCreateDH[{d_,0}] := Nothing; (* silently drop from lists *) 

latticeCreateDH[{d_,h_},cylinderLU_:{-0.2,3.2}]  :=  Module[{lattice},
lattice = Association [
"d"-> d
,"h"-> h
,"cylinder" -> { {-1/2,1/2},cylinderLU} 
(* always has periodicity (1,0); this is how much of it we display *) 
,"parastichyVectors" ->  tgetThreeParastichyVectorsDH[{d,h}]
];
lattice = Prepend[lattice,{ "parastichyNumbers"-> latticeParastichyNumbersGroupedByLength[lattice]}];
lattice
];




(* ::Input::Initialization:: *)
latticeParastichyNumbersGroupedByLength[lattice_] := Module[{pv,pvlengths,pva}, 
pv = latticeParastichyVectors[lattice];
pvlengths =Map[vectorNorm2,pv];
pva = GroupBy[pvlengths,Identity,Sort[Keys[#]]&];
Association[Map[ pva[#]-> # &, Keys[pva]]]
];

latticeParastichyNumbers[lattice_] :=
Module[{pnumbers}, 
pnumbers =latticeParastichyNumbersGroupedByLength[lattice];
Flatten[Map[Sort,Keys[pnumbers]]]
];




(* ::Input::Initialization:: *)
latticeGetCylinder[lattice_] := lattice["cylinder"];
latticeGetCylinderLU[lattice_] := lattice["cylinder"][[2]];
latticeSetCylinderLU[lattice_,cylinderLU_] := Module[{res,cyl},
res =lattice;
cyl= lattice["cylinder"];
cyl[[2]] = cylinderLU;
res["cylinder"] = cyl;
res
];
(*latticeCylinderHeight[lattice_] := Module[{cylinderLU},
cylinderLU= latticeGetCylinderLU[lattice];
cylinderLU[[2]]-cylinderLU[[1]]
];
*)


latticeLabel[lattice_] := 
latticeParastichyNumbersGroupedByLength[lattice];
latticeLabelText[lattice_] := Module[{},
ll =  Keys@latticeLabel[lattice] ;
tos[x_] := If[x===hat[1],"\!\(\*OverscriptBox[\(1\), \(^\)]\)",ToString[x]];
ll = Map[tos,ll,{2}];
ll = Map[StringRiffle[#,"="]&,ll];
ll = StringRiffle[Take[ll,UpTo[2]],","]
];


latticeLabelPosition[lattice_] := Module[{cyl},
cyl=latticeGetCylinder[lattice];
{cyl[[1,1]],cyl[[2,2]]} (* top left *)
];

latticeParastichyVectors[lattice_] := lattice["parastichyVectors"];

latticePrincipalParastichyPair[lattice_] := Take[latticeParastichyNumbers[lattice],2];
latticePrincipal3ParastichyNumbers[lattice_] :=Take[latticeParastichyNumbers[lattice],3]


(* ::Input::Initialization:: *)
latticePoints[lattice_] :=  Module[{nmin,nmax,irange,points,h,cylinderLU},h = lattice["h"];cylinderLU=lattice["cylinder"][[2]];{nmin,nmax}= {Ceiling[Min[cylinderLU]/h],Floor[Max[cylinderLU]/h]};irange = {nmin,nmax};points = N@Flatten[Table[latticePointWithCopies[lattice,i],{i,nmin,nmax}],1];
points
];

latticeGraphicPoints[lattice_] :=  Point[latticePoints[lattice]];
latticeGraphicsPoint[lattice_,m_] :=  Point[latticePoint[lattice,m]];



(* ::Input::Initialization:: *)
mod[x_] :=  x - Round[x];

lpoint[{d_,h_},m_] := { mod [d m] , m h};
lpoint[{d_,h_},hat[m_]] := Module[{j,jp,jm},
j = lpoint[{d,h},m]; jp = j - {1,0}; jm = j+ {1,0}; (* should just test j[[1]]>0... *) 
If[ jp . jp < jm . jm, jp,jm]
];

(*pvector[{d_,h_},m_] := If[zeroParastichyQ[m],{1,0},lpoint[{d,h},m]];

*)

latticePoint[lattice_,m_] :=lpoint[{lattice["d"],lattice["h"]},m];
latticePointWithCopies[lattice_,m_] := Module[{cylinder,lp,i,x},
(* including periodic copies within the display cylinder *) 
cylinder = latticeGetCylinder[lattice];
lp = latticePoint[lattice,m];
If[cylinder[[1]]== {-1/2,1/2},Return[{lp}]]; (* should be the same *)
x = lp[[1]];
Return[Table[lp + i {1,0},{i,Ceiling[cylinder[[1,1]]-x],Floor[cylinder[[1,2]]-x]}]]
];

latticeVector[lattice_,m_] :=If[zeroParastichyQ[m],{1,0},latticePoint[lattice,m]];


(* ::Input::Initialization:: *)
latticePointH[lattice_,m_] := latticePoint[lattice,m][[2]];
latticePointD[lattice_,m_] := latticePoint[lattice,m][[1]];
latticeRise[lattice_] := latticePointH[lattice,1]; (* will be the same as lattice["h"] for h > 0 *) 
latticeDivergence[lattice_] := latticePointD[lattice,1]; (* will be the same as lattice["d"] for -1/2<d<1/2 *) 
latticeVectorLength[lattice_,m_] :=  Norm[ latticeVector[lattice,m]];


(* ::Input::Initialization:: *)
latticePrincipal3ParastichyLines[lattice_] := Map[latticeParastichyLines[lattice,#]&,latticePrincipal3ParastichyNumbers[lattice]];

latticePrincipalParastichyLines[lattice_] := Map[latticeParastichyLines[lattice,#]&,latticePrincipalParastichyPair[lattice]];

barem[m_] :=m /. hat -> Identity;
zeroParastichyQ[m_] := barem[m] == 0;

latticeParastichySlope[lattice_,m_] := Module[{parastichyVectorM,pSlope},
parastichyVectorM = latticePoint[lattice,m];
 If[parastichyVectorM[[1]]==0 ,Return[\[Infinity]]];
parastichyVectorM[[2]]/parastichyVectorM[[1]]
];

latticeParastichyVerticalSeparation[lattice_,m_] := Module[{parastichyVectorM,pSlope},
 If[zeroParastichyQ[m],Return[latticeRise[lattice]]];
parastichyVectorM = latticePoint[lattice,m];
 If[parastichyVectorM[[1]]==0 ,Return[0]];
pSlope = parastichyVectorM[[2]]/parastichyVectorM[[1]];
latticeRise[lattice]/pSlope
];

latticeParastichyHorizontalSeparation[lattice_,m_] := Module[{},
If[zeroParastichyQ[m],Return[1]];
1/barem[m]
];



(* ::Input::Initialization:: *)
linelineIntersection[line1_,line2_] := Module[{x1,y1,x2,y2,x3,y3,x4,y4,x,y,m1,m2},
{ {x1,y1},{x2,y2} } = line1;
{{ x3,y3},{x4,y4}} = line2;
m1 = { {x,y,1},{x1,y1,1},{x2,y2,1}};
m2 = {{ x,y,1},{x3,y3,1},{x4,y4,1}};
{x,y}  /. Solve[{Det[m1]==0,Det[m2]==0},{x,y}][[1]]
];



(* ::Input::Initialization:: *)
latticeParastichyCylinderIntersection[lattice_,m_,type_] :=Module[{arena,arenaBottomIntersection,arenaTopIntersection},
If[zeroParastichyQ[m],Abort[]];
arena = latticeGetCylinder[lattice];
arenaBottomIntersection = linelineIntersection[
{{  arena[[1,1]], arena[[2,1]]},{ arena[[1,2]],arena[[2,1]]}},
{ {0,0},  latticeVector[lattice,m]}][[1]];
arenaTopIntersection = linelineIntersection[
{{  arena[[1,1]], arena[[2,2]]},{ arena[[1,2]],arena[[2,2]]}},
{ {0,0},  latticeVector[lattice,m]}][[1]];
If[type===Bottom,
arenaBottomIntersection,arenaTopIntersection]
];


(* ::Input::Initialization:: *)
(* use funcs above ...*) 
(*latticeParastichyRangeObsolete[lattice_,m_] :=  Module[{multiple,parastichyLine,arena,ilowerB, iupperB,translationD},
arena = latticeGetCylinder[lattice];
If[zeroParastichyQ[m],
translationD = latticeParastichyVerticalSeparation[lattice,0];ilowerB = -Floor[(  - arena\[LeftDoubleBracket]2,1\[RightDoubleBracket])/translationD];iupperB = Floor[(arena\[LeftDoubleBracket]2,2\[RightDoubleBracket])/ translationD];
Return[{ilowerB,iupperB}]
];
(* or a slope *)
translationD= Abs[latticeParastichyHorizontalSeparation[lattice,m]];arenaBottomIntersection = linelineIntersection[{{  arena\[LeftDoubleBracket]1,1\[RightDoubleBracket], arena\[LeftDoubleBracket]2,1\[RightDoubleBracket]},{ arena\[LeftDoubleBracket]1,2\[RightDoubleBracket],arena\[LeftDoubleBracket]2,1\[RightDoubleBracket]}},{ {0,0},  latticeVector[lattice,m]}]\[LeftDoubleBracket]1\[RightDoubleBracket];arenaTopIntersection = linelineIntersection[{{  arena\[LeftDoubleBracket]1,1\[RightDoubleBracket], arena\[LeftDoubleBracket]2,2\[RightDoubleBracket]},{ arena\[LeftDoubleBracket]1,2\[RightDoubleBracket],arena\[LeftDoubleBracket]2,2\[RightDoubleBracket]}},{ {0,0},  latticeVector[lattice,m]}]\[LeftDoubleBracket]1\[RightDoubleBracket];ilowerB = -Floor[( arenaBottomIntersection - arena\[LeftDoubleBracket]1,1\[RightDoubleBracket])/translationD];iupperB = Floor[(arena\[LeftDoubleBracket]1,2\[RightDoubleBracket]- arenaBottomIntersection )/ translationD];Return[{ilowerB,iupperB}]
];*)


(* ::Input::Initialization:: *)
(* use funcs above ...*) 
latticeParastichyPointsThrough[lattice_,m_] :=  Module[{multiple,parastichyLine,arena,ilowerB, iupperB,translationD},
arena = latticeGetCylinder[lattice];
If[zeroParastichyQ[m],
translationD = latticeParastichyVerticalSeparation[lattice,0];ilowerB = -Floor[(  - arena[[2,1]])/translationD];iupperB = Floor[(arena[[2,2]])/ translationD];
Return[Table[i,{i,ilowerB,iupperB}]]
];
(* or a slope *)
translationD= Abs[latticeParastichyHorizontalSeparation[lattice,m]];
(* special case *)  
(*If[translationD\[Equal]1,Return[{1,hat[1]}]];
*)
arenaBottomIntersection = linelineIntersection[{{  arena[[1,1]], arena[[2,1]]},{ arena[[1,2]],arena[[2,1]]}},{ {0,0},  latticeVector[lattice,m]}][[1]];arenaTopIntersection = linelineIntersection[{{  arena[[1,1]], arena[[2,2]]},{ arena[[1,2]],arena[[2,2]]}},{ {0,0},  latticeVector[lattice,m]}][[1]];ilowerB = -Floor[( arenaBottomIntersection - arena[[1,1]])/translationD];iupperB = Floor[(arena[[1,2]]- arenaBottomIntersection )/ translationD];Return[Table[i,{i,ilowerB,iupperB}]]

];


(* ::Input::Initialization:: *)
(* use funcs above ...*) 
latticeParastichyXZThrough[lattice_,m_] :=  Module[{multiple,parastichyLine,arena,ilowerB, iupperB,translationD},
arena = latticeGetCylinder[lattice];
If[zeroParastichyQ[m],
translationD = latticeParastichyVerticalSeparation[lattice,0];ilowerB = -Floor[(  - arena[[2,1]])/translationD];iupperB = Floor[(arena[[2,2]])/ translationD];
Return[Table[{arena[[1,1]],i *  translationD},{i,ilowerB,iupperB}]]
];
(* or a slope *)
translationD= Abs[latticeParastichyHorizontalSeparation[lattice,m]];
(* special case *)  
(*If[translationD\[Equal]1,Return[{1,hat[1]}]];
*)

arenaBottomIntersection = linelineIntersection[{{  arena[[1,1]], arena[[2,1]]},{ arena[[1,2]],arena[[2,1]]}},{ {0,0},  latticeVector[lattice,m]}][[1]];ilowerB = -Floor[( arenaBottomIntersection - arena[[1,1]])/translationD];iupperB = Floor[(arena[[1,2]]- arenaBottomIntersection )/ translationD];Return[Table[{arenaBottomIntersection+ i *  translationD,arena[[2,1]]},{i,ilowerB,iupperB}]]

];


(* ::Input::Initialization:: *)
latticeParastichyLines[lattice_,m_] :=  Module[{xtable },
xtable= latticeParastichyXZThrough[lattice,m];
 Map[latticeParastichyLinesThroughXZ[lattice,m,#]&,xtable]
];


(* ::Input::Initialization:: *)
latticeParastichyLinesThroughXZ[lattice_,m_,throughxz_] := Module[{pvecslope,bottom,top,cylinder,cylinderLU,line,i,lastXZ,nextX,nextZ,v},

cylinder = latticeGetCylinder[lattice];cylinderLU = cylinder[[2]];If[zeroParastichyQ[m], (* parastichy is horizontal *)
line = {{cylinder[[1,1]],throughxz[[2]]},{cylinder[[1,2]],throughxz[[2]]}},
(* or *) 
If[latticePoint[lattice,m][[1]]==0, (* parastichy is vertical *) 
line ={ {throughxz[[1]],cylinder[[2,1]]},{throughxz[[1]],cylinder[[2,2]]}},
(* or general case *) 
pvecslope = latticeParastichySlope[lattice,m];bottom = { (cylinderLU[[1]]-throughxz[[2]])/pvecslope +throughxz[[1]], cylinderLU[[1]]};top        = { (cylinderLU[[2]]-throughxz[[2]])/pvecslope+throughxz[[1]],cylinderLU[[2]]};
line = {};
lastXZ = bottom;
i=0;
While[
nextX = If[pvecslope>0, cylinder[[1,2]],cylinder[[1,1]] ];
nextZ = lastXZ[[2]]+(nextX-lastXZ[[1]])* pvecslope; (* assumes cylinder width a multiple of 1 *)
If[nextZ> cylinder[[2,2]],
nextZ =  cylinder[[2,2]];
nextX = lastXZ[[1]]+(nextZ-lastXZ[[2]])/pvecslope
];
line = Append[line,{lastXZ,{nextX,nextZ}}];
i++;
i< 50 && nextZ  < cylinder[[2,2]],
(* While body *)
lastXZ = Last@Last[line];
lastXZ[[1]] = If[pvecslope>0, cylinder[[1,1]],cylinder[[1,2]] ]
]
]
];

Line[line]
];




(* ::Input::Initialization:: *)
(*latticeParastichyLines[lattice_,m_,through_] := Module[{pvecm,thr,pvecslope,bottom,top,cylinder,cylinderLU,line,i,lastXZ,nextX,nextZ,v},
pvecm = latticePoint[lattice,m];thr = latticePoint[lattice,through];cylinder = latticeGetCylinder[lattice];cylinderLU = cylinder\[LeftDoubleBracket]2\[RightDoubleBracket];If[zeroParastichyQ[m],
v = latticeParastichyVerticalSeparation[lattice,0];line = {{cylinder\[LeftDoubleBracket]1,1\[RightDoubleBracket],v*through},{cylinder\[LeftDoubleBracket]1,2\[RightDoubleBracket],v*through}},(* or *) 
If[pvecm[[1]]==0,
v = latticeParastichyHorizontalSeparation[lattice,1];line ={ {v*through,cylinder\[LeftDoubleBracket]2,1\[RightDoubleBracket]},{v*through,cylinder\[LeftDoubleBracket]2,2\[RightDoubleBracket]}},
(* or general case *) 
pvecslope = pvecm\[LeftDoubleBracket]2\[RightDoubleBracket]/pvecm\[LeftDoubleBracket]1\[RightDoubleBracket];bottom = { (cylinderLU\[LeftDoubleBracket]1\[RightDoubleBracket]-thr\[LeftDoubleBracket]2\[RightDoubleBracket])/pvecslope +thr\[LeftDoubleBracket]1\[RightDoubleBracket], cylinderLU\[LeftDoubleBracket]1\[RightDoubleBracket]};top        = { (cylinderLU\[LeftDoubleBracket]2\[RightDoubleBracket]-thr\[LeftDoubleBracket]2\[RightDoubleBracket])/pvecslope+thr\[LeftDoubleBracket]1\[RightDoubleBracket],cylinderLU\[LeftDoubleBracket]2\[RightDoubleBracket]};
line = {};
lastXZ = bottom;
i=0;
While[
nextX = If[pvecslope>0, cylinder\[LeftDoubleBracket]1,2\[RightDoubleBracket],cylinder\[LeftDoubleBracket]1,1\[RightDoubleBracket] ];
nextZ = lastXZ\[LeftDoubleBracket]2\[RightDoubleBracket]+(nextX-lastXZ\[LeftDoubleBracket]1\[RightDoubleBracket])* pvecslope;
If[nextZ> cylinder\[LeftDoubleBracket]2,2\[RightDoubleBracket],
nextZ =  cylinder\[LeftDoubleBracket]2,2\[RightDoubleBracket];
nextX = lastXZ\[LeftDoubleBracket]1\[RightDoubleBracket]+(nextZ-lastXZ\[LeftDoubleBracket]2\[RightDoubleBracket])/pvecslope
];
line = Append[line,{lastXZ,{nextX,nextZ}}];
i++;
i< 50 && nextZ  < cylinder\[LeftDoubleBracket]2,2\[RightDoubleBracket],
(* While body *)
lastXZ = Last@Last[line];
lastXZ\[LeftDoubleBracket]1\[RightDoubleBracket] = If[pvecslope>0, cylinder\[LeftDoubleBracket]1,1\[RightDoubleBracket],cylinder\[LeftDoubleBracket]1,2\[RightDoubleBracket] ]
]
]
];

Line[line]
];
*)



(* ::Input::Initialization:: *)
latticeParallelogram[lattice_,m_,n_,through_] :=Module[{origin,pm,pn},
origin = latticePoint[lattice,through]; pm=latticePoint[lattice,m];pn=latticePoint[lattice,n];
 { origin, origin+pm,origin+pm+pn,origin+pn,origin}
];


(* ::Input::Initialization:: *)



latticeGraphicsCylinder[lattice_] :=  Rectangle @@ Transpose[latticeGetCylinder[lattice]];
latticeGraphicsPlotRange[lattice_] :=  latticeGetCylinder[lattice];



(* ::Input::Initialization:: *)
latticeVectorComplex[lattice_,m_] := latticePointComplex[lattice,m];
latticeVectorComplex[lattice_,0] :=  1;

latticePointComplex[lattice_,m_] := Module[{pt},
pt = latticePoint[lattice,m];
pt[[1]] + I pt[[2]]
];


latticeUV[{m_,n_},delta_] := Module[{uv},
(* the uv that has mv -nu= +1 (not Delta ), v pm- u pn=p1 and n pm - m p n=p0 *)
If[m==0,Return[{-1,0}]];
If[n==0,Return[{0,1}]];
uv=  euclideanUV[{m,barem[n]}]; (* natural uv may be plusminus 1 *)
If[delta<0,uv = -uv];
uv
];
(*
latticePVtoGPTransform[{m_,n_},{u_,v_},delta_] := Module[{},
LinearFractionalTransform[{{{-u}},{v},{- m delta},n delta}]
(* will map zn/zm to z1 *) 
];
*)
Clear[latticePVtoGPCoordinates];

latticePVtoGPCoordinates[{m_,n_},{u_,v_},delta_][d_,h_] := Module[{g,res},
g = LinearFractionalTransform[{{{-u}},{v},{- m delta},n delta}];
res = ComplexExpand@ReIm@ComplexExpand@Simplify[g[{d+ I h}][[1]]];
Simplify[res /.   {  - n u +  m v  } -> 1 ] 
(* nb latticeUV which was used to pick u,v  picks mv-nu=1 , not delta *)
];

(* has this as (unused)  inverse to demonstrate form*) 
(*transformGeneratingPointToPrincipalVectors[lattice_]:=Module[{m,n,u,v,delta},
{m,n} =latticePrincipalParastichyPair[lattice];
delta = latticeDelta[lattice];
{u,v} = lUV[{m,n},delta];
LinearFractionalTransform[{{{n delta}},{-v},{ m delta},-u}](* maps z1 to zn/zm *)
];*)


(* no computational point in this, but it allows us to check the functional form *)
generatingPointFromPrincipalVectors[lattice_] := Module[{m,n,u,v,delta,zm,zn,z,g,d,h},
{m,n} =latticePrincipalParastichyPair[lattice];
{zm,zn}= {latticeVectorComplex[lattice,m],latticeVectorComplex[lattice,n]};
delta = latticeDelta[lattice];
{u,v} = latticeUV[{m,n},delta];
(* will map zn/zm to z1 *) 
{d,h} = ComplexExpand@ReIm@ComplexExpand[zn/zm];
 latticePVtoGPCoordinates[{m,n},{u,v},delta][d,h]
]
latticeDelta[lattice_] := Module[{m,n},
{m,n}= latticePrincipalParastichyPair[lattice];
If[m==0,Return[1]];
If[n==0,Return[-1]];
 euclideanDelta[{m,barem[n]}]
];




(* ::Input::Initialization:: *)
latticeRenormalised[lattice_] := Module[{tran,lgpDH,transformedlgpDH,cylinderLU,hScale,pm,pn},
(* rotate and scale so that the old m-th parastichy vector is now (1,0) *)
{pm,pn} = latticePrincipalParastichyPair[lattice];

tran = latticeRenormalisationTransformation[lattice,pm] ;
(* that maps m to 0. we need a linearly independent n *)
lgpDH = latticePoint[lattice,pn];
transformedlgpDH = tran [ lgpDH]; 
(* pop back in the principal strip *) 
transformedlgpDH = dhPrincipalPoint[transformedlgpDH];
If[transformedlgpDH=={0,0},Abort[]];

cylinderLU = lattice["cylinder"][[2]];
(* work out the h-scaling, so the new display cylinder has as many points as the old one *)
If[ barem[pm] != 1 ,
hScale = transformedlgpDH[[2]]/lgpDH[[2]];
cylinderLU = hScale * cylinderLU;
];
latticeCreateDH[transformedlgpDH,cylinderLU]
];

dhPrincipalPoint[{d_,h_}] := Module[{principald,principalh},
 (* intend to make principal point dependent on lattice["cylinder"] *) 
principald = mod[d];
If[principald<0,principald=1+principald];
principalh = If[h>0,h,-h];
{principald,principalh}
];

latticeRenormalisationTransformation[lattice_,mvec_] := Module[{mEnd,mVectorLength,rot,sca,tran},
mEnd = latticePoint[lattice,mvec];
mVectorLength = latticeVectorLength[lattice,mvec];
rot = RotationTransform[{mEnd,{1,0}}];
sca = ScalingTransform[{1/mVectorLength,1/mVectorLength}];
tran = Composition[sca,rot];
tran
];




(* ::Input::Initialization:: *)
latticeMoebiusTransform[mp_,np_,Delta_][{dp_,hp_}] := Module[{u,v,dh},
dh[d_,h_,m_,n_,u_,v_] :=
{((d^2+h^2 )m u+n v-d (n u+m v))/((d^2+h^2)m^2-2 d m n+n^2),
h 1 /((d^2+h^2)m^2-2 d m n+n^2)};
dh[d_,\[Infinity],m_,n_,u_,v_] := {u/m,0};
{u,v} = euclideanUV[{mp,np},Delta];
Simplify@dh[dp,hp,mp,np,u,v]
];
latticeMoebiusTransform[m_,n_] := latticeMoebiusTransform[m,n,1]
latticeMoebiusTransform[1,0][{0,0}] := {1/2,\[Infinity]};
latticeMoebiusTransform[1,0][{0.,0.}] := {1/2,\[Infinity]};
latticeMoebiusTransform[0,1][{d_,h_}]  := {d,h};
latticeMoebiusTransform[0,1,Delta_][{d_,h_}]  := {d,h};


(* ::Input::Initialization:: *)
latticeHexagonal [{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[latticeDHHexagonalUpper[{m,n}],cylinderLU];

latticeTriplePoint[{m_,n_}] := latticeDHHexagonalLower[{m,n}];


(* ::Input::Initialization:: *)
latticeDHHexagonalLower[{m_,n_}]  := latticeMoebiusTransform[m,n][ { -1/2,Sqrt[3]/2}];
latticeDHHexagonalUpper[{m_,n_}]  := latticeMoebiusTransform[m,n][ { 1/2,Sqrt[3]/2}];

latticeHexagonalLower[{m_,n_}]:=  latticeCreateDH[latticeDHHexagonalLower[{m,n}]];
latticeHexagonalUpper[{m_,n_}]:=  latticeCreateDH[latticeDHHexagonalUpper[{m,n}]];

latticeTouchingCircle[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[
latticeMoebiusTransform[m,n][ {Cos[5\[Pi]/12],Sin[5\[Pi]/12]}]
,cylinderLU];
latticeEquiLength[{m_,n_},cylinderLU_:{-0.2,3.2}] := (* wrong ! *)
latticeCreateDH[
latticeMoebiusTransform[m,n][ {-1/2,1.2}]
,cylinderLU];
latticeOrthogonal[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[
latticeMoebiusTransform[m,n][ { 0,1}]
,cylinderLU];
latticeWithMN[{m_,n_},cylinderLU_:{-0.2,3.2}] := latticeCreateDH[
latticeMoebiusTransform[m,n][{0,(Sqrt[3]/(2)-.25)}]
,cylinderLU];



(* ::Input::Initialization:: *)
latticeCircles[lattice_] := Module[{latticeMargin,lplus,lminus,r,cylinderLU,latticep},
cylinderLU = latticeGetCylinder[lattice][[2]];
cylinderLU = cylinderLU + {-latticeRise[lattice],latticeRise[lattice]};
latticeMargin = latticeSetCylinderLU[lattice,cylinderLU];

latticep =  latticePoints[latticeMargin] ;
lplus = latticep+ Table[{1,0},Length[latticep]];
lminus =  latticep + Table[{-1,0},Length[latticep]];
r =latticeDiskRadius[latticeMargin];
Map[Circle[#,r]&,Join[ latticep,lplus,lminus]]
];

latticeDiskRadius[lattice_] := Module[{pv1},
pv1 = latticeParastichyVectors[lattice][First[latticePrincipalParastichyPair[lattice]]];
Sqrt[pv1 . pv1]/2
];


(* ::Input::Initialization:: *)
(* pairs of points define circles centred on the h-d axis *)


(* also some label and boundary points away from the  corners*)
inlabelh = Sqrt[3]/(2+0.5);

viPrincipalRegionEdgePoints  = <|  (* used for labelling *) 
labelInner -> {0,inlabelh},
labelOuter -> {0,1/inlabelh},
minusInner->   {-1-Cos[5\[Pi]/6],Sin[5\[Pi]/6]},
plusInner -> {1+Cos[5\[Pi]/6],Sin[5\[Pi]/6]},
minusOuter -> {-1/2,1.1},
plusOuter -> {1/2,1.1},
unitCircle -> {0,1}
|>;

viPrincipalRegionPoints  = <| 
minusUnit -> {-1/2,Sqrt[3]/2} ,
minusInfinity -> {-1/2,Infinity},
zero -> {0,0},
plusUnit -> {1/2,Sqrt[3]/2} ,
plusInfinity -> {1/2,Infinity}
|>;

viPrincipalRegionBoundaryPairs01 = <|
minusInner -> {viPrincipalRegionPoints[zero],viPrincipalRegionPoints[minusUnit]}
,unitCircle ->{viPrincipalRegionPoints[minusUnit],viPrincipalRegionPoints[plusUnit]}
,plusInner -> {viPrincipalRegionPoints[plusUnit],viPrincipalRegionPoints[zero]}
|>;
viPrincipalRegionBoundaryPairs10 = <|
minusOuter -> {viPrincipalRegionPoints[minusInfinity],viPrincipalRegionPoints[minusUnit]}
,unitCircle ->{viPrincipalRegionPoints[minusUnit],viPrincipalRegionPoints[plusUnit]}
,plusOuter -> {viPrincipalRegionPoints[plusUnit],viPrincipalRegionPoints[plusInfinity]}
|>;
viRegion01 = RegionDifference[
DiscretizeRegion[Disk[{0,0},1,{0,\[Pi]}],MaxCellMeasure->.001],
DiscretizeRegion[RegionUnion[Disk[{1,0},1,{0,\[Pi]}],Disk[{-1,0},1,{0,\[Pi]}]],MaxCellMeasure->.001]
];
viRegion10 =  RegionDifference[
DiscretizeRegion[Rectangle[{-1/2,0},{1/2,1.2}],MaxCellMeasure->.0009],
DiscretizeRegion[Disk[{0,0},1,{0,\[Pi]}],MaxCellMeasure->.001]
];


(* ::Input::Initialization:: *)



viRegionPoints[{m_,n_}] := Map[Simplify,Map[
latticeMoebiusTransform[m,n],viPrincipalRegionPoints]
];

mirrorAt1[g_] := GeometricTransformation[g,Composition[TranslationTransform[{1,0}],
ReflectionTransform[{1,0}]]
];
mirrorBoundaries[bdy_] := Module[{res},
res = KeyTake[bdy,{plusOuter,minusOuter,plusInner,minusInner,unitCircle}];
res = Map[mirrorAt1,res];
res
];

viRegionBoundaries[{m_,n_},doMirror_:False] := Module[{rpoints,pointPairsToCircles},


pointPairsToCircles[ {p1_,p2_}] := 
pairToCircle@Map[latticeMoebiusTransform[m,n],{p1,p2}];

rpoints = 
<| "01" ->Union[<|"mn"->{m,n}|>,Map[pointPairsToCircles,viPrincipalRegionBoundaryPairs01 ]]
,"10" -> Union[<|"mn"->{n,m}|>,Map[pointPairsToCircles,viPrincipalRegionBoundaryPairs10 ]]
|>;
If[doMirror,rpoints =Map[mirrorBoundaries,rpoints]];

rpoints
] 


linecircleIntersection[lineD_,Circle[centre_,r_,theta_]] := Module[{},
Sqrt[r^2 - (lineD-centre[[1]])^2]
];

viTouchingCircleBranch[{m_,n_}] := viRegionBoundaries[{m,n}]["10"][unitCircle];

circleToRest[Circle[xy_,r_,\[Theta]12_]] := Module[{\[Theta]1,\[Theta]2},
{\[Theta]1,\[Theta]2}=Sort[\[Theta]12];
{Circle[xy,r,{0,\[Theta]1}],Circle[xy,r,{\[Theta]2,\[Pi]}]}
];



viTouchingSecondaryBranch[{m_,n_}] := circleToRest@viRegionBoundaries[{m,n}]["10"][unitCircle];

viOpposedCircleBranch[mn_]  := getCircleBranch[mn,"Opposed"];
viNonOpposedCircleBranch[mn_]  := getCircleBranch[mn,"NonOpposed"];
getCircleBranch[{m_,n_},type_] := Module[{centre,branch,branchEndsD,branchEndsH,orthoPointD},
branch = viTouchingCircleBranch[{m,n}];
{centre,r,theta12} = Apply[List,branch];
branchEndsD = {centre[[1]]+ r Cos[theta12[[1]]],centre[[1]]+ r Cos[theta12[[2]]]};
branchEndsH = {centre[[2]]+ r Sin[theta12[[1]]],centre[[2]]+ r Sin[theta12[[2]]]};
orthoPointD = viOrthostichyD[{m,n-m}];
If[!IntervalMemberQ[Interval[branchEndsD],orthoPointD],
If[type=="Opposed", Return[branch],Return[Nothing[]]]];

orthoPointH = linecircleIntersection[orthoPointD,branch];
orthopt = {orthoPointD,orthoPointH};
branchEndOrder = Ordering[branchEndsH];
{lowerpt,triplept}  = Transpose[{branchEndsD,branchEndsH}][[branchEndOrder]];
res = If[type=="Opposed",
Circle[centre,r,Sort@{xyToArg[branch,orthopt],xyToArg[branch,lowerpt]}],
Circle[centre,r,Sort@{xyToArg[branch,triplept],xyToArg[branch,orthopt]}]
];
Return[res];
];

xyToArg[Circle[centre_,r_,theta_],xy_ ]:= ArcTan @@ ( xy - centre)


pairToCircle[{p1_,p2_}] := Module[{dp,rp,todr2,x1,y1,x2,c2,y2,d,r2},
(* given two points on an axis semicircle, (or a line) calc the region between then *)
If[ p1[[1]]==p2[[1]],
Return[ Line[{p1,p2}]]];
todr2 = (*First@Simplify@Solve[  {(x1-d)^2 + y1^2 \[Equal] r2, (x2-d)^2 + y2^2 \[Equal] r2},{d,r2}];*)
{(x1^2-x2^2+y1^2-y2^2)/(2 x1-2 x2),1/(4 (x1-x2)^2) (x1^4-4 x1^3 x2+x2^4+(y1^2-y2^2)^2+2 x2^2 (y1^2+y2^2)-4 x1 x2 (x2^2+y1^2+y2^2)+2 x1^2 (3 x2^2+y1^2+y2^2))};
{dp,rp} = (  todr2 /. { x1->p1[[1]], y1-> p1[[2]],x2-> p2[[1]],y2-> p2[[2]]} ) ;
p1Arg = ArcTan @@  ( p1 - {dp,0} );
p2Arg = ArcTan @@  ( p2 - {dp,0} );
Return[Circle[{dp,0},Sqrt[rp],Sort@{p1Arg,p2Arg}]]
]

viRegion[{m_,n_}] := Module[{pts01,pts10,rb01,rb10},

pts01 = Map[latticeMoebiusTransform[m,n],MeshCoordinates[viRegion01]];
rb01 = MeshRegion[pts01,{MeshCells[viRegion01,0],
MeshCells[viRegion01,1],MeshCells[viRegion01,2]}];
pts10 = Map[latticeMoebiusTransform[n,m],MeshCoordinates[viRegion01]]
/. ComplexInfinity-> 1.2;
rb10 = MeshRegion[pts10,{MeshCells[viRegion10,0],
MeshCells[viRegion10,1],MeshCells[viRegion10,2]}];
<| "01"->rb01 , "10"-> rb10 |>
]
viRegion[{0,1}] := 
<| "01"->viRegion01 , "10"-> viRegion10 |>;


viOrthostichyD[{m_,n_}] := Module[{v,w},
{v,w} = euclideanUV[{n,m+n}];
w/(n+m)
];


(* ::Input::Initialization:: *)
(*


*)

 viTriplePoint[{m_,n_}] := Module[{delta,tp,tp1,tp2,transform},

transform =  latticeMoebiusTransform[m,n];
(* two candidates from either end of the principal unit circle *) 
{tp1,tp2} = Map[transform,viPrincipalRegionBoundaryPairs01[unitCircle]];
(* we need the lower *)
tp = If[tp1[[2]]<tp2[[2]], tp1,tp2];
tp
];




(* ::Input::Initialization:: *)
(* https://mathematica.stackexchange.com/questions/11430/why-doesnt-normal-work-on-geometrictransformation *)

NormalizeGraphics[g_]:=Internal`InheritedBlock[{System`Private`InternalNormal},Unprotect[System`Private`InternalNormal];
System`Private`InternalNormal[gr:_Rotate|_Translate|_Scale|_GeometricTransformation,_]:=Module[{tmp=Quiet[transform2D[gr],TransformedRegion::reg]},tmp/;Head[tmp]=!=TransformedRegion];
Normal[g,{Rotate,Scale,Translate,GeometricTransformation}]]

transform2D[Rotate[g_,r_,p___]]:=TransformedRegion[g,RotationTransform[r,absolutePosition[g,p]]]

transform2D[Translate[g_,t_]]:=TransformedRegion[g,TranslationTransform[t]]

transform2D[Scale[g_,s_,p___]]:=TransformedRegion[g,ScalingTransform[s,absolutePosition[g,p]]]

transform2D[GeometricTransformation[g_,tf_]]:=TransformedRegion[g,tf/.Except[_TransformationRegion]:>AffineTransform[tf]]

absolutePosition[g_]:=absolutePosition[g,{Center,Center}]
absolutePosition[g_,{h:(Left|Center|Right),v:(Top|Center|Bottom)}]:=Module[{hrange,vrange},{hrange,vrange}=RegionBounds[g][[;;2]];
{Replace[h,{Left->Min,Center->Mean,Right->Max}][hrange],Replace[v,{Bottom->Min,Center->Mean,Top->Max}][vrange]}]
absolutePosition[g_,spec_]:=spec


(* ::Input::Initialization:: *)
latticeAddStem[lattice_,shape_] := Module[{res},
res = Append[lattice,spline3D-> shape];
shapeLU = MinMax@{shape[0,0][[3]],shape[0,1][[3]]};
res = latticeSetCylinderLU[res,shapeLU];
res
];
lattice3DradiusFunction[lattice_,v_] := Module[{xy},
xy=Take[lattice[spline3D][0,v],2];Sqrt[xy . xy]
];
(*
lattice3DZFunction[lattice_,v_] := lattice[spline3D][0,v][[3]];
*)
lattice3DDHToUV[lattice_][{d_,h_}] := Module[{shapeLU},
(* d maps to u as this is periodic in spline,  v goes from 0 to 1 as h goes over shapeLU of spline z values *) 
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
vofh[hp_] := (hp-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]); (* v from 0 to 1 over shape *)
{d,vofh[h]}
];
lattice3DPosition[lattice_,{d_,h_}] := lattice[spline3D] @@lattice3DDHToUV[lattice][{d,h}];

lattice3DPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
cylinderLU= latticeGetCylinder[lattice][[2]];
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[lattice3DPosition[lattice,#]&,latticePoints[subLattice]]
]
lattice3DParastichyOfV[lattice_,m_,n_][v_] := Module[{dL,pslope,h,vscale},
dL = latticeParastichyCylinderIntersection[lattice,m,Bottom]+
n*latticeParastichyHorizontalSeparation[lattice,m];
pslope = latticeParastichySlope[lattice,m];
shapeLU = MinMax@{lattice[spline3D][0,0][[3]],lattice[spline3D][0,1][[3]]};
vscale = shapeLU[[2]]-shapeLU[[1]]; (* h ranges over this as v goes from 0 to 1 *) 
h =  v * vscale ; 
lattice3DPosition[lattice,{ dL +h /pslope,h}] 
];
lattice3DParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[lattice3DParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
lattice3DPointsUpToV[lattice_,v_] := Module[{pts},
pts = lattice3DPoints[lattice];
Select[pts, Last[#] <   lattice[spline3D][0,v][[3]]&]
];



(* ::Input::Initialization:: *)
stemSmoothRadiusFunctionV[radiusF_,nPoints_:12] := Module[{stemPoints,radiusFunction},
(* helper smooth function for v in [0,1] *)
stemPoints = Table[radiusF[v/nPoints],{v,0,nPoints}];
radiusFunction=BSplineFunction[stemPoints];
radiusFunction
];


(* ::Input::Initialization:: *)
stemMakeSurfaceFunctionUV[lattice_,circumferenceFunction_,nPoints_:12] := Module[{cylinderLU,r},
cylinderLU =latticeGetCylinderLU[lattice];
r[v_] := circumferenceFunction[v]/(2\[Pi]); (* a radius function of 1 will correspond to a cylinder with circumference  2 pi  .. *) 
Function[{u,v}, {r[v] * Cos[ 2 \[Pi] u], r[v] * Sin[ 2 \[Pi] u], stemHeightFunction[lattice,v]} ]
];

stemArcLengthOfV[stem_][v_] := Module[{},
N@ArcLength[stemRadiusFunctionV[stem][s],{s,0,v}]
];
stemVInverseArcLengthFunctionS[stem_] := Module[{sofVTable},
(* maps (0,arclength[v=1] ) to (0,1)  *) 
sofVTable = Table[{stemArcLengthOfV[stem][v],v},{v,0,1,0.01}];
Interpolation[sofVTable] (* store this result in the stem<||> so we don't recalculate *) 
];
stemAreaDifferentialOfV[stem_][v_] :=Module[{x},2 \[Pi] stemRadiusFunctionV[stem][v] *
Sqrt[ 1 + ( D[stemRadiusFunctionV[stem][x],x])^2 /. x->v]];
stemSurfaceAreaBelowV[stem_][v_] := 
NIntegrate[stemAreaDifferentialOfV[stem][w],{w,0,v}];

stemVConstantAreaFunctionT[stem_] :=  Module[{tofVTable},
(* maps (0,shape surface area ) to (0,1)  *) 
tofVTable = Table[{stemSurfaceAreaBelowV[stem][v],v},{v,0,1,0.01}];
Interpolation[tofVTable] 
];

stemAddShape[lattice_,circumferenceFunction_] := Module[{stem,surfaceFunctionUV,shapeLU,vFunctionArcLength},
surfaceFunctionUV = stemMakeSurfaceFunctionUV[lattice,circumferenceFunction];
stem = Append[lattice,{
"surfaceXYZofUV"-> surfaceFunctionUV,"circumferenceFunctionV"->circumferenceFunction
}];
shapeLU = MinMax@{surfaceFunctionUV[0,0][[3]],surfaceFunctionUV[0,1][[3]]};
stem = latticeSetCylinderLU[stem,shapeLU];
vFunctionArcLength = stemVInverseArcLengthFunctionS[stem];
stem = Append[stem,{
"vArcLengthInverseS"-> vFunctionArcLength
}];
vFunctionArea = stemVConstantAreaT[stem];
stem = Append[stem,{"arcLengthSRange"-> N@{0,stemArcLengthOfV[stem][1]}}];
stem
];
stemRadiusFunctionV[stem_] := Function[v,stem["circumferenceFunctionV"][v]/(2\[Pi])]
stemShapeFunctionUV[stem_] := stem["surfaceXYZofUV"]; 
stemShapeFunctionUS[stem_] := Function[{u,s},
stemShapeFunctionUV[stem][u,stem["vArcLengthInverseS"][s]]
];

stemShapeLU[lattice_] := MinMax@{stemShapeFunctionUV[lattice][0,0][[3]],stemShapeFunctionUV[lattice][0,1][[3]]};
stemHeightFunction[lattice_,v_] := Module[{cylinderLU=latticeGetCylinderLU[lattice]},
cylinderLU[[1]] + v (cylinderLU[[2]] -cylinderLU[[1]])
];





(* ::Input::Initialization:: *)
stemPointsUpToV[lattice_,v_] := Module[{pts},
pts = stemPoints[lattice];
Select[pts, Last[#] <   stemShapeFunctionUV[lattice][0,v][[3]]&]
];
stemArcPointsUpToV[lattice_,v_] := Module[{pts},
pts = stemArcPoints[lattice];
Select[pts, Last[#] <   stemShapeFunctionUV[lattice][0,v][[3]]&]
];

stemPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
cylinderLU= latticeGetCylinderLU[lattice];
shapeLU = MinMax@{ stemShapeFunctionUV[lattice][0,0][[3]], stemShapeFunctionUV[lattice][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[stemPositionDH[lattice,#]&,latticePoints[subLattice]]
];

stemArcPoints[lattice_] := Module[{cylinderLU,shapeLU,subLattice},
(* display points with 0<v< 1 
but map h to arclength s, not v, so need a slightly taller lattice *)
cylinderLU= latticeGetCylinderLU[lattice];
shapeLU = MinMax@{ stemShapeFunctionUV[lattice][0,0][[3]], stemShapeFunctionUV[lattice][0,1][[3]]};
cylinderLU = MinMax@IntervalIntersection[Interval@cylinderLU,Interval@shapeLU];
(* ensure cylinder is within shape, so its h will map to a v within [0,1]. Otherwise the spline is unevaluated and slows down the graphics *) 
subLattice = latticeSetCylinderLU[lattice,cylinderLU];
Map[stemArcPositionDH[lattice,#]&,latticePoints[subLattice]]
];


stemPositionDH[lattice_,{d_,h_}] := stemShapeFunctionUV[lattice] @@stemDHToUV[lattice][{d,h}];
stemArcPositionDH[lattice_,{d_,h_}] := stemShapeFunctionUS[lattice] @@stemDHToUS[lattice][{d,h}];


stemDHToUV[lattice_][{d_,h_}] := Module[{shapeLU},
(* d maps to u as this is periodic in spline,  v goes from 0 to 1 as h goes over shapeLU of spline z values *) 
shapeLU = stemShapeLU[lattice];
vofh[hp_] := (hp-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]); (* v from 0 to 1 over shape height, not over arc length ! *)
{d,vofh[h]}
];

stemDHToUS[lattice_][{d_,h_}] := Module[{shapeLU,s,v},
(* d maps to u as this is periodic in spline, 
v from 0 to 1 ,  s from 0 to arclength  which is the top of the lattice cylinder *) 
shapeLU = stemShapeLU[lattice];
s =  (h-shapeLU[[1]])/(shapeLU[[2]]-shapeLU[[1]]);
(* v from 0 to 1 over shape height, not over arc length ! *)
{d,s}
];


stemParastichyOfS[stem_,m_,n_][v_] := Module[{},
stemParastichyOfV[stem,m,n][stemVInverseArcLengthFunctionS[stem][v] ]
];


(* ::Input::Initialization:: *)
stemParastichyOfV[stem_,m_,n_][v_] := Module[{dL,pslope,h,vscale,shapeLU},
dL = latticeParastichyCylinderIntersection[stem,m,Bottom]+
n*latticeParastichyHorizontalSeparation[stem,m];
pslope = latticeParastichySlope[stem,m];
shapeLU =stemShapeLU[stem];
vscale = shapeLU[[2]]-shapeLU[[1]]; (* h ranges over this as v goes from 0 to 1 *) 
h =  v * vscale ; 
stemPositionDH[stem,{ dL +h /pslope,h}] 
];

stemArcLengthParastichyOfV[stem_,m_,n_][v_] := Module[{dL,pslope,h,vscale,shapeLU},
dL = latticeParastichyCylinderIntersection[stem,m,Bottom]+
n*latticeParastichyHorizontalSeparation[stem,m];
pslope = latticeParastichySlope[stem,m];
shapeLU =stemShapeLU[stem];
vscale = shapeLU[[2]]-shapeLU[[1]]; 
h =  v * vscale *stem["arcLengthSRange"][[2]]; 
stemArcPositionDH[stem,{ dL +h /pslope,h}] 
];

stemParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[stemParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
stemArcLengthParastichyOfV[lattice_,m_][v_] := Module[{ilower,iupper },
{ilower,iupper}= latticeParastichyRangeObsolete[lattice,m];
Table[stemArcLengthParastichyOfV[lattice,m,n][v],{n,ilower,iupper}]
];
