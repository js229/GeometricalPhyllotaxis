(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;
diskTopZ[Disk[{_,z_},r_]] := z+r;
diskR[Disk[{_,_},r_]] := r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;
leftAndRightNumbers[n_List] := Join@@{n,moveNumberRight/@n,moveNumberLeft/@n};
bareNumber[left[n_]]  := n;
bareNumber[right[n_]] := n;
bareNumber[n_] := n;
bareNumberQ[n_] := n===bareNumber[n];

moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];
moveNumberedDiskLeft[n_->d_] := moveNumberLeft[n]->moveDiskLeft[d];


getDisk[n_] := getDiskFromRun[globalRun,n] 
getDiskFromRun[run_,n_] := run["DiskData"][n]["Disk"];
getDiskFromRun[run_,right[n_]] :=  moveDiskRight[getDiskFromRun[run,n]];
getDiskFromRun[run_,left[n_]] := moveDiskLeft[getDiskFromRun[run,n]];

getDiskXZ[run_,n_] := diskXZ[getDiskFromRun[run,n]];
getDiskXZ[n_] :=getDiskXZ[globalRun,n] ;
getDiskZ[run_,n_] := diskZ[getDiskFromRun[run,n]];getDiskZ[n_] :=getDiskZ[globalRun,n] ;

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2;
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2;
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);


disksMaximum[] := 
Max@Map[diskTopZ[getDisk[#]]&,Keys[globalRun["DiskData"]]];

highestDiskZ[run_] := Max@Map[diskZ[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];
(* used in RunCoinStacking as well for setup, so don't use the global *)

nextRadius[] := Module[{highestZ},
highestZ=highestDiskZ[globalRun];
globalRun["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[] := Max[bareNumber/@ VertexList[globalRun["ContactGraph"]]]+1;


(* ::Input::Initialization:: *)



executeRun[run_,chainMax_:Missing[]] := Module[{i,imax,res,diskTime},
Off[SSSTriangle::tri];

globalRun=run;

globalLastSupportDiskNumbers = VertexList[globalRun["ContactGraph"]];

If[!NumericQ[imax],imax=2000];
monitorFunction := For[i=1,i<= imax,i++,
If[runCompletesArena[],Break[]];
diskTime= First@Timing[addNextDisk[]];
];
monitorString := StringTemplate[" Z `Z`; per-chain time `timing`;next disk `disk`; parastichy `parastichy`"][<|
"disk"-> nextDiskNumber[]
,"Z"-> disksMaximum[]
,"timing"->diskTime
,"parastichy"->monitorParastichy
(*,"gxy"->AnnotationValue[{globalRun["ContactGraph"],1},VertexCoordinates]
*)|>];
If[False,monitorFunction,Monitor[monitorFunction,monitorString]];

result= postRun[globalRun];
Print[First[result["Chains"]]];
result
];



(* ::Input::Initialization:: *)

runCompletesArena[] := Module[{cutoff},
cutoff= globalRun["Arena"]["CylinderLU"][[2]]+ 2 * globalRun["Arena"]["rFunction"][globalRun["Arena"]["CylinderLU"][[2]]];
disksMaximum[]>cutoff || Max[Keys[globalRun["DiskData"]]]> globalRun["Arena"]["diskMax"]
];




(* ::Input::Initialization:: *)

diskListRowFromDisk[node_,disk_] := Module[{},
node-><|"DiskNumber"->node,"Disk"->disk|>
];

addNextDisk[]:=Module[{nextR,row,n,timing},
nextR=nextRadius[];
row=findNextDiskFromSupportSet[nextR];
n=nextDiskNumber[];

updateContactGraph[n,row["NextDisk"],row["NextDiskRestsOn"]];
AppendTo[globalRun["DiskData"],
diskListRowFromDisk[n,row["NextDisk"]]];
globalLastSupportDiskNumbers= Join[globalLastSupportDiskNumbers,leftRightCouldSupport[
globalRun["ContactGraph"],n,nextRadius[]]];

]


(* ::Input::Initialization:: *)
findNextDiskFromSupportSet[nextR_]:= Module[{supportTable,res},
supportTable=supportPairs[nextR];
supportTable= SortBy[supportTable,diskZ[#NextDisk]&];
If[Length[supportTable]==0,Print["No valid supports"];Abort[]];
res=First[supportTable];
res
];


(* ::Input::Initialization:: *)

vectorXZ[n1_\[DirectedEdge]n2_ | n1_\[UndirectedEdge] n2_ | {n1_,n2_}] := Module[{}, getDiskXZ[n2]-getDiskXZ[n1]];

neighbours[g_,n_] :=  Complement[VertexList[Graph[EdgeList[g,n\[UndirectedEdge]_]]],{n}]
vectorsFromNode[g_,n_] := Module[{nbrs},
nbrs := Join[Map[ n\[DirectedEdge] # & , neighbours[g,n]],Map[ left[n]\[DirectedEdge] # & , neighbours[g,left[n]]]];
Association@Map[#->vectorXZ[#]&,nbrs]
];

clockwiseSortFunction[xy_] := Module[{x,y},
{x,y}=xy/Norm[xy];
-If[x>0,1+y,-(1+y)]
]; (* sorts in clockwise order *)

mostClockwiseEdgeFromNode[g_,n_] := Module[{vectors},
vectors = vectorsFromNode[g,n];
If[Length[vectors]==0,Return[Missing[]]];
vectors = SortBy[vectors,clockwiseSortFunction];
First[Keys[vectors]]
];

topChain[graph_] := Module[{g,chain,neighbours,highestNode,lastNode,nextNode,from,nextEdge,chainMax=500},

g=graph;
highestNode=Last[SortBy[Select[VertexList[g],bareNumberQ],getDiskZ[#]&]];


nbrs[n_] := Join[Map[ n\[DirectedEdge] # & , neighbours[g,n]],Map[ left[n]\[DirectedEdge] # & , neighbours[g,left[n]]]];
chain= {highestNode};

For[i=1,i<chainMax,i++,
lastNode=Last[chain];
nextEdge =mostClockwiseEdgeFromNode[g,lastNode];
If[MissingQ[nextEdge], (* may only happen for 1 left[1] megabodge *)
Break[]];
{from,nextNode}=List@@nextEdge;
If[MatchQ[from,left[_]],chain=Append[chain,from]];
chain=Append[chain,nextNode];
g=EdgeDelete[g,from\[UndirectedEdge]nextNode]; (* could move up into backwards branch *);
If[MatchQ[Last[chain],right[_]],
chain=Append[chain,moveNumberLeft[Last[chain]]]];

If[Last[chain]==First[chain],Break[];]
];If[i==chainMax,Print["i10"];Abort[]];
chain
];




(* ::Input::Initialization:: *)
supportPairs[nextR_] :=Module[{supportGraph,supportChain},
supportGraph=  Subgraph[globalRun["ContactGraph"],globalLastSupportDiskNumbers];
(* topchain picks the top of the graph, but is faster if we only supply the subgraph corresponding to the current support *) 
supportChain = topChain[supportGraph];
globalLastSupportDiskNumbers=disksInSupportChain[supportGraph,supportChain,nextR];
supportPairsFromSupportDisks[globalLastSupportDiskNumbers,nextR]
];

disksInSupportChain[g_,chain_,nextR_] :=
addLeftRightSupporters[g,DeleteDuplicates[chain],nextR]; 

addLeftRightSupporters[g_,sDisks_,nextR_] := Module[{},
supportDisks=sDisks;
supportDisks= DeleteDuplicates[bareNumber/@ supportDisks];
supportDisks =Flatten[Map[leftRightCouldSupport[g,#,nextR]&,supportDisks]];
supportDisks
]

supportPairsFromSupportDisks[supportDisks_,nextR_] :=Module[{pairs,supportTable,extendedDisks,res},

pairs = Flatten[Table[{supportDisks[[i]],supportDisks[[j]]},{i,1,Length[supportDisks]},{j,1,Length[supportDisks]}],1];

supportTable = Association@Map[makeSupportTableRow[#]&,pairs];
(* assumes r nonincreasing *)
supportTable = Select[supportTable,Abs[#EdgeSeparation]< 2* nextR&];
(* now calculate the next disk position for the pair *) 
supportTable = Map[Append[#,"NextDisk"->diskOnThisPair[#NextDiskRestsOn,nextR]]&,supportTable];
supportTable = Select[supportTable,!MissingQ[#NextDisk]&];
supportTable = Select[supportTable,diskIsNormalised[#NextDisk]&];
(* check for disk which intersect existing disks *) 
disksToCheckIntersection=Association@Map[#-> getDisk[#]&,supportDisks];
supportTable= Map[supportTableFindIntersections[#,nextR,disksToCheckIntersection]&,supportTable];
supportTable= Select[supportTable,Length[#Intersection]==0&];

supportTable
];


leftRightCouldSupport[g_,node_,nextR_] := Module[{xy,res},

res= {node};
xy = getDiskXZ[node];
If[xy[[1]]-1 >=-0.5-  2* nextR,res=Append[res,left[node]]];
If[xy[[1]]+1 <=   0.5+  2* nextR,res=Append[res,right[node]]];
res 
];


makeSupportTableRow[{node1_,node2_}] := Module[{res,hDiff},
hDiff= diskX[getDisk[node2]]-diskX[getDisk[node1]];
If[hDiff<= 0,Return[Nothing[]]];
res=<|"NextDiskRestsOn"->{node1,node2}
, "EdgeSeparation"->diskLeftX[getDisk[node2]]-diskRightX[getDisk[node1]] 
|>;
{node1,node2}->res
]


supportTableFindIntersections[row_,nextR_,disks_] := Module[{res,extendedDisks,locationIntersectsQ,intersections},
intersections= Map[diskdiskIntersectionQ[row["NextDisk"],#]&,KeyDrop[disks,row["NextDiskRestsOn"]]];
intersections= Keys@Select[ intersections,TrueQ];
Append[row,"Intersection"->intersections]
];


diskOnThisPair[{n1_,n2_},r_] := Module[{res,d1,d2,xl,xr,xres},
d1 = getDisk[n1];
d2 = getDisk[n2];
res = diskdiskUpperTouchingPoint[{d1,d2},r];
If[MissingQ[res],Return[res]]; (* no overlap *) 
Disk[res,r]
];
diskdiskIntersectionQ[Disk[xy1_,r1_],Disk[xy2_,r2_]]:= Norm[xy1-xy2,2] < (r1+ r2);




(* ::Input::Initialization:: *)


updateContactGraph[n_,disk_,{n1_,n2_}] := Module[{g,d,d1,d2,d1Left},
g = globalRun["ContactGraph"];
g= vertexAddDisk[g,n,disk];

If[!bareNumberQ[n1],
 g= vertexAddSideDisk[g,n1]];
If[!bareNumberQ[n2],
 g= vertexAddSideDisk[g,n2]];
g= EdgeAdd[g,
{n \[UndirectedEdge] n1,n \[UndirectedEdge] n2 }];

globalRun["ContactGraph"]=g;

];




(* ::Input::Initialization:: *)
vertexAddDisk[g_,v_,Disk[xz_,r_]] := Module[{vxy,vr,res},
res = VertexAdd[g,v];
(*AnnotationValue[{res,v},VertexCoordinates]=xz;
AnnotationValue[{res,v},"DiskRadius"]=r;*)
res
];
vertexAddSideDisk[g_,v_] :=Module[{res,baseDiskXZ,baseDiskR,xz},
res= VertexAdd[g,v];
(*baseDiskXZ= AnnotationValue[{res,bareNumber[v]},VertexCoordinates];
baseDiskR= AnnotationValue[{res,bareNumber[v]},"DiskRadius"];
If[MatchQ[v,left[_]],xz=baseDiskXZ-{1,0}];
If[MatchQ[v,right[_]],xz=baseDiskXZ+{1,0}];
AnnotationValue[{res,v},VertexCoordinates]=xz;
AnnotationValue[{res,v},"DiskRadius"]=baseDiskR;
*)
res
];





(* ::Input::Initialization:: *)
(*  *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= newdiskdiskTouchingPoint[pairDisks,r];

If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];



(* ::Input::Initialization:: *)


newdiskdiskTouchingPoint[diskPair_,r_] := Module[{c1,c2,r1,r2,interdisk,interdiskVectorNorm,interdiskNormal,
angle,vector,normal,interdiskVector},
{c1,c2}= Map[diskXZ,diskPair];
{r1,r2}= Map[diskR,diskPair];
interdiskVector = c2-c1;
interdisk = Norm[interdiskVector];
interdiskVectorNorm = interdiskVector/Norm[interdiskVector];
interdiskNormal =  {-interdiskVectorNorm[[2]],interdiskVectorNorm[[1]]};


angle = sssTriangleInteriorAngle[r2+r,r+r1,interdisk];
If[MissingQ[angle],Return[angle]];
vector=(r1+r)*Cos[angle]*interdiskVectorNorm;
normal = (r1+r)*Sin[angle]* interdiskNormal;
{c1+vector+normal,c1+vector-normal}

]
sssTriangleInteriorAngle[a_,b_,c_] := Module[{tri,angle},
tri =SSSTriangle[a,b,c];
If[Head[tri]==SSSTriangle,
Return[Missing["Not a triangle"]]];
angle = TriangleMeasurement[tri,{"InteriorAngle",1}];
angle
];



(* ::Input::Initialization:: *)

pretty[run_] := Module[{g,setGraphXY,res,vc,es},
g=run["ContactGraph"];
vc = Map[getDiskXZ[run,#]&,VertexList[g]];
g = Graph[g,VertexCoordinates->vc];
es = Map[#->edgeStyle[#]&,EdgeList[g]];
g= Graph[g,EdgeStyle->es];
g=Graph[g,VertexLabels->None];
res=run;
res["ContactGraph"]=g;
res
];
edgeStyle[upper_ \[UndirectedEdge] lower_] := Module[{vxy},
vxy=vectorXZ[upper\[UndirectedEdge] lower];
If[First[vxy]>= 0,Blue,Red]
]
edgeStyle[upper_ \[DirectedEdge] lower_] := edgeStyle[upper \[UndirectedEdge] lower]


(* ::Input::Initialization:: *)

lowerEdges[g_,node_]:=  Select[vectorsFromNode[g,node],Last[#]<0&];
 edgeCheck[run_] := Module[{g,res},
g=run["ContactGraph"];
res=Map[lowerEdges[g,#]&,Complement[Select[VertexList[g],bareNumberQ],{1}]];
If[Or@@ Map[Length[#]!=2&,res],"Print some nodes without two supports"];
edgeStyler[edgeList_] := Map[edgeStyle,edgeList];
res = Map[Sort@edgeStyler[Keys[#]]=={RGBColor[0, 0, 1],RGBColor[1, 0, 0]}&,res];
If[Or@@ res,"Print some lopsided nodes"];

];

postRun[run_] := Module[{res,chains},
res = pretty[run];
edgeCheck[res];
chains= topdownChains[res["ContactGraph"]];

res=Prepend[res,"Chains"->chains];
res["ContactGraph"]=reColour[res];
res
];

reColour[run_] := Module[{g,chains,v,e},
chains=Map[#Chain&,run["Chains"]];
vList[gr_] := Map[#->AnnotationValue[{gr,#},VertexCoordinates]&,VertexList[gr]];v=vList[run["ContactGraph"]];

eList[gr_] := Map[#->AnnotationValue[{gr,#},EdgeStyle]&,EdgeList[gr]];

chainEdges=Association@Flatten@Map[eList,Values@chains];
grayChains= Association@Map[#->Gray&,EdgeList[run["ContactGraph"]]];
chainEdges=Join[grayChains,chainEdges];
Graph[Keys[v],Keys[chainEdges],
VertexCoordinates->Values[v],
EdgeStyle->KeyValueMap[#1->#2&,chainEdges]]
];

topdownChains[graph_] := Module[{i,g,chainGraphSet,chain,chainGraph},
(* relies on looking coordinates up in globalRun ... *)
g=Graph[graph,VertexLabels->"Name"];
chainGraphSet=List[];
For[i=1,i<1000,i++,
chain=topChain[g];

chainGraph=Subgraph[g,chain];
chainGraph= Graph[chainGraph,VertexLabels->"Name"];
chainGraphSet=Append[chainGraphSet, chainGraph];
g=stripChain[g,chain];
If[Length[VertexList[g]]==0,Break[]];
];
chainSet=
Reverse@Association@MapIndexed[First[#2]-><|"Chain"->#1|>&,Reverse[chainGraphSet]];
chainSet= Map[Append[#,"Parastichy"->chainParastichy[#Chain]]&,chainSet];
chainSet= Map[Append[#,"MeanZ"->chainMeanZ[#Chain]]&,chainSet];
chainSet
];

chainMeanZ[chain_] := Last@Mean@Map[AnnotationValue[{chain,#},VertexCoordinates]&,Drop[VertexList[chain],-1]];

stripChain[g_,chain_]:= Module[{lrchain},
lrchain =leftAndRightNumbers[DeleteDuplicates[bareNumber/@chain]];

lrchain= Intersection[lrchain,VertexList[g]];
VertexDelete[g,lrchain]
];

chainParastichy[chain_]:=Module[{},
If[AcyclicGraphQ[chain],
acyclicChainParastichy[chain]
,cyclicChainParastichy[chain]
]
];

cyclicChainParastichy[chain_] := Module[{edges,res},
(*If[Length[FindCycle[chain,{4,\[Infinity]}]]!=0,Print["4cycle found"]];
*)
edges= Flatten[FindCycle[chain,Infinity,All],2];
res=Association@Map[#->EdgeDelete[chain,#]&,edges];
res=Select[res,gIsLinear];
res=Select[res,gIsChain];
If[Length[res]==0,
Return[Missing["Can't decyclic"]]];
(*If[Length[res]>1,w=res;Print["Multi decyclics",chain,res]];
*)res=First[res];
If[!AcyclicGraphQ[res],
Print["Can't declyce",chain];Return[Missing[]]];
acyclicChainParastichy[res]
];

gIsLinear[g_] := Module[{res},
res=Map[EdgeCount[g,#\[UndirectedEdge] _]&,VertexList[g]];
And@@Map[#<=2&,res]
];
gIsChain[g_] := Module[{v,first,last,graph},
v=VertexList[g];
v=SortBy[v,AnnotationValue[{g,#},VertexCoordinates]&];
first=First[v];last=Last[v];
graph=VertexDelete[g,{first,last}];
ConnectedGraphQ[graph]
];


acyclicChainParastichy[chain_]:=Module[{},
If[!AcyclicGraphQ[chain],Print["aCP"];Abort[]];
KeySort@Counts[Map[AnnotationValue[{chain,#},EdgeStyle]&,EdgeList[chain]]
]
];




