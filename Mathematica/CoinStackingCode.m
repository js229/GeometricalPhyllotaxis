(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;
diskTopZ[Disk[{_,z_},r_]] := z+r;
diskR[Disk[{_,_},r_]] := r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;
leftAndRightNumbers[n_List] := Join@@{n,moveNumberRight/@n,moveNumberLeft/@n};
bareNumber[left[n_]]  := n;
bareNumber[right[n_]] := n;
bareNumber[n_] := n;
bareNumberQ[n_] := n===bareNumber[n];

moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];
moveNumberedDiskLeft[n_->d_] := moveNumberLeft[n]->moveDiskLeft[d];


getDisk[n_] := getDiskFromRun[globalRun,n] 
getDiskFromRun[run_,n_] := run["DiskData"][n]["Disk"];
getDiskFromRun[run_,right[n_]] :=  moveDiskRight[getDiskFromRun[run,n]];
getDiskFromRun[run_,left[n_]] := moveDiskLeft[getDiskFromRun[run,n]];

getDiskXZ[run_,n_] := diskXZ[getDiskFromRun[run,n]];
getDiskXZ[n_] :=getDiskXZ[globalRun,n] ;
getDiskZ[run_,n_] := diskZ[getDiskFromRun[run,n]];getDiskZ[n_] :=getDiskZ[globalRun,n] ;

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2;
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2;
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);


disksMaximum[] := 
Max@Map[diskTopZ[getDisk[#]]&,Keys[globalRun["DiskData"]]];

highestDiskZ[run_] := Max@Map[diskZ[getDiskFromRun[run,#]]&,Keys[run["DiskData"]]];
(* used in RunCoinStacking as well for setup, so don't use the global *)

nextRadius[] := Module[{highestZ},
highestZ=highestDiskZ[globalRun];
globalRun["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[] := Max[bareNumber/@ VertexList[globalRun["ContactGraph"]]]+1;


(* ::Input::Initialization:: *)



executeRun[run_,chainMax_:Missing[]] := Module[{i,imax,res,diskTime},
Off[SSSTriangle::tri];

globalRun=run;

If[MissingQ[globalRun["LastSupportDiskNumbers"]],
globalRun["LastSupportDiskNumbers"] = VertexList[globalRun["ContactGraph"]]];

If[!NumericQ[imax],imax=20000];
monitorFunction := For[i=1,i<= imax,i++,
If[runCompletesArena[],Break[]];
diskTime= First@Timing[addNextDisk[]];
];
monitorString := Module[{},
monitorZtogo= run["Arena"]["zMax"]-monitorZ;
monitorDiskstogo= monitorZtogo/monitorRise;

StringTemplate["next disk `disk`; Z `ztogo`; per-disk time `timing`"][<|
"disk"-> nextDiskNumber[]
,"Z"->  disksMaximum[]
,"monitorZtogo"->monitorZtogo
,"diskstogo"->monitorDiskstogo
,
"ztogo"-> run["Arena"]["zMax"]-monitorZ
,"monitorRise"->monitorRise
,"monitorDiskstogo"->monitorDiskstogo
,"radius"->diskR[Last[globalRun["DiskData"]]]
,"Zmax"->run["Arena"]["zMax"]
,"timing"->diskTime
|>]
];
If[False,monitorFunction,Monitor[monitorFunction,monitorString]];

result= postRun[globalRun];
result
];



(* ::Input::Initialization:: *)

runCompletesArena[] := Module[{cutoff},
disksMaximum[]>globalRun["Arena"]["zMax"] || 
Max[Keys[globalRun["DiskData"]]]> globalRun["Arena"]["diskMax"]
];




(* ::Input::Initialization:: *)

diskListRowFromDisk[node_,disk_] := Module[{},
node-><|"DiskNumber"->node,"Disk"->disk|>
];

addNextDisk[]:=Module[{nextR,row,n,timing,disk},

nextR=nextRadius[];

row=newFindNextDiskFromSupportSet[nextR];
disk = row["NextDisk"];
disk= jiggleDisk[run,disk];
n=nextDiskNumber[];


updateContactGraph[n,row["NextDiskRestsOn"]];
AppendTo[globalRun["DiskData"],
diskListRowFromDisk[n,disk]];
globalRun["LastSupportDiskNumbers"]= Join[globalRun["LastSupportDiskNumbers"],
leftRightCouldSupport[n,nextRadius[]]];

monitorRise=disksMaximum[]-monitorZ;
monitorZ= disksMaximum[];

];

jiggleDisk[run_,disk_] := Module[{res,noise},
res=disk;
noise=run["Arena"]["Noise"];
If[MissingQ[noise],Return[res]];

res=jiggleDiskRadius[res,noise];
Return[res];
];

jiggleDiskRadius[Disk[xy_,r_],noise_] := Disk[xy,RandomReal[r*{1-noise,1+noise}]]


(* ::Input::Initialization:: *)

newFindNextDiskFromSupportSet[nextR_]:= Module[{newSupportTable,res},
newSupportTable=newsupportPairs[nextR];
newSupportTable= SortBy[newSupportTable,diskZ[#NextDisk]&];
If[Length[newSupportTable]==0,Print["No valid supports looking for ", nextDiskNumber[]];Abort[]];
res=First[newSupportTable];
res
];


(* ::Input::Initialization:: *)

vectorXZ[run_,n1_\[DirectedEdge]n2_ | n1_\[UndirectedEdge] n2_ | {n1_,n2_}] := Module[{}, getDiskXZ[run,n2]-getDiskXZ[run,n1]];

neighbours[g_,n_] :=  Complement[VertexList[Graph[EdgeList[g,n\[UndirectedEdge]_]]],{n}]

vectorsFromNode[run_,g_,n_] := Module[{nbrs},
nbrs := Join[Map[ n\[DirectedEdge] # & , neighbours[g,n]],Map[ left[n]\[DirectedEdge] # & , neighbours[g,left[n]]]];
Association@Map[#->vectorXZ[run,#]&,nbrs]
];

clockwiseSortFunction[xy_] := Module[{x,y},
{x,y}=xy/Norm[xy];
-If[x>0,1+y,-(1+y)]
]; (* sorts in clockwise order *)

mostClockwiseEdgeFromNode[run_,g_,n_] := Module[{vectors},
vectors = vectorsFromNode[run,g,n];
If[Length[vectors]==0,Return[Missing[]]];
vectors = SortBy[vectors,clockwiseSortFunction];
First[Keys[vectors]]
];

topChain[graph_] := topChainInRun[globalRun,graph];

topChainInRun[run_,graph_] := Module[{g,chain,neighbours,highestNode,lastNode,nextNode,from,nextEdge,chainMax=500},

g=graph;
highestNode=Last[SortBy[Select[VertexList[g],bareNumberQ],getDiskZ[run,#]&]];


nbrs[n_] := Join[Map[ n\[DirectedEdge] # & , neighbours[g,n]],Map[ left[n]\[DirectedEdge] # & , neighbours[g,left[n]]]];
chain= {highestNode};

For[i=1,i<chainMax,i++,
monitorTopChainCount={"TopChain",Length[VertexList[g]],i};
lastNode=Last[chain];
nextEdge =mostClockwiseEdgeFromNode[run,g,lastNode];
If[MissingQ[nextEdge], (* may only happen for 1 left[1] megabodge *)
Break[]];
{from,nextNode}=List@@nextEdge;
If[MatchQ[from,left[_]],chain=Append[chain,from]];
chain=Append[chain,nextNode];
g=EdgeDelete[g,from\[UndirectedEdge]nextNode]; (* could move up into backwards branch *);
If[MatchQ[Last[chain],right[_]],
chain=Append[chain,moveNumberLeft[Last[chain]]]];

If[Last[chain]==First[chain],Break[];]
];If[i==chainMax,Print["i10"];Abort[]];
chain
];




(* ::Input::Initialization:: *)

newsupportPairs[nextR_] :=Module[{supportGraph,supportChain},

supportGraph=  Subgraph[globalRun["ContactGraph"],globalRun["LastSupportDiskNumbers"]];
supportChain = topChain[supportGraph];


globalRun["LastSupportDiskNumbers"]=disksInSupportChain[supportChain,nextR];

res=newSupportPairsFromSupportDisks[globalRun["LastSupportDiskNumbers"],nextR];
res
];


disksInSupportChain[chain_,nextR_] :=
addLeftRightSupporters[DeleteDuplicates[chain],nextR]; 

addLeftRightSupporters[sDisks_,nextR_] := Module[{},
supportDisks=sDisks;
supportDisks= DeleteDuplicates[bareNumber/@ supportDisks];
supportDisks =Flatten[Map[leftRightCouldSupport[#,nextR]&,supportDisks]];
supportDisks
];

leftRightCouldSupport[node_,nextR_] := Module[{d,xy,res,nodeRadius},

res= {node};

d=getDisk[node];

xy=diskXZ[d];
nodeRadius=diskR[d];
If[xy[[1]]-1 >=-0.5-  (nextR+nodeRadius),res=Append[res,left[node]]];
If[xy[[1]]+1 <=   0.5+  (nextR+nodeRadius),res=Append[res,right[node]]];
res 
];


(* ::Input::Initialization:: *)
newSupportPairsFromSupportDisks[supportDisks_,nextR_] :=Module[{pairs,supportTable,extendedDisks,res,i,j},

pairs = Flatten[Table[{supportDisks[[i]],supportDisks[[j]]},{i,1,Length[supportDisks]},{j,i+1,Length[supportDisks]}],1];


newSupportDisks=supportDisks;
newSupportDisks = Map[#->getDiskFromRun[globalRun,#]&,newSupportDisks];
newPairs = Flatten[Table[{newSupportDisks[[i]],newSupportDisks[[j]]},{i,1,Length[newSupportDisks]},{j,i+1,Length[newSupportDisks]}],1];

newSupportTable = Map[newMakeSupportTableRow[#]&,newPairs];
newSupportTable = Select[newSupportTable,Abs[#GapSeparation]< 2* nextR&];
newSupportTable = Map[Append[#,"NextDisk"->newDiskOnThisPair[{#Disk1,#Disk2},nextR]]&,newSupportTable];
monitornewSupportTable = newSupportTable;
newSupportTable = Select[newSupportTable,!MissingQ[#NextDisk]&];
newSupportTable = Select[newSupportTable,isLeftRightSupported];
newSupportTable = Select[newSupportTable,diskIsNormalised[#NextDisk]&];

newdisksToCheckIntersection=Association[newSupportDisks];
(* the centre of the new disk must be above the line trhrough the centres of the support *) 

supportLine =  SortBy[Values@Map[diskXZ,newdisksToCheckIntersection],First];
supportLineFunction = Interpolation[supportLine,InterpolationOrder->1];
diskAboveSupportLineQ[disk_]:= diskZ[disk] > supportLineFunction[diskX[disk]];

newSupportTable = Select[newSupportTable,diskAboveSupportLineQ[#NextDisk]&];


newSupportTable= Map[newsupportTableFindIntersections[#,nextR,newdisksToCheckIntersection]&,newSupportTable];
newSupportTable= Select[newSupportTable,Length[#Intersection]==0&];

newSupportTable
];

isLeftRightSupported[row_] := Module[{x1,x2,xDisk,z1,z2,zDisk},
x1=diskX[row["Disk1"]];
x2 = diskX[row["Disk2"]];
xDisk = diskX[row["NextDisk"]];
z1=diskZ[row["Disk1"]];
z2 = diskZ[row["Disk2"]];
zDisk = diskZ[row["NextDisk"]];

IntervalMemberQ[Interval[{x1,x2}],xDisk] && (zDisk > z1 || zDisk > z2)
];


newMakeSupportTableRow[{node1_->d1_,node2_->d2_}] := Module[{res,hDiff,eSep},
hDiff= diskX[d2]-diskX[d1];

If[hDiff> 0,
eSep= diskLeftX[d2]-diskRightX[d1] 
,
eSep = diskLeftX[d1]-diskRightX[d2] 
];
eSep = If[eSep>0,eSep,0];
<|"Disk1"->d1,"Disk2"->d2,"NextDiskRestsOn"->{node1,node2}, "GapSeparation"->eSep|>
]

newsupportTableFindIntersections[row_,nextR_,disks_] := Module[{res,extendedDisks,locationIntersectsQ,intersections},
intersections= Map[diskdiskIntersectionQ[row["NextDisk"],#]&,KeyDrop[disks,row["NextDiskRestsOn"]]];
intersections= Keys@Select[ intersections,TrueQ];
Append[row,"Intersection"->intersections]
];


newDiskOnThisPair[{d1_,d2_},r_] := Module[{res},
res = diskdiskUpperTouchingPoint[{d1,d2},r];
If[MissingQ[res],Return[res]]; (* no overlap *) 
Disk[res,r]
];

diskdiskIntersectionQ[Disk[xy1_,r1_],Disk[xy2_,r2_]]:= Norm[xy1-xy2,2] < (r1+ r2);




(* ::Input::Initialization:: *)
updateContactGraph[n_,disk_,{n1_,n2_}] := updateContactGraph[n,{n1,n2}]


updateContactGraph[n_,{n1_,n2_}] := Module[{g,d,d1,d2,d1Left},
g = globalRun["ContactGraph"];
g=  VertexAdd[g,n];

If[!bareNumberQ[n1],
 g= VertexAdd[g,n1]];
If[!bareNumberQ[n2],
 g= VertexAdd[g,n2]];
g= EdgeAdd[g,
{n \[UndirectedEdge] n1,n \[UndirectedEdge] n2 }];

globalRun["ContactGraph"]=g;

];




(* ::Input::Initialization:: *)
(*  *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= newdiskdiskTouchingPoint[pairDisks,r];

If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];



(* ::Input::Initialization:: *)


newdiskdiskTouchingPoint[diskPair_,r_] := Module[{c1,c2,r1,r2,interdisk,interdiskVectorNorm,interdiskNormal,
angle,vector,normal,interdiskVector},
{c1,c2}= Map[diskXZ,diskPair];
{r1,r2}= Map[diskR,diskPair];
interdiskVector = c2-c1;
interdisk = Norm[interdiskVector];
interdiskVectorNorm = interdiskVector/Norm[interdiskVector];
interdiskNormal =  {-interdiskVectorNorm[[2]],interdiskVectorNorm[[1]]};


angle = sssTriangleInteriorAngle[r2+r,r+r1,interdisk];
If[MissingQ[angle],Return[angle]];
vector=(r1+r)*Cos[angle]*interdiskVectorNorm;
normal = (r1+r)*Sin[angle]* interdiskNormal;
{c1+vector+normal,c1+vector-normal}

]
sssTriangleInteriorAngle[a_,b_,c_] := Module[{tri,angle},
tri =SSSTriangle[a,b,c];
If[Head[tri]==SSSTriangle,
Return[Missing["Not a triangle"]]];
angle = TriangleMeasurement[tri,{"InteriorAngle",1}];
angle
];



(* ::Input::Initialization:: *)

postRun[run_] := Module[{res,chains,nrchains},
res = pretty[run];
edgeCheck[res];
res= postRunNodeStatistics[res];
res
];
pretty[run_] := Module[{g,setGraphXY,res,vc,es},
g=run["ContactGraph"];
vc = Map[getDiskXZ[run,#]&,VertexList[g]];
g = Graph[g,VertexCoordinates->vc];
es = Map[#->edgeStyle[run,#]&,EdgeList[g]];
g= Graph[g,EdgeStyle->es];
g=Graph[g,VertexLabels->None];
g=Graph[g,VertexSize->Tiny];

res=run;
res["ContactGraph"]=g;
res
];
edgeStyle[run_,upper_ \[UndirectedEdge] lower_] := Module[{vxy},
vxy=vectorXZ[run,upper\[UndirectedEdge] lower];
If[First[vxy]>= 0,Blue,Red]
]
edgeStyle[upper_ \[DirectedEdge] lower_] := edgeStyle[upper \[UndirectedEdge] lower];


(* ::Input::Initialization:: *)


 edgeCheck[run_] := Module[{g,res,edgeStyler,res2,nodesToCheck},
g=run["ContactGraph"];
res=Map[lowerEdges[g,#]&,Complement[Select[VertexList[g],bareNumberQ],{1}]];
If[Or@@ Map[Length[#]!=2&,res],"Print some nodes without two supports"];

edgeStyler[edgeList_] := Map[edgeStyle,edgeList];
nodesToCheck = Complement[Select[VertexList[g],bareNumberQ],{1,2,3,4,0,left[1],5,6,7}];
res2= Map[lowerEdges[g,#]&,nodesToCheck];
res2 =Association@Map[#->Sort@edgeStyler[#]&,res2];
res2= Select[res2,# != {RGBColor[0, 0, 1],RGBColor[1, 0, 0]}&];

If[Length[res2]>0,
Print["Print  lopsided nodes", res2];
];

];

edgeCheckNode[n_] := Module[{g,res,edgeStyler,res2},
If[bareNumber[n]===1,Return[True]];
g=globalRun["ContactGraph"];
le = lowerEdges[g,n];
If[Length[le]!=2,Print["Node ", n, " without two supports"]];
If[Sort[Map[edgeStyle,Keys[le]]]!= {RGBColor[0, 0, 1],RGBColor[1, 0, 0]},
Print["Node ", n, " is lopsided"]];


];

lowerEdges[g_,n_] := Module[{nxy,edges,nodes},
nxy=AnnotationValue[{g,n},VertexCoordinates];
edges= EdgeList[g,n \[UndirectedEdge]_];
nodes= Complement[Flatten[List@@@edges],{n}];
nodes= Association@Map[(n \[DirectedEdge] #)-> Last[AnnotationValue[{g,#},VertexCoordinates]]-Last[nxy]&,nodes];
nodes = Select[nodes,#<=0&];
Keys[nodes]
];


(* ::Input::Initialization:: *)
(*
reColour[run_] := Module[{g,chains,v,e},
chains=Map[#Chain&,run["Chains"]];
vList[gr_] := Map[#->AnnotationValue[{gr,#},VertexCoordinates]&,VertexList[gr]];v=vList[run["ContactGraph"]];

eList[gr_] := Map[#->AnnotationValue[{gr,#},EdgeStyle]&,EdgeList[gr]];

chainEdges=Association@Flatten@Map[eList,Values@chains];
grayChains= Association@Map[#->Gray&,EdgeList[run["ContactGraph"]]];
chainEdges=Join[grayChains,chainEdges];
Graph[Keys[v],Keys[chainEdges],
VertexCoordinates->Values[v],
EdgeStyle->KeyValueMap[#1->#2&,chainEdges]]
];*)


(* ::Input::Initialization:: *)

edgeDirectedRightwards[g_,v1_ \[UndirectedEdge] v2_] := Module[{v1xy,v2xy},
v1xy=AnnotationValue[{g,v1},VertexCoordinates];
v2xy=AnnotationValue[{g,v2},VertexCoordinates];
If[First[v1xy]<First[v2xy],
v1\[DirectedEdge] v2,v2\[DirectedEdge] v1]
];

directedGraphRightwards[g_] := Module[{v,vxy,edges,d},
v=VertexList[g];
vxy=Map[#->AnnotationValue[{g,#},VertexCoordinates]&,v];
edges =EdgeList[g];
edges= Map[edgeDirectedRightwards[g,#]&,edges];
d=Graph[v,edges,VertexCoordinates->vxy,VertexSize->Tiny,VertexLabels->"Name"
,EdgeShapeFunction->{{"HalfFilledArrow","ArrowSize"->.05}}
];
d
];


(* ::Input::Initialization:: *)
leftRightChainEdges[d_] := Module[{nonbares,nonbarePaths,nonbarePath,pathToDE,pathscore,chains},
nonbares=Select[VertexList[d],!bareNumberQ[#]&];
nonbarePaths[left[node_]] :=  FindPath[d,left[node],node,\[Infinity],All];
nonbarePaths[right[node_]] :=  FindPath[d,node,right[node],\[Infinity],All];
pathscore[path_] := Module[{z},
z= Map[Last@AnnotationValue[{d,#},VertexCoordinates]&,path];
z= z- Mean[z];
z= Map[Abs,z];
z= Total[z];
z
];
nonbarePath[node_] :=  First@SortBy[nonbarePaths[node],pathscore];

pathToDE[path_] := (monitorTopChainCount=path;Map[Apply[UndirectedEdge,#]&,Partition[path,2,1]]);
chains=Association@Map[bareNumber[#]->pathToDE[nonbarePath[#]]&,nonbares];
chains
];
(*
pickShortest[edgeList_] := First@SortBy[edgeList,#Xdifference&];

*)





(* ::Input::Initialization:: *)
countbyPath[chain_] := Module[{res},
res=Counts[classifyPath[chain]];
res= Append[<|RGBColor[0, 0, 1]->0,RGBColor[1, 0, 0]->0|>,res];
res=KeySort[res];
res
]; 
classifyPath[chain_] := Map[classifyPathEdge[chain,#]&,EdgeList[chain]];
classifyPathEdge[g_,v1_\[UndirectedEdge] v2_] := Module[{v1xy,v2xy},
v1xy=AnnotationValue[{g,v1},VertexCoordinates];
v2xy=AnnotationValue[{g,v2},VertexCoordinates];
{v1xy,v2xy}= SortBy[{v1xy,v2xy},First];
If[ Last[v1xy]>=Last[v2xy],Red,Blue]
];


chainFromEdges[chainEdges_]:= Union@@(List@@@chainEdges)

flattestChains[g_] := Module[{d,chainEdges,chains},
d=directedGraphRightwards[g];
chainEdges= leftRightChainEdges[d];
chains= Map[<|"Chain"->Subgraph[g,#]|>&,chainEdges];
chains = Map[Append[#,"Parastichy"->countbyPath[#Chain]]&,chains];
chains
]


(* ::Input::Initialization:: *)
postRunFlatChain[run_] := Module[{res,chains,nrchains},
res = run;
(* topdown uses the topChain code from the runtime, so looks up xy coords in the run["DiskData"]; flattestChainData relies on these having gone into the graph vertexcoordinates already, sigh *)
res= Append[res,"FlatChains"->flattestChainData[res["ContactGraph"]]];
res
];
postRunChain[run_] := Module[{res,chains,nrchains},
res = run;
(* topdown uses the topChain code from the runtime, so looks up xy coords in the run["DiskData"]; flattestChainData relies on these having gone into the graph vertexcoordinates already, sigh *)
res=Append[res,"Chains"->topdownChains[res,res["ContactGraph"]]];

res
];
postRunNodeStatistics[run_] := Module[{res,angles},
res = run;
angles= Map[<|"Angle"->#|>&,computeNodeLowerAngles[run]];
res= Append[res,"NodeStatistics"-> angles];
res 
];


(* ::Input::Initialization:: *)
flattestChainData[graph_,chainsToDo_:100] := Module[{i,g,chainGraphSet,chains},
chains= flattestChains[graph];

chainSet=chains /. DirectedEdge -> UndirectedEdge;
chainSet= Map[Append[#,"MeanZ"->chainMeanZ[#Chain]]&,chainSet];
chainSet= Map[Append[#,"MeanRadius"->chainMeanRadius[#Chain]]&,chainSet];
chainSet
];



chainMeanZ[chain_] := Last@Mean@Map[AnnotationValue[{chain,#},VertexCoordinates]&,Drop[VertexList[chain],-1]];

chainMeanRadius[chain_] := Module[{e,gxy},
gxy[n_] :=AnnotationValue[{chain,n},VertexCoordinates];
norm[n1_,n2_] := Norm[gxy[n2]-gxy[n1]];
e=EdgeList[chain];
e=norm @@@ e;
Mean[e]/2
];



(* ::Input::Initialization:: *)
topdownChains[run_,graph_,chainsToDo_:100] := Module[{i,g,chainGraphSet,chain,chainGraph},
g=Graph[graph,VertexLabels->"Name"];

chainGraphSet=List[];
For[i=0,i<chainsToDo,i++,
monitorTopDownChainCount=i;
chain=topChainInRun[run,g];
chainGraph=Subgraph[g,chain];
chainGraph= Graph[chainGraph,VertexLabels->"Name"];
chainGraphSet=Append[chainGraphSet, chainGraph];
g=stripChain[g,chain];

If[Length[VertexList[g]]==0,Break[]];
];monitorTopDownChainCount="Done";
chainSet=
Association@MapIndexed[First[#2]-><|"Chain"->#1|>&,Reverse[chainGraphSet]];
chainSet= Map[Append[#,"Parastichy"->chainParastichy[#Chain]]&,chainSet];
chainSet= Map[Append[#,"MeanZ"->chainMeanZ[#Chain]]&,chainSet];
chainSet= Map[Append[#,"MeanRadius"->chainMeanRadius[#Chain]]&,chainSet];
chainSet= Map[Append[#,"AngleMean"->chainMeanLatticeAngle[run,#Chain]]&,chainSet];
chainSet= Map[Append[#,"AngleSD"->chainSDLatticeAngle[run,#Chain]]&,chainSet];
chainSet
];

chainMeanLatticeAngle[run_,chain_] := Module[{res,v},
v=Select[VertexList[chain],bareNumberQ];
res= KeyTake[run["NodeStatistics"],v];
res= Map[#Angle&,res];
Mean[res]
];
chainSDLatticeAngle[run_,chain_] := Module[{res,v},
v=Select[VertexList[chain],bareNumberQ];
res= KeyTake[run["NodeStatistics"],v];
res= Map[#Angle&,res];
If[Length[res]<2,Return[Missing["monoEdge"]]];
StandardDeviation[res]
];

chainMeanZ[chain_] := Last@Mean@Map[AnnotationValue[{chain,#},VertexCoordinates]&,Drop[VertexList[chain],-1]];

chainMeanRadius[chain_] := Module[{e,gxy},
gxy[n_] :=AnnotationValue[{chain,n},VertexCoordinates];
norm[n1_,n2_] := Norm[gxy[n2]-gxy[n1]];
e=EdgeList[chain];
e=norm @@@ e;
Mean[e]/2
];



(* ::Input::Initialization:: *)
stripChain[g_,chain_]:= Module[{lrchain},
lrchain =leftAndRightNumbers[DeleteDuplicates[bareNumber/@chain]];

lrchain= Intersection[lrchain,VertexList[g]];
VertexDelete[g,lrchain]
];

chainEncircles[chain_] := Module[{lrNode},
lrNode=Select[VertexList[chain],!bareNumberQ[#]&];
If[Length[lrNode]!=1,Return[False]];
MemberQ[VertexList[chain],bareNumber[First[lrNode]]]
];

chainParastichy[chain_]:=Module[{},
If[!chainEncircles[chain],Return[Missing["Not encircling"]]];
If[AcyclicGraphQ[chain],
acyclicChainParastichy[chain]
,cyclicChainParastichy[chain]
]
];

cyclicChainParastichy[chain_] := Module[{reducedchain,v,first,last,edges,res},


v=VertexList[chain];
v=SortBy[v,AnnotationValue[{chain,#},VertexCoordinates]&];
first=First[v];last=Last[v];


edges= Flatten[FindCycle[chain,Infinity,All],2];
vInLoops=Complement[DeleteDuplicates[Flatten[List@@@edges]],{first,last}];
vInLoops=Association@Map[#->EdgeCount[chain,# \[UndirectedEdge] _]&,vInLoops];
vInLoops =Keys[Select[vInLoops,#==2 &]];
reducedchain = VertexDelete[chain,vInLoops];

If[AcyclicGraphQ[reducedchain],
Return[acyclicChainParastichy[reducedchain]]];



edges= Flatten[FindCycle[reducedchain,Infinity,All],2];
res=Association@Map[#->EdgeDelete[reducedchain,#]&,edges];
res=Select[res,gIsLinear];
res=Select[res,gIsChain];
If[Length[res]==0,
Return[Missing["Can't decyclic"]]];
(*If[Length[res]>1,w=res;Print["Multi decyclics",chain,res]];
*)res=First[res];
If[!AcyclicGraphQ[res],
Print["Can't declyce",chain];Return[Missing[]]];
acyclicChainParastichy[res]
];

gIsLinear[g_] := Module[{res},
res=Map[EdgeCount[g,#\[UndirectedEdge] _]&,VertexList[g]];
And@@Map[#<=2&,res]
];
gIsChain[g_] := Module[{v,first,last,graph},
v=VertexList[g];
v=SortBy[v,AnnotationValue[{g,#},VertexCoordinates]&];
first=First[v];last=Last[v];
graph=VertexDelete[g,{first,last}];
ConnectedGraphQ[graph]
];


acyclicChainParastichy[chain_]:=Module[{res},
If[!AcyclicGraphQ[chain],Print["aCP"];Abort[]];
res=KeySort@Counts[Map[AnnotationValue[{chain,#},EdgeStyle]&,EdgeList[chain]]
];
res = Append[<|RGBColor[0, 0, 1]->0,RGBColor[1, 0, 0]->0|>,res];
res
];



(* ::Input::Initialization:: *)
computeNodeLowerAngles[run_] := Module[{v,edges,edgePairAngle},
v=Select[VertexList[run["ContactGraph"]],bareNumberQ];
edges=Select[Association@Map[#->lowerEdges[run["ContactGraph"], #]&,v],Length[#]==2&];
edges= Association@KeyValueMap[#1->Values@KeyTake[vectorsFromNode[run,run["ContactGraph"],#1],#2]&,edges];
edgePairAngle[{e1_,e2_}] := ArcCos[(e1 . e2)/(Norm[e1]*Norm[e2])];
edges= Map[edgePairAngle,edges];
edges
]
