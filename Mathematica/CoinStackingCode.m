(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;
diskTopZ[Disk[{_,z_},r_]] := z+r;
diskR[Disk[{_,_},r_]] := r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;
leftAndRightNumbers[n_List] := Join@@{n,moveNumberRight/@n,moveNumberLeft/@n};
bareNumber[left[n_]]  := n;
bareNumber[right[n_]] := n;
bareNumber[n_] := n;
bareNumberQ[n_] := n==bareNumber[n];

moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];
moveNumberedDiskLeft[n_->d_] := moveNumberLeft[n]->moveDiskLeft[d];


getDisk[n_] := Module[{res},
res= globalRun["CurrentDisks"][n];
If[MissingQ[res],
res= globalRun["PastDisks"][n]];
res
];
getDisk[right[n_]] := moveDiskRight[getDisk[n]];
getDisk[left[n_]] := moveDiskLeft[getDisk[n]];

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);

diskAndVisibleCopies[Disk[{x_,z_},r_]] := {Disk[{x,z},r],If[x+r>1/2,moveDiskLeft[Disk[{x,z},r]],Nothing[]],If[x-r<-1/2,moveDiskRight[Disk[{x,z},r]],Nothing[]]};

disksMaximum[] := 
Max@Map[diskTopZ,globalRun["CurrentDisks"]];

highestDiskZ[run_] := Max@Map[diskZ,Values@run["CurrentDisks"]];
smallestRadius[run_] := Min@Map[diskR,Values@run["CurrentDisks"]];
(* used in RunCoinStacking as well for setup, so don't use the global *)

nextRadius[] := Module[{highestZ},
highestZ=highestDiskZ[globalRun];
globalRun["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[] := Max@Keys[globalRun["CurrentDisks"]]+1;nextChainNumber[]:= Max[Keys[globalRun["CompletedChainGraphs"]]]+1;


(* ::Input::Initialization:: *)
extendDisksRight[nextR_] := Module[
{extendedDisksRight},
extendedDisksRight = 
Select[globalRun["CurrentDisks"],diskLeftX[#]+1     <= 1/2 +nextR&];
extendedDisksRight = Association[Map[moveNumberedDiskRight,Normal[extendedDisksRight]]];
extendedDisksRight

];
extendDisksLeft[nextR_] := Module[
{extendedDisksLeft},
extendedDisksLeft = Select[globalRun["CurrentDisks"],diskRightX[#]-1 + nextR >=- 1/2 &];
extendedDisksLeft = Association[Map[moveNumberedDiskLeft,Normal[extendedDisksLeft]]];

extendedDisksLeft

];
extendDisksLeftRight[nextR_]:= Module[{extendedDisks},
extendedDisks = 
Append[globalRun["CurrentDisks"], extendDisksRight[nextR]];
extendedDisks = 
Append[extendedDisks, extendDisksLeft[nextR]];
extendedDisks 
];



(* ::Input::Initialization:: *)

executeRun[run_,chainMax_:Missing[]] := Module[{i,imax,res,timing},
Off[SSSTriangle::tri];

globalRun=run;
globalUsedPairs= Association[];
globalSupportPairs= {};

If[!MissingQ[chainMax],
globalRun["Arena"]["ChainMax"]=chainMax];
imax = globalRun["Arena"]["ChainMax"];
If[!NumericQ[imax],imax=500];
Monitor[
For[i=1,i<= imax,i++,
If[runCompletesArena[],Break[]];
timing = First@Timing[addNextDisk[]];
];
,
StringTemplate[" Z `Z`; per-chain time `timing`"][<|"chain"->nextChainNumber[]-1
,"disk"-> nextDiskNumber[]-1
,"Z"-> highestDiskZ[]
,"parastichy"->  Last[globalRun["Parastichy"]]
,"timing"->timing
,"disktime"-> globalRun["CurrentTimePerDisk"]|>]
];
globalRun
];



(* ::Input::Initialization:: *)

runCompletesArena[] := Module[{},
If[globalRun["Arena"]["ChainMax"]!="Fill",Print["Set chainmax"];Abort[]];

disksMaximum[]>globalRun["Arena"]["CylinderLU"][[2]]+ 2 * globalRun["Arena"]["rFunction"][globalRun["Arena"]["CylinderLU"][[2]]];
];




(* ::Input::Initialization:: *)
addNextDisk[]:=Module[{nextR,path,n,g,timing},
nextR=nextRadius[];
row=findNextDiskFromSupportSet[nextR];
globalRun["NextDisk"]= row["NextDisk"];
globalRun["NextDiskRestsOn"]= row["NextDiskRestsOn"];
n=nextDiskNumber[];
globalUsedPairs=Append[globalUsedPairs,globalRun["NextDiskRestsOn"]->n];

globalRun["CurrentTimePerDisk"]=timing;globalRun["CurrentDisks"]=Append[globalRun["CurrentDisks"],n->globalRun["NextDisk"]];(*globalRun["CurrentChain"]=Append[globalRun["CurrentChain"],n];globalRun["CurrentChain"]=SortBy[globalRun["CurrentChain"],diskX[getDisk[#1]]&];*)globalRun["ContactGraph"]=updateContactGraph[n];
(*globalRun["CurrentChainGraph"]=Subgraph[globalRun["ContactGraph"],leftAndRightNumbers[globalRun["CurrentChain"]]];
*)]


(* ::Input::Initialization:: *)
findNextDiskFromSupportSet[nextR_]:= Module[{supportTable,res},
globalSupportPairs=supportPairsFromTopChain[nextR];
supportTable= Select[globalSupportPairs,!#SelfIntersecting&];
supportTable= SortBy[supportTable,diskZ[#NextDisk]&];
If[Length[supportTable]==0,Print["No valid supports"];Abort[]];
res=First[supportTable];
res
];


(* ::Input::Initialization:: *)





(* ::Input::Initialization:: *)
topChain[graph_] := Module[{g,chain,graphXY,neighbours,highestNode,lastNode,nextNode},

g=graph;
If[VertexList[g]=={left[1],1,2,right[1]},Return[{2,1,left[1],2}]]; (* megabodge *)
If[VertexList[g]=={left[1],1,right[1]},Return[{1,right[1],left[1]}]]; (* megabodge *)
If[VertexList[g]=={1,right[1]},Return[{1,right[1]}]]; (* megabodge *)
If[VertexList[g]=={left[1],1},Return[{1,left[1],right[1]}]]; (* megabodge *)

graphXY[n_] := AnnotationValue[{g,n},VertexCoordinates];

neighbours[n_] :=  Complement[VertexList[Graph[EdgeList[g,n\[UndirectedEdge]_]]],{n}];
highestNode=Last[SortBy[Select[VertexList[g],bareNumberQ],Last[graphXY[#]]&]];
chain= {highestNode};
nextRight[n_] := Module[{res,vectors,rightVectors},
vectors =Association@Map[#->vectorXY[n,#]&,neighbours[n]];
rightVectors=Select[vectors,First[#]>=0&];
If[Length[rightVectors]>0,
(* usually *)
rightVectors= SortBy[rightVectors,-Last[#]&];
res=First[Keys[rightVectors]]
, (* otherwise go backwards and hence sort other direction *)
vectors= SortBy[vectors,Last[#]&];
If[Length[vectors]>0,
res=First[Keys[vectors]],
res=Missing["No edges from node"]
]
];
res
];
For[i=1,i<10,i++,
lastNode=Last[chain];
nextNode =nextRight[lastNode];
If[MissingQ[nextNode], (* _should only happen for 1 left[1] *)
Break[]];
chain=Append[chain,nextNode];
g=EdgeDelete[g,lastNode\[UndirectedEdge]nextNode]; (* could move up into backwards branch *);
If[MatchQ[Last[chain],right[_]],
chain=Append[chain,moveNumberLeft[Last[chain]]]];
If[MemberQ[VertexList[g],left[Last[chain]]],chain=Append[chain,left[Last[chain]]]];
If[Last[chain]==First[chain],Break[];]
];
chain
];




(* ::Input::Initialization:: *)


supportPairsFromTopChain[nextR_] :=Module[{pairs,supportDisks,supportTable,extendedDisks,res},

supportDisks=topChain[globalRun["ContactGraph"]];
supportDisks= DeleteDuplicates[bareNumber/@ supportDisks];
supportDisks = Flatten[Map[leftRightCouldSupport[#,nextR]&,supportDisks]];

pairs = Flatten[Table[{supportDisks[[i]],supportDisks[[j]]},{i,1,Length[supportDisks]},{j,1,Length[supportDisks]}],1];
pairs = DeleteCases[pairs,{left[_],left[_]}|{right[_],right[_]}|{left[_],right[_]} ];

usedPairs= Keys[globalUsedPairs];
usedPairs = Union[usedPairs,Map[moveNumberLeft,usedPairs,{2}],Map[moveNumberRight,usedPairs,{2}]];
pairs=Complement[pairs,usedPairs];

supportTable = Association@Map[makeSupportTableRow[#]&,pairs];
(* assumes r nonincreasing *)
supportTable= filterForNonIncreasingR[nextR,supportTable];
supportTable=  calculateSupportTableSelfIntersecting[supportTable,nextR];
supportTable
];


leftRightCouldSupport[node_,nextR_] := Module[{xy,res},
graphXY[n_] := AnnotationValue[{globalRun["ContactGraph"],n},VertexCoordinates];

res= {node};
xy = graphXY[node];
If[xy[[1]]-1 >=-0.5-  2* nextR,res=Append[res,left[node]]];
If[xy[[1]]+1 <=   0.5+  2* nextR,res=Append[res,right[node]]];
res 
];


makeSupportTableRow[{node1_,node2_}] := Module[{res,hDiff},
hDiff= diskX[getDisk[node2]]-diskX[getDisk[node1]];
If[hDiff<= 0,Return[Nothing[]]];
res=<|"NextDiskRestsOn"->{node1,node2}
, "EdgeSeparation"->diskLeftX[getDisk[node2]]-diskRightX[getDisk[node1]] 
,"Used"->Missing[]|>;

{node1,node2}->res
]
filterForNonIncreasingR[nextR_,supportTable_] := Module[{res},
res = Select[supportTable,Abs[#EdgeSeparation]< 2* nextR&];
res = Map[Append[#,"NextDisk"->diskOnThisPair[#NextDiskRestsOn,nextR]]&,res];
res = Select[res,diskIsNormalised[#NextDisk]&];
res
];



calculateSupportTableSelfIntersecting[sTable_,nextR_] :=Module[{res,extendedDisks,locationIntersectsQ},
supportTable=sTable;
extendedDisks = extendDisksLeftRight[ nextR];
locationIntersectsQ[d_] := 
 Or@@Map[diskdiskIntersectionQ[d,#]&,extendedDisks];
supportTable= Map[Append[#,"SelfIntersecting"->locationIntersectsQ[#NextDisk]]&,supportTable];
supportTable
];

diskOnThisPair[{n1_,n2_},r_] := Module[{res,d1,d2,xl,xr,xres},
d1 = getDisk[n1];
d2 = getDisk[n2];
res = diskdiskUpperTouchingPoint[{d1,d2},r];
If[MissingQ[res],Return[res]]; (* no overlap *) 
Disk[res,r]
];
diskdiskIntersectionQ[Disk[xy1_,r1_],Disk[xy2_,r2_]]:= Norm[xy1-xy2,2] < (r1+ r2);




(* ::Input::Initialization:: *)
updateContactGraph[n_] := Module[{g,n1,n2,d,d1,d2,d1Left},
g = globalRun["ContactGraph"];
{n1,n2}= globalRun["NextDiskRestsOn"];


{d,d1,d2} = {getDisk[n],getDisk[n1],getDisk[n2]};
g = vertexAddWithCoordinates[g,n,diskXZ[d]];
g = vertexAddWithCoordinates[g,n1,diskXZ[d1]];(* surely not needed *)
g = vertexAddWithCoordinates[g,n2,diskXZ[d2]];
g= EdgeAdd[g,
{n1 \[UndirectedEdge] n,n \[UndirectedEdge] n2 }];
g = Graph[g,AnnotationRules->{n1 \[UndirectedEdge] n->{EdgeStyle-> Red},
n \[UndirectedEdge] n2 ->{ EdgeStyle->Blue}}];

g
];


(* ::Input::Initialization:: *)
vertexAddWithCoordinates[g_,v_,vxy_] := Module[{vc,res},
If[MemberQ[VertexList[g],v],Return[g]];
res = VertexAdd[g,v];
vc = AnnotationValue[g,VertexCoordinates];
vc = Append[vc,vxy];
res = Annotate[res,VertexCoordinates->vc];
res
]



(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= newdiskdiskTouchingPoint[pairDisks,r];

If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];



(* ::Input::Initialization:: *)


newdiskdiskTouchingPoint[diskPair_,r_] := Module[{c1,c2,r1,r2,interdisk,interdiskVectorNorm,interdiskNormal,
angle,vector,normal,interdiskVector},
{c1,c2}= Map[diskXZ,diskPair];
{r1,r2}= Map[diskR,diskPair];
interdiskVector = c2-c1;
interdisk = Norm[interdiskVector];
interdiskVectorNorm = interdiskVector/Norm[interdiskVector];
interdiskNormal =  {-interdiskVectorNorm[[2]],interdiskVectorNorm[[1]]};


angle = sssTriangleInteriorAngle[r2+r,r+r1,interdisk];
vector=(r1+r)*Cos[angle]*interdiskVectorNorm;
normal = (r1+r)*Sin[angle]* interdiskNormal;
{c1+vector+normal,c1+vector-normal}

]
sssTriangleInteriorAngle[a_,b_,c_] := Module[{tri,angle},
tri =SSSTriangle[a,b,c];
If[Head[tri]==SSSTriangle,
Return[Missing["Not a triangle"]]];
angle = TriangleMeasurement[tri,{"InteriorAngle",1}];
angle
];



(* ::Input::Initialization:: *)
tryToCompleteCurrentChain[] := Module[{res,nodeList,lrNodes,lrCases,lrPaths},

globalRun["CurrentChainNodePath"]=Missing["No chain"];

nodeList = VertexList@globalRun["CurrentChainGraph"];
lrNodes = Cases[nodeList,left[_] | right[_]];
lrCases = Association@Map[#->MemberQ[nodeList,bareNumber[#]]&,lrNodes];
lrCases = Select[lrCases,TrueQ];

If[Length[lrCases]==0,Return[]];
lrPaths = Association@Map[#->lrNodePath[#,globalRun["CurrentChainGraph"]]&,Keys@lrCases];
lrPaths = Select[lrPaths,Length[#]>0&];

If[Length[lrPaths]==0,Return[]];
If[Length[lrPaths]>1,
Print["Multiple paths"];
Print[lrPaths];
Print[globalRun["CurrentChainGraph"]]
];

globalRun["CurrentChainNodePath"]= First@First[lrPaths];
];

lrNodePath[lrNode_,g_] := FindPath[g,lrNode,bareNumber[lrNode]]


(* ::Input::Initialization:: *)
setUpNewChain[] := Module[{chainNumber,completedChainGraph},


completedChainGraph = globalRun["CurrentChainGraph"];
chainNumber = nextChainNumber[];
globalRun["CompletedChainGraphs"]= Append[globalRun["CompletedChainGraphs"],
chainNumber->completedChainGraph];
globalRun["CompletedChainNodePaths"]= Append[globalRun["CompletedChainNodePaths"],
chainNumber->globalRun["CurrentChainNodePath"]];

globalRun["PastDisks"]= Append[globalRun["PastDisks"],globalRun["CurrentDisks"]];


globalRun["CurrentDisks"]= KeyTake[
globalRun["CurrentDisks"],globalRun["CurrentChain"]];

globalRun["CurrentChain"] = {};
globalRun["CurrentOverlaps"] = {};
globalRun["UsedOverlaps"]= {};


globalRun["CurrentChainGraph"] = Graph[{}];

]
