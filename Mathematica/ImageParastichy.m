(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



makePackage = False;
If[makePackage,
    BeginPackage["ImageParastichy`"];
    locateParastichyOptions::usage = "Global options for heuristics";
    makeTidyMesh::usage = "Delete duplicate points and remove over-large cells";
    meshExtendParastichy::usage = "Extend a line without large kinks"
];

If[makePackage,
    Begin["`Private`"]
];
  
(*Options[EvaluationNotebook[],AutoGeneratedPackage\[Rule]Automatic];
*)



resetOptions := locateParastichyOptions = <|
"Renumber"-> True,
"DuplicateNearness" ->5.1,
"LargePolygonLength" ->42,
"InitialPeel" -> 0,
"StraightnessWhenAdjacent" ->25,
"StraightnessWhenUnadjacent"-> 30,
"InitialParastichyLength"->  10,
"ParastichyExtensionLength"->  10, (* each way *)
"MinimumThreadLength"-> 3,
"FamilyGrowthSize" -> 90
|>; 
resetOptions;

	
makeSunGraph[seedCentres_] :=
	Module[{g,dMeshRaw, lineLength, lengths, pointsToDrop, x, meshxy, toDrop, dMesh, res, boundary},
		dMeshRaw = DelaunayMesh[seedCentres];
	
	lengths = AssociationThread[MeshCells[dMeshRaw, 1], Map[lineToLength, MeshPrimitives[dMeshRaw, 1]]];
	(* find the short line pairs and take the first cell index *) 
	pointsToDrop =
	(
	Keys @ Select[lengths, # < locateParastichyOptions["DuplicateNearness"]&] /. Line[{x_, y_}] -> x
	);
	toDrop = Map[First @ Position[seedCentres, meshCoordinates[dMeshRaw,#]]&, pointsToDrop];
	(* should be in point order anyway *)
	Print["Dropping ", Length[toDrop], " points as duplicates"];
	dMesh = DelaunayMesh[Delete[seedCentres, toDrop]];
	dMesh = meshDeletePolygons[dMesh, meshLongCells[dMesh, locateParastichyOptions["LargePolygonLength"]]];
	dMesh = meshPeel[dMesh, locateParastichyOptions["InitialPeel"]];
	boundary = SortBy[ConnectedMeshComponents @ RegionBoundary[dMesh], Length[MeshCells[#, 0]&]];
	
	g = meshToGraph[dMesh];
	
	res = <|
			"Graph" -> g
			, "InnerBoundary" -> meshCellsOfMesh1InMesh2[boundary[[1]], dMesh]
			, "OuterBoundary" -> meshCellsOfMesh1InMesh2[boundary[[2]], dMesh]
	(*		, "Adjacency" -> meshAdjacencyAssociation[dMesh]
*)			, "Centroid" -> RegionCentroid[dMesh]
		|>;
		res
	];	



(* private functions *)


lineToLength[Line[{p1_, p2_}]] := Norm[p1 - p2];


(* ::Input::Initialization:: *)
meshCoordinates[mesh_MeshRegion,ix_] := Block[{x},MeshPrimitives[mesh, {0, ix}] /. Point[x_] -> x];
meshCoordinates[mesh_] := Block[{x},MeshPrimitives[mesh, 0] /. Point[x_] -> x];
meshCellCellDistance[mesh_,{v1_,v2_}] := Norm[meshCoordinates[mesh,v1]-meshCoordinates[mesh,v2]];

meshDeletePolygons[mesh_,deletedpolys_] :=   
	MeshRegion[meshCoordinates[mesh],Complement[ MeshCells[mesh,2],deletedpolys]];

meshLinesWithLength[mesh_MeshRegion] := AssociationThread[MeshCells[mesh,1],Map[lineToLength,MeshPrimitives[mesh,1]]];
meshLinesWithLength[mesh_Association] := meshLinesWithLength[mesh["Mesh"]];

(* for tidying the initial mesh *)

meshLongCells::usage = "Find cells in which one of the sides has length> length ";
meshLongCells[mesh_,length_] := Module[{polys,x,lengths,polyMembers,longLinePairs,polyHasLinePair,polyHasAnyPairs},
	longLinePairs = Keys@Select[meshLinesWithLength[mesh], # > length&] /. Line[x_]->x;
	polys = MeshCells[mesh,2];
	polyMembers  =AssociationThread[polys,polys/. Polygon[x_]->x];
	polyHasLinePair[Polygon[x_],pair_] := Length[Intersection[x,pair]]>= 2;
	polyHasAnyPairs[p_] :=Or@@Map[polyHasLinePair[p,#]&,longLinePairs];
	Keys@Select[Association@Map[#->polyHasAnyPairs[#]&,polys],#&]
];

(* peel the outer boundary of cells off n times *)
meshPeel[mesh_,n_] := Module[{doapeel},
	doapeel[meshp_] := MeshRegion[MeshPrimitives[meshp,0]/. Point[x_]->x,meshPolygonsNotFormingBoundary[meshp]];
	Nest[doapeel,mesh,n]
];
meshPolygonsNotFormingBoundary[mesh_] := Module[{boundaryNodes,meshPolygons,polyFormsBoundary},
	boundaryNodes = boundaryPointIndexes[mesh];
	meshPolygons = MeshCells[mesh,2];
	polyFormsBoundary[Polygon[threeNodeList_]] := Length[Intersection[threeNodeList,boundaryNodes]]>= 2;
	Select[meshPolygons,Not @* polyFormsBoundary]
];

boundaryPointIndexes[mesh_] := Module[{boundaryNodesXY,meshXY},
(* replace by cellsOfMesh1InMesh2[RegionBoundary[mesh], mesh] just for clarity *)
	boundaryNodesXY = MeshPrimitives[RegionBoundary[mesh],0];
	meshXY = MeshPrimitives[mesh,0];
	Map[First@FirstPosition[meshXY,#]&,boundaryNodesXY]
];

meshCellsOfMesh1InMesh2[mesh1_, mesh2_] :=
	Module[{pointxy},
		pointxy = MeshPrimitives[mesh1, 0];
		Flatten @ Map[FirstPosition[MeshPrimitives[mesh2, 0], #]&, pointxy]
	];

meshAdjacencyAssociation[mesh_] := Module[{paraPossibles},
	paraPossibles =  Flatten[Apply[List,MeshCells[mesh,1],{1}],1];
	paraPossibles = DeleteDuplicates@Join[paraPossibles,Map[Reverse,paraPossibles]];
	GroupBy[paraPossibles,First,Map[Last,#]&]
];

(*
meshLineAngle[meshAssociation_, {ix1_, ix2_}] := Module[{p1p2, pAngle, res},
   (* in [-180,180 *)
   p1p2 = MeshPrimitives[meshAssociation["Mesh"], {0, {ix1, ix2}}];
   pAngle[{Point[{x1_, y1_}], Point[{x2_, y2_}]}] := (360/(2 \[Pi])) ArcTan[x2 - x1, y2 - y1];
   pAngle[p1p2]
   ];
*)

meshCellCellDistance[mesh_,{v1_,v2_}] := Norm[meshCoordinates[mesh,v1]-meshCoordinates[mesh,v2]];

meshToGraph[mesh_MeshRegion] := Module[{g,vertexList,edgeList,edgeWeights},vertexList = Block[{x},MeshCells[mesh,0] /. Point[x_]->x];
edgeList  = Block[{v1,v2},MeshCells[mesh,1] /. Line[ {v1_,v2_}]-> UndirectedEdge[v1,v2]];
edgeWeights = MeshCells[mesh,1] /. Line[ {v1_,v2_}]:>  meshCellCellDistance[mesh,{v1,v2}];

g = Graph[vertexList
,edgeList
,EdgeWeight->edgeWeights
,VertexCoordinates->Block[{x},MeshPrimitives[mesh,0]/. Point[x_]->x]];
g
];
meshToGraph[m_] := Print["mG called with head ", Head[m]];

If[makePackage,End[]]; (* Private *)

If[makePackage,EndPackage[]];





(* ::Input::Initialization:: *)
meshCoordinates[meshAssociation_Association,ix_] := graphCoordinates[meshAssociation["Graph"],ix]

graphCoordinates[meshAssociation_Association,ix_] := graphCoordinates[meshAssociation["Graph"],ix]

 
graphCoordinates[g_Graph,ix_] := (AnnotationValue[{g,ix},VertexCoordinates]);
graphCoordinates[g_,ix_] := Print["gC called with head ",Head[g]];




(* ::Input::Initialization:: *)
createParastichyFamily[meshAssociation_,starter_,family_:1] := Module[{nextpara,paraList,mpf,pstart},
pstart = parastichyStarter[meshAssociation,starter];If[Length[pstart]<2,Return[Missing["Can't make starter from ", starter]]];mpf = {};mpf = addToParastichyFamily[mpf,pstart,family];mpf = Nest[findAdjacentThreads[meshAssociation,#]&,mpf,locateParastichyOptions["FamilyGrowthSize"]];
mpf = tidyParastichyFamily[meshAssociation,mpf];

If[locateParastichyOptions["Renumber"],
mpf = renumberParastichyFamily[meshAssociation,mpf];
];
mpf
];


(* ::Input::Initialization:: *)
findAnOverlap[meshAssociation_,parastichyFamily_] := Module[{ix,jx,overlap},
For[ix=1,ix<Length[parastichyFamily],ix++,
For[jx = ix+1, jx<=Length[parastichyFamily],jx++,
overlap  = Intersection[
parastichyFamily[[ix]]["Members"],parastichyFamily[[jx]]["Members"]
];
If[Length[overlap]>0 
, Return[{parastichyFamily[[ix]]["Index"],parastichyFamily[[jx]]["Index"]}]];
]];
Return[Missing["No overlap"]];
];

adjacencyFunction[meshAssociation_] := Function[{ix},AdjacencyList[meshAssociation["Graph"],ix]];


findAnAdjacency[meshAssociation_,parastichyFamily_] := Module[{ix,jx,firstTail,secondHead,decho},
decho[x_] := If[False,Echo[x,"fAA"],x];


For[ix=1,ix<Length[parastichyFamily],ix++,
For[jx = ix+1, jx<=Length[parastichyFamily],jx++,
decho[{parastichyFamily[[ix]],parastichyFamily[[jx]]}];

firstTail = Last[parastichyFamily[[ix]]["Members"]];
secondHead =  First[parastichyFamily[[jx]]["Members"]];

If[MemberQ[adjacencyFunction[meshAssociation][firstTail],secondHead]
, Return[{parastichyFamily[[ix]]["Index"],parastichyFamily[[jx]]["Index"]}]];

firstTail = Last[parastichyFamily[[jx]]["Members"]];
secondHead =  First[parastichyFamily[[ix]]["Members"]];

If[MemberQ[adjacencyFunction[meshAssociation][firstTail],secondHead]
, Return[{parastichyFamily[[jx]]["Index"],parastichyFamily[[ix]]["Index"]}]];


]];
Return[Missing["No adjacency"]];
];




(* ::Input::Initialization:: *)
tidyParastichyFamily[meshAssociation_,parastichyFamily_] := Module[{ijx,n,mPF},
mPF = parastichyFamily;

For[n=0,n<100,n++,
ijx = findAnOverlap[meshAssociation,mPF] ;
If[MissingQ[ijx],Break[]];
Print[n, " Overlap", ijx];
mPF = mergeParastichySibs[meshAssociation,mPF,ijx];
];
For[n=0,n<100,n++,
ijx = findAnAdjacency[meshAssociation,mPF] ;
If[MissingQ[ijx],Break[]];
mPF = mergeParastichySibs[meshAssociation,mPF,ijx];
];

mPF
];



(* ::Input::Initialization:: *)
parastichyAdjacencyTable [meshAssociation_,parastichyFamily_]:= Module[{g,path,paraAdjacency,paraAdjacencyCount,paraAdjacencies,paraAdjacencyTable},
	paraAdjacency[parastichyFamilyMember_] := DeleteDuplicates[Union@@Map[adjacencyFunction[meshAssociation],parastichyFamilyMember["Members"]]];
	paraAdjacencyCount[ix_,ix_] := 0;
	paraAdjacencyCount[ix_,jx_] := Length@Intersection[
		paraAdjacency[parastichyFamily[[ix]]],parastichyFamily[[jx]]["Members"]
	];
paraAdjacencies[ix_] := Keys@Take[Reverse@Sort@Association@Table[ 
		parastichyFamily[[ix]]["Index"] \[UndirectedEdge]parastichyFamily[[jx]]["Index"]
		-> paraAdjacencyCount[ix,jx],
{jx,Length[parastichyFamily]}],2];
paraAdjacencyTable = Flatten@Table[paraAdjacencies[ix],{ix,Length[parastichyFamily]}]; 
	paraAdjacencyTable
];



(* ::Input::Initialization:: *)
renumberParastichyFamily[meshAssociation_,parastichyFamily_] := Module[{g,familyOrder,paraAdjacencyTable,res,family,para,i},
paraAdjacencyTable =parastichyAdjacencyTable[meshAssociation,parastichyFamily]; g = Graph[Map[#["Index"]&,parastichyFamily],paraAdjacencyTable,VertexLabels->"Name"];
familyOrder = topologicalSortByLongestPaths[g];
res = {};family = First[parastichyFamily]["Family"];family=ToString[family]~~"A";For[i=1,i<= Length[familyOrder],i++,
para = Query[SelectFirst[#["Index"]==familyOrder[[i]]&]]@parastichyFamily;res = addToParastichyFamily[res,para["Members"],family];
	];
	res
];


(* ::Input::Initialization:: *)

mergeParastichySibs[meshAssociation_,parastichyFamily_,{ix_,jx_}] := Module[{mPF,newParastichy,decho},

decho[x_] := If[True,Echo[x,"mPS"],x];

mPF = parastichyFamily;

newParastichy = Union[getParastichyByIndex[mPF,ix]["Members"],getParastichyByIndex[mPF,jx]["Members"]];newParastichy = makeDirectedParastichy[meshAssociation,newParastichy];If[MissingQ[newParastichy],Return[mPF]];
	
mPF = deleteFromParastichyFamily[mPF,{ix,jx}];	
mPF = addToParastichyFamily[mPF,newParastichy];
mPF
];


deleteFromParastichyFamily[mpf_,indices_] :=  Query[Select[ !MemberQ[indices,#["Index"]]&]]@mpf;
getParastichyByIndex[mpf_,index_] := First@Select[mpf,#["Index"]==index&];





combineInParastichyFamily[mpf_,{ix1_,ix2_}] := Module[{para,para1,para2,res},
para1 = (First@Query[Select[#["Index"]==ix1&]]@mpf)["Members"];
para2 = (First@Query[Select[#["Index"]==ix2&]]@mpf)["Members"];
para = Join[para1,para2];
res = mpf;

res = deleteFromParastichyFamily[mpf,{ix1,ix2}];
res = addToParastichyFamily[res,para];
res
];


addToParastichyFamily[mpf_,parastichy_] := addToParastichyFamily[mpf,parastichy,First[mpf]["Family"]];
addToParastichyFamily[mpf_,parastichy_,family_] := Module[{ix,res,overlaps,maxIndex},
res = mpf;
maxIndex = If[Length[mpf]==0,0,Max[Map[#["Index"]&,mpf]]];
res = Append[res,
<| "Family"->family,"Index"-> maxIndex+1,"Members"->parastichy , "Head"-> First@parastichy|>];
res
];

dropParastichyElement[mpf_,ix_,dix_] := Module[{res,para,pix},
res = mpf;
pix = First@FirstPosition[Map[#["Index"]&,res],ix];
para = res[[pix]];
para["Members"] = Drop[para["Members"],dix];
res[[pix]]=para;
res
];

appendParastichyElements[mpf_,ix_,extraPoints_] := Module[{res,para,pix},
res = mpf;
pix = First@FirstPosition[Map[#["Index"]&,res],ix];
para = res[[pix]];
para["Members"] = Join[para["Members"],extraPoints];
res[[pix]]=para;
res
];
prependParastichyElements[mpf_,ix_,extraPoints_] := Module[{res,para,pix},
res = mpf;
pix = First@FirstPosition[Map[#["Index"]&,res],ix];
para = res[[pix]];
para["Members"] = Join[extraPoints,para["Members"]];
res[[pix]]=para;
res
];


(* ::Input::Initialization:: *)

parastichyStarter[meshAssociation_, starter_] :=
  Module[{inner, parastichyPoints},
    inner = meshExtendParastichy[meshAssociation, starter, locateParastichyOptions["InitialParastichyLength"], {}, {}];
   inner
  ];
 
meshExtendParastichy[meshAssociation_,starter_,length_,avoidPoints_,adjacentParastichy_] :=Module[{i,parastichy,np,decho},

decho[x_] := If[False,Echo[x],x];
parastichy = starter;

For[ i=1,i<= length,i++,np = decho@nextParastichyPoint[meshAssociation,parastichy,avoidPoints,adjacentParastichy];If[MissingQ[np],Break[]];parastichy= Append[parastichy,np];If[MemberQ[meshAssociation["OuterBoundary"],np],Break[]];If[MemberQ[meshAssociation["InnerBoundary"],np],Break[]];
];
parastichy
];


(* ::Input::Initialization:: *)

nextParastichyPoint[meshAssociation_, parastichy_, avoidPoints_, adjacentParastichy_] := Module[{candidateContinues, straightnessAngle, nextStraightest, debugTest, adjacentParastichyEnds, candidateInfo, adjacentParastichyCentre, adjacentCandidates, res, decho},

 debugTest = MemberQ[{845, 10}, -First@parastichy]; decho[x_] := If[debugTest, Echo[x, "nPP"], x];If[Length[parastichy] == 0, Return[Missing["No parastichy to extend"]]];If[MissingQ[parastichy] == 0, Return[Missing["Missing parastichy"]]];straightnessAngle = If[Length[adjacentParastichy] > 0,
locateParastichyOptions["StraightnessWhenAdjacent"],
locateParastichyOptions["StraightnessWhenUnadjacent"]
];adjacentParastichyEnds  = If[Length[adjacentParastichy] == 0, {}, Union @@ Map[adjacencyFunction[meshAssociation][#] &, {First[adjacentParastichy], Last[adjacentParastichy]}]]; adjacentParastichyCentre   = Complement[adjacentParastichy, adjacentParastichyEnds];

candidateContinues = adjacencyFunction[meshAssociation][Last@parastichy];   

candidateContinues = Complement[candidateContinues, avoidPoints]; candidateInfo = KeyValueMap[ <| "Node" -> #1, "Deviation" -> #2|> &]@orderByStraightness[meshAssociation, parastichy, candidateContinues];
 candidateInfo = Map[Append[#, 
"Adjacency" -> adjacencyFunction[meshAssociation][#["Node"]]] &, candidateInfo];
 candidateInfo = Map[Append[#, 
"NextToAdjacentCentre" ->  Length[Intersection[#["Adjacency"], adjacentParastichyCentre]] > 0] &, candidateInfo]; candidateInfo = Map[Append[#, 
"NextToAdjacentEnds" ->  Length[Intersection[#["Adjacency"], adjacentParastichyEnds]] > 0] &, candidateInfo];
 candidateInfo = Map[     Append[#, 
"NextToAdjacent" ->   Length[Intersection[#["Adjacency"], adjacentParastichy]] > 0] &, candidateInfo];
 candidateInfo = Map[   Append[#, 
"OnAdjacent" ->   Length[Intersection[{#["Node"]}, adjacentParastichy]] > 0] &, candidateInfo];candidateInfo = Map[Append[#,
 "Straightish" -> isStraightish[#]] &, candidateInfo];
   (* screen out any with too much deviation anyway *) 
candidateInfo =  Query[Select[  #["Straightish"] & ]]@ candidateInfo; If[Length[candidateInfo] == 0, Return[Missing["End of the line"]]  ]; If[First[candidateInfo]["OnAdjacent"],  Return[Missing["Collision"]]    ];
   
   (* do we have any that preserve adjacency *) adjacentCandidates =  Query[Select[  #["NextToAdjacent"] & ]]@candidateInfo;If[Length[adjacentCandidates] > 0,
res = First[adjacentCandidates]["Node"];
Return[res]
];   
   (* otherwise we take a nonadjacent (which may have been straighter *)res = First[candidateInfo]["Node"]; 
Return[res];
   ];

isStraightish[cInfo_] := (
   Abs[cInfo["Deviation"]] < 
    If[cInfo["NextToAdjacentCentre"] || cInfo["NextToAdjacentEnds"], 
     locateParastichyOptions["StraightnessWhenAdjacent"],
     locateParastichyOptions["StraightnessWhenUnadjacent"]
     ]
   );

orderByStraightness[meshAssociation_, parastichy_, candidateContinues_] := Module[{paraPossiblePairs, paraPossibleAngles, lastAngle, paraAngles, deviationsNext}, paraPossiblePairs = Map[{parastichy[[-1]], #} &, candidateContinues]; paraPossibleAngles = Association@Map[#[[2]] -> graphEdgeAngle[meshAssociation, #] &, paraPossiblePairs]; lastAngle = graphEdgeAngle[meshAssociation, {parastichy[[-2]], parastichy[[-1]]}]; paraAngles = Map[anglePrincipal[# - lastAngle] &, paraPossibleAngles]; deviationsNext = Sort@Abs[paraAngles];
   deviationsNext
   ];




(* ::Input::Initialization:: *)
graphLineDeviation[meshAssociation_, {ix1_, ix2_, ix3_}] := Module[{ first, second},
   (* in [-180,180 *)
first =  graphEdgeAngle[meshAssociation,{ix1,ix2}];
second = graphEdgeAngle[meshAssociation,{ix2,ix3}];
anglePrincipal[first - second]
   ];

graphEdgeAngle[meshAssociation_,{ix1_,ix2_}] := Module[{p1p2,pAngle},
(* in [-180,180 *)
p1p2 =graphCoordinates[meshAssociation["Graph"], {ix1, ix2}];
pAngle[{{x1_, y1_}, {x2_, y2_}}] := (360/(2 \[Pi])) ArcTan[x2 - x1, y2 - y1];
pAngle[p1p2]
];




(* ::Input::Initialization:: *)



anglePrincipal[angle_] :=  angle - 360 Round[angle/360]; (* in -180 < angle < 180 *) 



(* ::Input::Initialization:: *)
extendThreadAndAdd[meshAssociation_,parastichyFamily_,thread_] := Module[{mPF,extendThread,avoidPoints,decho},
mPF = parastichyFamily;
avoidPoints = nodesInParastichyFamily[mPF];If[Length[Intersection[thread,avoidPoints]]>0,Return[mPF]];extendThread = meshExtendParastichy[meshAssociation,thread,locateParastichyOptions["ParastichyExtensionLength"], avoidPoints,{}];avoidPoints = Union[avoidPoints,extendThread];
extendThread = meshExtendParastichy[meshAssociation,Reverse@extendThread,locateParastichyOptions["ParastichyExtensionLength"], avoidPoints,{}];decho[{"Second extension ",extendThread}];avoidPoints = Union[avoidPoints,extendThread];extendThread  = makeDirectedParastichy[meshAssociation,extendThread];mPF = addToParastichyFamily[mPF,extendThread] ; 
mPF
];


(* ::Input::Initialization:: *)
findAdjacentThreads[meshAssociation_,parastichyFamily_] := Module[{mPF,atp,family,ix,avoidPoints,extendThread,decho,nTimes},
mPF = parastichyFamily;

For[nTimes = 1,nTimes<= 1,nTimes++,
atp = adjacentThreadsToParastichyFamily[meshAssociation,mPF];

For[ix=1,ix<= Length[atp],ix++,
mPF = extendThreadAndAdd[meshAssociation,mPF,atp[[ix]]];
];
];
mPF
];


centralMembers[parastichyFamilyMember_] := Module[{members},
members = parastichyFamilyMember["Members"];
If[Length[members]==0,Return[Missing["Error: parastichy with no members"]]];
If[Length[members]<3,Return[{}]];
Drop[Drop[members,-1],1]
];

nodesInParastichyFamily[parastichyFamily_] :=  DeleteDuplicates[Union@@Map[#["Members"]&,parastichyFamily]];

nonEndNodesInParastichyFamily[parastichyFamily_] :=  DeleteDuplicates[Union@@Map[centralMembers,parastichyFamily]];

adjacentNodesToParastichyFamily[meshAssociation_,parastichyFamily_]:=  Module[{familyPoints,allAdjacentPoints},
familyPoints  =  nonEndNodesInParastichyFamily@parastichyFamily;
allAdjacentPoints = Union @@ Map[adjacencyFunction[meshAssociation][#]&, familyPoints];
allAdjacentPoints = DeleteDuplicates @allAdjacentPoints ;
allAdjacentPoints= Complement[allAdjacentPoints, nodesInParastichyFamily[parastichyFamily] ];
allAdjacentPoints
];


(* ::Input::Initialization:: *)
adjacentThreadsToParastichyFamily[meshAssociation_,parastichyFamily_]:=  Module[{allAdjacentEdges,allAdjacentGraph,allAdjacentComponents,adjacentThreads},
debugTest = False;
(*avoidPoints = nodesInParastichyFamily[parastichyFamily];
*)allAdjacentEdges = GraphUnion@@Map[NeighborhoodGraph[meshAssociation["Graph"],#]&,nodesInParastichyFamily[parastichyFamily]];
allAdjacentEdges = Graph[allAdjacentEdges,VertexLabels->"Name"];
allAdjacentEdges = VertexDelete[allAdjacentEdges,nodesInParastichyFamily[parastichyFamily]];

If[debugTest,
Print[allAdjacentEdges]];

If[VertexCount[allAdjacentEdges]<2,Return[]];

allAdjacentGraph = allAdjacentEdges;
allAdjacentComponents =  ConnectedGraphComponents[allAdjacentGraph];allAdjacentComponents  =Select[allAdjacentComponents, VertexCount[#] >= locateParastichyOptions["MinimumThreadLength"]&];

If[debugTest,
Print[allAdjacentComponents]];

allAdjacentComponents  =Map[makeDirectedPath[meshAssociation,#]&,allAdjacentComponents];allAdjacentComponents    = allAdjacentComponents /. Missing[_]->Nothing[];

If[debugTest,
Print[allAdjacentComponents]];
allAdjacentComponents  = Map[splitAtKinks[meshAssociation,#]&,allAdjacentComponents];allAdjacentComponents  = Flatten @allAdjacentComponents;allAdjacentComponents    = allAdjacentComponents /. Missing[_]->Nothing[];adjacentThreads  =Map[TopologicalSort,allAdjacentComponents];

adjacentThreads
];


(* ::Input::Initialization:: *)
vertexEdgeCount[graph_,vertex_] := Length[IncidenceList[graph,vertex]];


removeCyclicPoints[component_] :=Module[{stree,incidence,edgeCount,branchPoints,streeComponents,res},stree = FindSpanningTree[component];


incidence  =  AssociationThread[VertexList[stree],Map[IncidenceList[stree,#]&,VertexList[stree]]];edgeCount  =  Map[Length,incidence];branchPoints = Select[edgeCount,#>2&];stree =VertexDelete[component,Keys@branchPoints];streeComponents = ConnectedGraphComponents[stree];streeComponents = SortBy[streeComponents,VertexCount];res = Last@streeComponents;

res

];





(* ::Input::Initialization:: *)
findLongestPath[g_] := Module[{paths,path,decho},
decho[x_] := If[False,Echo[x,"fLP"],x];
If[VertexCount[g]<= 2, Return[VertexList[g]]];
paths =findEdgePaths[g];
path = Last[SortBy[paths,#["PathLength"]&]]["Path"];
If[Length[path]==0,Return[Missing["No spanning path"]]];
path
];


findEndPoints[g_] := Module[{acyclic,endPoints},
decho[x_] := If[False,Echo[x,"fEPt"],x];
If[VertexCount[g]<= 1, Return[VertexList[g]]];
acyclic = FindSpanningTree[g];
endPoints = Select[VertexList[acyclic],vertexEdgeCount[acyclic,#]==1&];
endPoints
];


(* ::Input::Initialization:: *)
findEdgePaths[g_] := Module[{acyclic,endPoints,paths,decho},
decho[x_] := If[False,Echo[x,"fEP"],x];
endPoints = decho@findEndPoints[g];
If[Length[endPoints]<1,Return[Missing["Missing path ends"]]];If[Length[endPoints]==1,Return[Missing["Couldn't construct spanning tree"]]];

paths = Map[<|"Start"->#[[1]],"End"->#[[2]]|> &,Partition[endPoints,2,1]];paths = Map[ Append[#,"Path"-> First@FindPath[g,#["Start"],#["End"]]]&,paths];paths = Map[ Append[#,"PathLength"-> Length@#["Path"]]&,paths];
paths
];


topologicalSortByLongestPaths[g_] := Module[{reducedGraph,path},
decho[x_] := If[False,Echo[x,"fLPs"],x];
path = findLongestPath[g];
reducedGraph = ConnectedGraphComponents@VertexDelete[g,path];
leftoverPaths = Map[findLongestPath,reducedGraph];
(* if that reduced tree still has branches we wil lose them *)
Join[path,Join@@leftoverPaths]
];

findSpanningPath[meshAssociation_,undirectedGraph_] := Module[{acyclic,endPoints,path,decho},
(* fixable *) 
decho[x_] := If[False,Echo[x,"fSPd"]];
acyclic = removeCyclicPoints[undirectedGraph];

endPoints = Select[VertexList[acyclic],vertexEdgeCount[acyclic,#]==1&];
endPoints = SortBy[endPoints,-graphPointRadius[meshAssociation,#]&];

If[Length[endPoints]<1,Return[Missing["Missing path ends"]]];

If[Length[endPoints]==1,
decho[{"No spanning tree for ",acyclic}];
Return[Missing["Couldn't construct spanning tree"]]];

If[Length[endPoints]>2,endPoints=Take[endPoints,2]];

path = FindPath[acyclic,First[endPoints],Last[endPoints]];
If[Length[path]==0,
path = FindPath[acyclic,Last[endPoints],First[endPoints]]
];

If[Length[path]==0,
Return[Missing["No spanning path"]]];
Clear[decho];
path = First@path;
path
];


(* ::Input::Initialization:: *)
makeDirectedParastichy[meshAssociation_,parastichy_] := Module[{edgeList,path},
edgeList = Map[{List,{#},Intersection[parastichy,adjacencyFunction[meshAssociation][#]]}&,parastichy];
edgeList = DeleteDuplicates[Sort /@Flatten[Map[Apply[Outer,#]&,edgeList],2]];
edgeList = Map[ #[[1]] \[UndirectedEdge] #[[2]] &, edgeList];
path  = findSpanningPath[meshAssociation, Graph[edgeList]];
path
];


(* ::Input::Initialization:: *)
makeDirectedPath[meshAssociation_,component_] :=Module[{path,acyclic,res},
(* given an undirected graph which is mainly a single path , return the directed graph with outer point at head *)acyclic = removeCyclicPoints[component];path = findSpanningPath[meshAssociation,acyclic];If[MissingQ[path],Return[path]];path = Partition[path,2,1];res= EdgeDelete[acyclic,EdgeList[acyclic]];res = EdgeAdd[res,DirectedEdge @@@ path];
res
];

directedPathHead[component_] :=  First@TopologicalSort[component];


(* ::Input::Initialization:: *)



graphPointRadius[meshAssociation_Association,ix_] :=  Module[{c,p},
c = meshAssociation["Centroid"];
p = graphCoordinates[meshAssociation["Graph"],ix];
Norm[(c-p)]
];

vertexAngle[meshAssociation_,component_,vertex_] :=Module[{incidence,inPair,outPair,ix123},
incidence = IncidenceList[component,vertex];
If[Length[incidence]==0,Return[Missing["Can't find incidence"]]];
If[Length[incidence]==1,Return[0]];
If[Length[incidence] > 2,Return[Missing["Too many incidences"]]];
inPair = First@Cases[incidence, _ \[DirectedEdge] vertex];
outPair = First@Cases[incidence, vertex \[DirectedEdge] _];
ix123 = {First[inPair],First[outPair],Last[outPair]};
graphLineDeviation[meshAssociation,ix123]
];


(* ::Input::Initialization:: *)
splitAtKinks[meshAssociation_,component_] := Module[{angles,res,kinks,edgesToDrop},
(* component is an unforked directed path with one element *)


vertices = VertexList[component];

angleAtVertex = Map[vertexAngle[meshAssociation,component,#]&,vertices];

angles = AssociationThread[vertices,angleAtVertex];
kinks = Keys@Select[angles,
		Abs[#] >locateParastichyOptions["StraightnessWhenAdjacent"]&];edgesToDrop = Map[
	Cases[IncidenceList[component,#],#\[DirectedEdge] _]&,kinks];res = component;
	res = EdgeDelete[res,Flatten@edgesToDrop];res  =connectedDirectedGraphComponents[res];
	res = Select[res,VertexCount[#]>  locateParastichyOptions["MinimumThreadLength"]&];
	Return[res];

];


eDeleteEdge[g_Graph,edge_] :=If[EdgeQ[g,edge],EdgeDelete[g,edge],g];

eDelete[comp_,edges_] := Module[{g,i},
g=comp;
For[i=1,i<= Length[edges],i++,
g = eDeleteEdge[g,edges[[i]]]
];
g
];

connectedDirectedGraphComponents[g_] := Module[{edges,flip,res},
edges = EdgeList[g];
flip[ a_ \[DirectedEdge] b_ ] := b \[DirectedEdge] a;
edges = Map[flip,edges];
If[MissingQ[edges],Echo[" Missing edges ", Stack[]]];
res = EdgeAdd[g,edges];
Map[eDelete[#,edges]&,
ConnectedGraphComponents[res]]
];


polygonsAtVertex[g_,v_] := Module[{edges},
edges = EdgeList@NeighborhoodGraph[g,v];
edges = Cases[edges,Except[ _ \[UndirectedEdge] v | v \[UndirectedEdge] _]];
edges  = Apply[List,edges,1];
edges = Map[Polygon@Append[#,v]&,edges];
edges 
];

graphToMesh[g_] := Module[{meshPoints,meshPolygons,mesh},
meshPoints = AnnotationValue[{g,VertexList[g]},VertexCoordinates];
meshPolygons = Flatten@Map[polygonsAtVertex[g,#]&,VertexList[g]];
mesh = MeshRegion[meshPoints,meshPolygons];
{meshPoints,meshPolygons}
];



