(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)
addAnnotationsToGraph = True;



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;
diskTopZ[Disk[{_,z_},r_]] := z+r;
diskR[Disk[{_,_},r_]] := r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;
leftAndRightNumbers[n_List] := Join@@{n,moveNumberRight/@n,moveNumberLeft/@n};
bareNumber[left[n_]]  := n;
bareNumber[right[n_]] := n;
bareNumber[n_] := n;


moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];
moveNumberedDiskLeft[n_->d_] := moveNumberLeft[n]->moveDiskLeft[d];


getDisk[n_,run_] := If[
KeyExistsQ[run["CurrentDisks"],n],run["CurrentDisks"][n]
,If[KeyExistsQ[run["PastDisks"],n],run["PastDisks"][n],
Missing[StringTemplate["No disk ``"][{n}]]]
];
getDisk[right[n_],run_] := moveDiskRight[getDisk[n,run]];
getDisk[left[n_],run_] := moveDiskLeft[getDisk[n,run]];

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);

diskAndVisibleCopies[Disk[{x_,z_},r_]] := {Disk[{x,z},r],If[x+r>1/2,moveDiskLeft[Disk[{x,z},r]],Nothing[]],If[x-r<-1/2,moveDiskRight[Disk[{x,z},r]],Nothing[]]};

disksMaximum[run_] := 
Max@Map[diskTopZ,run["CurrentDisks"]];

highestDiskZ[run_] := Max@Map[diskZ,Values@run["CurrentDisks"]];
smallestRadius[run_] := Min@Map[diskR,Values@run["CurrentDisks"]];

nextRadius[run_] := Module[{highestZ},
highestZ=highestDiskZ[run];
run["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[run_] := Max@Keys[run["CurrentDisks"]]+1;nextChainNumber[run_]:= Max[Keys[run["CompletedChainGraphs"]]]+1;


(* ::Input::Initialization:: *)
extendDisksRight[run_,nextR_] := Module[
{extendedDisks,extendedDisksRight},
extendedDisks= run["CurrentDisks"];
extendedDisksRight = 
Select[extendedDisks,diskLeftX[#]+1     <= 1/2 +nextR&];
extendedDisksRight = Association[Map[moveNumberedDiskRight,Normal[extendedDisksRight]]];
extendedDisksRight

];
extendDisksLeft[run_,nextR_] := Module[
{extendedDisks,extendedDisksLeft},
extendedDisks= run["CurrentDisks"];

extendedDisksLeft = Select[extendedDisks,diskRightX[#]-1 + nextR >=- 1/2 &];
extendedDisksLeft = Association[Map[moveNumberedDiskLeft,Normal[extendedDisksLeft]]];

extendedDisksLeft

];
extendDisksLeftRight[run_,nextR_]:= Module[{extendedDisks},
extendedDisks = 
Append[run["CurrentDisks"], extendDisksRight[run,nextR]];
extendedDisks = 
Append[extendedDisks, extendDisksLeft[run,nextR]];
extendedDisks 
];



(* ::Input::Initialization:: *)

runCompletesArena[run_] := Module[{res},

If[run["Arena"]["ChainMax"]=="Fill",
res =disksMaximum[run]>run["Arena"]["CylinderLU"][[2]]+ 2 * run["Arena"]["rFunction"][run["Arena"]["CylinderLU"][[2]]],
res = nextChainNumber[run] > run["Arena"]["ChainMax"];
];
res
];




(* ::Input::Initialization:: *)
addDisksFromGraph[seedRun_,chainNumber_:1] := Module[{run,currentDisks,g},
g = seedRun["ContactGraph"];
g = Graph[g,VertexCoordinates->Map[diskXZ[getDisk[#,seedRun]]&,VertexList[g]]];
g = Graph[g,PlotTheme->"Labeled",
VertexStyle->Directive[EdgeForm[None],FaceForm[None]],
VertexLabels->Placed[Automatic,Center]];
g = Graph[g,AnnotationRules->Map[#->{EdgeStyle->Gray}&,EdgeList[g]]];

run = Append[seedRun,
<|
"CurrentDisks"->Association@Map[#->getDisk[#,seedRun]&, Select[VertexList[g],#==bareNumber[#]&]]
,"PastDisks"-> Association[]
,"Parastichy"-> Association[]
,"ContactGraph"->  g
,"CompletedChainGraphs"-> <|chainNumber->g|>
,"CompletedChainNodePaths" -> <|chainNumber->{}|>
,"UsedOverlaps"->{}
,"CurrentChain"->{}
,"CurrentChainGraph"->Missing[]
|>
];
run
];




(* ::Input::Initialization:: *)
restartRunFromChain[run_,chain_] := Module[{res,chainGraph},
res =run;
chainGraph = run["CompletedChainGraphs"][chain];
res["ContactGraph"] = chainGraph;
res = addDisksFromGraph[res,chain];
res
];


(* ::Input::Initialization:: *)

executeRun[run_,chainMax_:Missing[]] := Module[{i,imax,res,timing},
Off[SSSTriangle::tri];
res = run;
If[!MissingQ[chainMax],
res["Arena"]["ChainMax"]=chainMax];
imax = res["Arena"]["ChainMax"];
If[!NumericQ[imax],imax=500];
Monitor[
For[i=1,i<= imax,i++,
If[runCompletesArena[res],Break[]];
{timing,res} = Timing[completeChain[res]];

];
,StringTemplate["parastichy `parastichy`; chain `chain`; disk `disk`; Z `Z`; per-chain time `timing`; per-disk time `disktime`"][<|"chain"->nextChainNumber[res]-1
,"disk"-> nextDiskNumber[res]-1
,"Z"-> highestDiskZ[res]
,"parastichy"->  Last[res["Parastichy"]]
,"timing"->timing
,"disktime"-> res["CurrentTimePerDisk"]|>]
];
res
];



(* ::Input::Initialization:: *)
chainCodeExecute[experiment_] := Module[{res,run},
res=experiment;
run = executeRun[experiment];
res = Append[experiment,"Results"->run];
res = Append[res,"ChainStatistics"->chainStatistics[run]];
res = Append[res,"NodeStatistics"->nodeStatistics[run]];
res
];

disksNumbersInChain[run_,chain_] := Module[{diskNumbers},
diskNumbers = VertexList[ run["CompletedChainGraphs"][chain]];
diskNumbers = Select[diskNumbers,#==bareNumber[#]&];
diskNumbers
]
disksInChain[run_,chain_] := Map[getDisk[#,run]&,disksNumbersInChain[run,chain]];

chainMeanRise[run_,chain_] := Module[{zValues},
zValues = diskZ /@ disksInChain[run,chain];
zValues = Sort[zValues];
zValues  = Differences[zValues];
Mean[zValues]
];

chainMeanZ[run_,chain_] := Mean[diskZ /@ disksInChain[run,chain]];
chainMeanR[run_,chain_] := Mean[diskR /@ disksInChain[run,chain]];
chainMeanAngle[run_,chain_] := Module[{diskNumbers,diskDifferences},
diskNumbers= Select[disksNumbersInChain[run,chain],#==bareNumber[#]&];
diskDifferences = Association@Map[#-> {diskX@getDisk[#-1,run],diskX@getDisk[#,run]}&,diskNumbers];
diskDifferences = Map[#[[2]]-#[[1]]&,diskDifferences];
diskDifferences = Map[If[#<0,1+#,#]&,diskDifferences];
Mean@diskDifferences
];

chainStatistics[run_] := Module[{paras,chainNumbers},
paras = run["Parastichy"];
paras = KeyValueMap[<|"Chain"->#1,"Parastichy"->KeySort[#2]|>&,paras];
paras = Map[Append[#,"MeanZ"->chainMeanZ[run,#Chain]]&,paras]; 
paras = Map[Append[#,"MeanR"->chainMeanR[run,#Chain]]&,paras]; 
paras = Map[Append[#,"MeanRise"->chainMeanRise[run,#Chain]]&,paras]; 
paras = Map[Append[#,"MeanTheta"->chainMeanAngle[run,#Chain]]&,paras]; 
paras
]


nodeStatistics[run_] :=  Module[{doNode,nodes},
doNode[n_] := Module[{disk,lastDisk,res},
disk = getDisk[n,run];
lastDisk = getDisk[n-1,run];
res= <|"DiskNumber"->n
,"Area"->areaPerNode[run,n]
,"Z"->diskZ[disk]
,"R"->diskR[disk]
,"Rise"-> If[MissingQ[ lastDisk],lastDisk,diskZ[disk]-diskZ[lastDisk]]
,"DeltaX"-> If[MissingQ[ lastDisk],lastDisk,diskX[disk]-diskX[lastDisk]]
|>;
res= Append[res,"Theta"-> If[res["DeltaX"]<-1/2,res["DeltaX"]+1,If[res["DeltaX"]>1/2,res["DeltaX"]-1,res["DeltaX"]]]];
res
];
nodes= Map[doNode,
Keys[run["PastDisks"]]];

vList = VertexList/@run["CompletedChainGraphs"];
nodeChainLookup = Association@Map[First[#]->Last[#]&,Flatten[KeyValueMap[Outer[List,#1,#2]&,GroupBy[Normal[vList],Last->First]],2]];

nodes= Map[Append[#,"Chain"-> nodeChainLookup[#DiskNumber]]&,nodes];
nodes= Map[Append[#,"Parastichy"-> run["Parastichy"][#Chain]]&,nodes];

nodes
];

areaPerNode[run_,node_] := Module[{g,nodes,nodeNeighbours,nodeAreas,disks,vDisk,vectors,areas},
g  = run["ContactGraph"];
nodeNeighbours =  VertexList@NeighborhoodGraph[g,node];

disks = Association@Map[#-> getDisk[#,run]&,nodeNeighbours];
vDisk = disks[node];
disks = Map[diskXZ,Select[disks,diskZ[#]<diskZ[vDisk]&]];
vectors = Map[ #- diskXZ[vDisk]&,disks];
areas = If[Length[vectors]==2,Abs@Det@ (Values@vectors),Missing[]];
areas
];



(* ::Input::Initialization:: *)
completeChain[run_] := Module[{res,i,complete=False},
res = run;


For[i=1,i<= 500,i++,

res = initializeCurrentOverlaps[res];

res= addNextDisk[res];
res = initializeCurrentOverlaps[res];
res = tryToCompleteCurrentChain[res];
complete = !MissingQ[res["CurrentChainNodePath"]];
If[complete,Break[]];

debugRes = res;
];
If[!complete,
Print[StringTemplate["chain incomplete after `` iterations"][i]];
Abort[];
];



res = setUpNewChain[res];
res
];

setUpNewChain[run_] := Module[{res,chainNumber,completedChainGraph},

res = run;
completedChainGraph = res["CurrentChainGraph"];
chainNumber = nextChainNumber[res];
res["CompletedChainGraphs"]= Append[res["CompletedChainGraphs"],
chainNumber->completedChainGraph];
res["CompletedChainNodePaths"]= Append[res["CompletedChainNodePaths"],
chainNumber->res["CurrentChainNodePath"]];

res["Parastichy"] = Append[res["Parastichy"],computeChainParastichy[res]];

res["PastDisks"]= Append[res["PastDisks"],res["CurrentDisks"]];


res["CurrentDisks"]= KeyTake[
res["CurrentDisks"],res["CurrentChain"]];

res["CurrentChain"] = {};
res["CurrentOverlaps"] = {};
res["UsedOverlaps"]= {};


res["CurrentChainGraph"] = Graph[{}];

res

]


(* ::Input::Initialization:: *)
computeChainParastichy[run_] := Module[{completedChainNumber,completedChainGraph,edges,res,g,lines},
completedChainNumber = Last[Keys[run["CompletedChainGraphs"]]];
g = run["CompletedChainGraphs"][completedChainNumber];
edges = Map[Apply[UndirectedEdge,#]&, Partition[run["CurrentChainNodePath"],2,1]];
leftOrRight[ a_ \[UndirectedEdge] b_] := Module[{x1,z1,x2,z2},{{x1,z1},{x2,z2}}={diskXZ[getDisk[a,run]],diskXZ[getDisk[b,run]]};
If[(z2-z1)/(x2-x1) >0 , "Right","Left"]];
edges = Map[leftOrRight,edges];
edges= Counts[edges];
completedChainNumber-> edges

]


(* ::Input::Initialization:: *)
tryToCompleteCurrentChain[run_] := Module[{res,nodeList,lrNodes,lrCases,lrPaths},
res = run;
res["CurrentChainNodePath"]=Missing["No chain"];


nodeList = VertexList@res["CurrentChainGraph"];
lrNodes = Cases[nodeList,left[_] | right[_]];
lrCases = Association@Map[#->MemberQ[nodeList,bareNumber[#]]&,lrNodes];
lrCases = Select[lrCases,TrueQ];

If[Length[lrCases]==0,Return[res]];
lrPaths = Association@Map[#->lrNodePath[#,res["CurrentChainGraph"]]&,Keys@lrCases];
lrPaths = Select[lrPaths,Length[#]>0&];

If[Length[lrPaths]==0,Return[res]];
If[Length[lrPaths]>1,
Print["Multiple paths"];
Print[lrPaths];
Print[res["CurrentChainGraph"]]
];

res["CurrentChainNodePath"]= First@First[lrPaths];

Return[res];


];

lrNodePath[lrNode_,g_] := FindPath[g,lrNode,bareNumber[lrNode]]


(* ::Input::Initialization:: *)
initializeCurrentOverlaps[run_] := Module[{nextR,res},
nextR= nextRadius[run];

possibleOverlaps = potentialHorizontalOverlaps[run,nextR];
 possibleOverlaps = Complement[possibleOverlaps,run["UsedOverlaps"]];
res=run;

res["CurrentOverlaps"]= possibleOverlaps;
res
];



(* ::Input::Initialization:: *)
potentialHorizontalOverlaps[run_,nextR_] := Module[{supportDisks,supportPairs,can},
supportDisks = currentSupportDisks[run,nextR];
(* these are sorted in X order, so the pairs will always be left right 
and we only need test one overlap *)
supportPairs = {};
For[i=1,i< Length[supportDisks],i++,
For[j=i+1,j<= Length[supportDisks],j++,
can = diskPairCanSupport[run,nextR,supportDisks[[i]],supportDisks[[j]]];

If[can,
supportPairs = Append[supportPairs,{supportDisks[[i]],supportDisks[[j]]}]
]
]
];

supportPairs

];


(* ::Input::Initialization:: *)
currentSupportDisks[run_,nextR_] :=  Module[{chain,lefts,rights},
chain = VertexList@Last@run["CompletedChainGraphs"];
chain = Join[chain,run["CurrentChain"]];
chain = SortBy[chain,diskX[getDisk[#,run]]&];
lefts = Map[moveNumberedDiskLeft[#->getDisk[#,run]]&,chain];
lefts = First /@ Select[lefts,diskRightX[Last[#]]+nextR>= -1/2 &];
rights =  Map[moveNumberedDiskRight[#->getDisk[#,run]]&,chain];
rights =First /@ Select[rights,diskLeftX[Last[#]]-nextR<= 1/2 &];
DeleteDuplicates@Join[lefts,chain,rights]
]

diskPairCanSupport[run_,nextR_,n1_,n2_] := (*
assumes lr ordering *)
diskLeftX[getDisk[n2,run]]-diskRightX[getDisk[n1,run]]<= 2*nextR



(* ::Input::Initialization:: *)
Clear[timeResults];
Clear[timeCheck];
timeResults = Association[];
timeLabels = {"General"};
timeStart[label_] :=AppendTo[timeLabels,label];
timeStop := Drop[timeLabels,-1];
timeCheck[f_] := Module[{tim,res,label},
label = Last[timeLabels];
{tim,res}=Timing[f];
If[KeyExistsQ[timeResults,label],
timeResults[label] += tim,
timeResults=Append[timeResults,label->0]
];

res
];
timeStart[label_] := Null;
timeStop := Null;
timeCheck[f_] := f;

SetAttributes[timeCheck,HoldAll]
(*timeCheck[label_] := timeCheck[#,label]&*)


(* ::Input::Initialization:: *)

addNextDisk[run_] := Module[{res,next,path,n,g,timing},
runForNextDisk = run;

{timing,res}= Timing[timeCheck@findNextNormalizedDisk[run]];

n= nextDiskNumber[run];
res["CurrentTimePerDisk"]= timing;

res["CurrentDisks"] = Append[res["CurrentDisks"],n->res["NextDisk"]];
res["CurrentChain"] = Append[res["CurrentChain"],n];
res["CurrentChain"] = SortBy[res["CurrentChain"] ,diskX[getDisk[#,res]]&];

checkDiskPair[res,n];

res["ContactGraph"]=updateContactGraph[res,n];
res["CurrentChainGraph"] = subgraphPreservingCoordinates[res["ContactGraph"],leftAndRightNumbers@res["CurrentChain"]];
timeStop[];
res
];


(* ::Input::Initialization:: *)
updateContactGraph[res_,n_] := Module[{g,n1,n2,d,d1,d2,d1Left},
g = res["ContactGraph"];
{n1,n2}= res["NextDiskRestsOn"];

If[addAnnotationsToGraph,
{d,d1,d2} = {getDisk[n,res],getDisk[n1,res],getDisk[n2,res]};
g = vertexAddWithCoordinates[g,n,diskXZ[d]];
g = vertexAddWithCoordinates[g,n1,diskXZ[d1]];(* surely not needed *)
g = vertexAddWithCoordinates[g,n2,diskXZ[d2]];
g= EdgeAdd[g,
{n1 \[UndirectedEdge] n,n \[UndirectedEdge] n2 }];
g = Graph[g,AnnotationRules->{n1 \[UndirectedEdge] n->{EdgeStyle-> Red},
n \[UndirectedEdge] n2 ->{ EdgeStyle->Blue}}];
,
g = VertexAdd[g,n];
g= EdgeAdd[g,
{n1 \[UndirectedEdge] n,n \[UndirectedEdge] n2 }];
];





g
];


(* ::Input::Initialization:: *)
checkDiskPair[run_,n_] := Module[{d,n1,n2,d1,d2},
{n1,n2}= run["NextDiskRestsOn"];
{d,d1,d2} = {getDisk[n,run],getDisk[n1,run],getDisk[n2,run]};
If[diskX[d2]< diskX[d],Print["Both disks on left"];Abort[]];
If[diskX[d1]> diskX[d],Print["Both disks ",n1," ", n2," on right in chain adding: ",n, "  in chain ", nextChainNumber[run]-1,run];
bugReportRun= run;Abort[]];
(* assumes n1 n2 provided in x-order *)
]


(* ::Input::Initialization:: *)
vertexAddWithCoordinates[g_,v_,vxy_] := Module[{vc,res},
If[MemberQ[VertexList[g],v],Return[g]];
res = VertexAdd[g,v];
vc = AnnotationValue[g,VertexCoordinates];
vc = Append[vc,vxy];
res = Annotate[res,VertexCoordinates->vc];
res
]

subgraphPreservingCoordinates[g_,vList_] := Module[{res},
res = Subgraph[g,vList]
];


(* ::Input::Initialization:: *)
findNextNormalizedDisk[run_] := Module[{res},

res= findNextDisk[run];
If[diskIsLeft[res["NextDisk"]],
res["NextDisk"]=moveDiskRight[res["NextDisk"]];
res["NextDiskRestsOn"]= Map[moveNumberRight,res["NextDiskRestsOn"]]
];

If[diskIsRight[res["NextDisk"]],
res["NextDisk"]=moveDiskLeft[res["NextDisk"]];
res["NextDiskRestsOn"]= Map[moveNumberLeft,res["NextDiskRestsOn"]]
];



res

];


(* ::Input::Initialization:: *)
findNextDisk[run_] := Module[{res,nextR,locations,nonIntersectingLocations,nextPair,nextDisk,nextDiskZ,pairsLowerThanDisk},
res = run;
nextR= N@nextRadius[res];

debug = nextDiskNumber[res]==13;

locations = 
Association@Map[#->overlapLocations[#,nextR,res]&,run["CurrentOverlaps"]];


If[True, (* assumes nonincreasing r *)
tooWidePairs = Select[locations,Missing["interdisk too large"]];

res = addUsedOverlaps[res,Keys@tooWidePairs,"too wide"];
];



locations = DeleteMissing[locations];
locations = Select[locations,diskX[#]>=-1/2 && diskX[#]<=1/2 &];
locations = SortBy[locations,diskZ];

nonIntersectingLocations =   deleteIntersectingDisks[res,locations,nextR];

If[Length[nonIntersectingLocations]==0,
Print["Can't find a location"];
dumpRun = res;
Abort[];
];

nonIntersectingLocations= List@@First@Normal@nonIntersectingLocations;
(* were sorted in z-order so this is the lowest *)
{nextPair,nextDisk}=nonIntersectingLocations;
nextDiskZ = diskZ[nextDisk];
pairsLowerThanDisk = Keys@Select[locations,diskZ[#]< nextDiskZ&];


res = Append[res,"NextDiskRestsOn"->nextPair];
res = Append[res,"NextDisk"->nextDisk];

If[res["Arena"]["ExcludePreviousIntersectors"],
res = addUsedOverlaps[res,pairsLowerThanDisk,"lower"]];


(* don't try this pair again *)
res = addUsedOverlaps[res,{nextPair,
moveNumberLeft/@nextPair,
moveNumberRight/@ nextPair},"pair copies"];


Return[res]
];

addUsedOverlaps[run_,pairs_,reason_:Missing[]] := Module[{res},
res=run;

res["UsedOverlaps"]=Join[
res["UsedOverlaps"],pairs];
res
]


dPrint[x__] := If[debug, Print[x]];

deleteIntersectingDisks[run_,locations_,nextR_] := Module[{extendedDisks,r2,locationIntersectsQ,intersectionLocationNumbers},


extendedDisks = extendDisksLeftRight[run, nextR];

locationIntersectsQ[d_] := 
 Map[diskdiskIntersectionQ[d,#]&,extendedDisks];
intersectionLocationNumbers[d_] := Keys@Select[locationIntersectsQ[d],TrueQ];
 
(* for each location key (pair of disk numbers), find the list of disks it intersects *) 

r2 = Map[intersectionLocationNumbers[#]&,locations];
(* exclude self intersections (could just not look...*)
r2 = Association@KeyValueMap[#1->Complement[#2,#1]&,r2];
r2 = Map[Length[#]==0&,r2];
r2 = Select[r2,TrueQ];
r2 = KeyTake[locations,Keys@r2];


r2
];

diskdiskIntersectionQ[Disk[xy1_,r1_],Disk[xy2_,r2_]]:= Norm[xy1-xy2,2] < (r1+ r2);

overlapLocations[{n1_,n2_},r_,run_] := Module[{res,d1,d2,xl,xr,xres},
d1 = getDisk[n1,run];
d2 = getDisk[n2,run];
res = diskdiskUpperTouchingPoint[{d1,d2},r];
If[MissingQ[res],Return[res]]; (* no overlap *) 
{xl,xr}= Sort[{diskX[d1],diskX[d2]}];
xres = First[res];
If[ xres < xl || xres > xr, Return[Missing["Both disks left or right"]]];
Disk[res,r]
];



(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= newdiskdiskTouchingPoint[pairDisks,r];

If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];



(* ::Input::Initialization:: *)


newdiskdiskTouchingPoint[diskPair_,r_] := Module[{c1,c2,r1,r2,interdisk,interdiskVectorNorm,interdiskNormal,
angle,vector,normal,interdiskVector},
{c1,c2}= Map[diskXZ,diskPair];
{r1,r2}= Map[diskR,diskPair];
interdiskVector = c2-c1;
interdisk = Norm[interdiskVector];
interdiskVectorNorm = interdiskVector/Norm[interdiskVector];
interdiskNormal =  {-interdiskVectorNorm[[2]],interdiskVectorNorm[[1]]};


angle = sssTriangleInteriorAngle[r2+r,r+r1,interdisk];
vector=(r1+r)*Cos[angle]*interdiskVectorNorm;
normal = (r1+r)*Sin[angle]* interdiskNormal;
{c1+vector+normal,c1+vector-normal}

]
sssTriangleInteriorAngle[a_,b_,c_] := Module[{tri,angle},
tri =SSSTriangle[a,b,c];
If[Head[tri]==SSSTriangle,
Return[Missing["Not a triangle"]]];
angle = TriangleMeasurement[tri,{"InteriorAngle",1}];
angle
];

