(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;

moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];


getDisk[n_,run_] := run["CurrentDisks"][n];
getDisk[right[n_],run_] := moveDiskRight[getDisk[n,run]];

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);

diskAndVisibleCopies[Disk[{x_,z_},r_]] := {Disk[{x,z},r],If[x+r>1/2,moveDiskLeft[Disk[{x,z},r]],Nothing[]],If[x-r<-1/2,moveDiskRight[Disk[{x,z},r]],Nothing[]]};

nextRadius[run_] := Module[{highestZ},
highestZ=Max@Map[diskZ,Values@run["CurrentDisks"]];
run["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[run_] := Max@Keys[run["CurrentDisks"]]+1;


(* ::Input::Initialization:: *)
potentialHorizontalOverlaps[run_,nextR_] := Module[{res,extendedDisks,f},
extendedDisks = extendDisksRight[run,nextR];
f[n_] := Outer[List,{n}, disksWithinHorizontalRight[run,extendedDisks,n,nextR]];
res = Flatten[#,2]&@Map[f,
Keys[run["CurrentDisks"]]];
res
];

disksWithinHorizontalRight[run_,extendedDisks_,n_,nextR_] := Module[{rhs,rightPossible},
rhs = diskRightX[run["CurrentDisks"][n]];

Keys@Association@Select[Normal[extendedDisks], diskRightX[Last[#]]> rhs && diskLeftX[Last[#]]<rhs + 2 * nextR&]

];

extendDisksRight[run_,nextR_] := Module[
{extendedDisks,extendedDisksRight},
extendedDisks= run["CurrentDisks"];
extendedDisksRight = Select[extendedDisks,diskX[#]+1<= 1/2+nextR &];
extendedDisksRight = Association[Map[moveNumberedDiskRight,Normal[extendedDisksRight]]];
extendedDisks = Append[extendedDisks,extendedDisksRight];
extendedDisks

];


(* ::Input::Initialization:: *)
initializeCurrentOverlaps[run_] := Module[{nextR,extendedDisks,res},
extendedDisks= run["CurrentDisks"];
nextR= nextRadius[run];

(* look to the right to see if there may be any extra overlaps *)

possibleOverlaps = potentialHorizontalOverlaps[run,nextR];
possibleOverlaps = Complement[possibleOverlaps,run["UsedOverlaps"]];
res=run;
res["CurrentOverlaps"]= possibleOverlaps;
res
];

setGraphCoordinates[run_] := Module[{res,g,nxy},
res = run;
g= res["ContactGraph"];
nxy[n_] := diskXZ@getDisk[n,res];
g = Graph[g,VertexCoordinates->Map[#->nxy[#]&,VertexList[g]]];
g = Graph[g,PlotTheme->"Labeled"];
res["ContactGraph"]=g;
res
];


(* ::Input::Initialization:: *)
completeChain[run_] := Module[{res,i,complete=False,chainNumber,previousChain,completedChain},
res = run;

res = initializeCurrentOverlaps[res];

For[i=1,i<= 5,i++,
Print[i];
res= addNextDisk[res];
complete = currentChainIsComplete[res];
If[complete,Break[]];
];
If[!complete,
Print["chain incomplete"];
Return[res];

Abort[]];

previousChain = Last[res["CompletedChains"]];
res["PastDisks"]= Append[res["PastDisks"],res["CurrentDisks"]];


completedChain =  res["CurrentChain"];
chainNumber = Max[Keys[res["CompletedChains"]]]+1;
res["CompletedChains"]= Append[res["CompletedChains"],
chainNumber->completedChain];
res["CurrentDisks"]= KeyTake[
res["CurrentDisks"],completedChain];
res["CurrentChain"] = {};
res["CurrentOverlaps"] = {};


res

]


(* ::Input::Initialization:: *)
currentChainIsComplete[run_] := Module[{edgeList,lhs,rhs},
edgeList = EdgeList@res["ContactGraph"];
lhs = First[run["CurrentChain"]];
rhs = Last[run["CurrentChain"]];
MemberQ[edgeList,(rhs \[UndirectedEdge] right[lhs])] || MemberQ[edgeList,
( right[lhs] \[UndirectedEdge] rhs)]
]


(* ::Input::Initialization:: *)

addNextDisk[run_] := Module[{next,path,n,g},

next=findNextNormalizedDisk[run];
n= nextDiskNumber[run];
res= run;
res["CurrentDisks"] = Append[res["CurrentDisks"],n->next["Disk"]];

res["CurrentChain"] = Append[res["CurrentChain"],n];
res["CurrentChain"] = SortBy[res["CurrentChain"] ,diskX[getDisk[#,res]]&];

removeList = {next["RestsOn"] ,Reverse@next["RestsOn"],
moveNumberLeft/@next["RestsOn"],
moveNumberLeft/@ (Reverse@next["RestsOn"])
};
res["UsedOverlaps"] = Join[res["UsedOverlaps"],removeList];

g = res["ContactGraph"];


g= EdgeAdd[g,
{next["RestsOn"][[1]] \[UndirectedEdge] n,
n \[UndirectedEdge] next["RestsOn"][[2]] }];

res["ContactGraph"]=g;
res = setGraphCoordinates[res];


res =initializeCurrentOverlaps[res];


res
];

findNextNormalizedDisk[run_] := Module[{res},
res= findNextDisk[run];
If[diskIsLeft[res["Disk"]],
res["Disk"]=moveDiskRight[res["Disk"]];
res["RestsOn"]= Map[moveNumberRight,res["RestsOn"]]
];

If[diskIsRight[res["Disk"]],
res["Disk"]=moveDiskLeft[res["Disk"]];
res["RestsOn"]= Map[moveNumberLeft,res["RestsOn"]]
];

Print["Adding ",res];

res

];

findNextDisk[run_] := Module[{nextR,locations,nextPair,nextCentre},
nextR= N@nextRadius[run];

locations = Association@Map[#->overlapLocations[#,nextR,run]&,run["CurrentOverlaps"]];
locations = DeleteMissing[locations];


locations= List@@First@Normal@Sort@locations;
{nextPair,nextCentre}=locations;
Return[<|"Disk"->Disk[nextCentre,nextR],"RestsOn"->nextPair|>]
]

overlapLocations[{n1_,n2_},r_,run_] := Module[{},
diskdiskUpperTouchingPoint[{getDisk[n1,run],getDisk[n2,run]},r]
];



(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= diskdisktouchingPoint[pairDisks,r];
If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];

diskdisktouchingPoint[pairDisks_,r_] := Module[{xy1,xy2,r1,r2,interdisk,sTriangle,triangle
,rTrianglePT,lTrianglePT,transform},
{{xy1,r1},{xy2,r2}}= List@@@ pairDisks;
interdisk = Norm[xy1-xy2];
If[interdisk > (r1+r) +( r2 + r),Return[Missing[]]];
Off[SSSTriangle::tri];
sTriangle =SSSTriangle[r+r2,r+r1,interdisk];
On[SSSTriangle::tri];
If[Head[sTriangle]===SSSTriangle,
Return[Missing[]]
(*Abort[];*)
];
triangle = (List@sTriangle)[[1,1]];
transform =Composition[TranslationTransform[xy1],RotationTransform[{triangle[[2]]-triangle[[1]],xy2-xy1}]
];
rTrianglePT = (transform[triangle])[[3]];
lTrianglePT = (ReflectionTransform[RotationTransform[90 Degree][xy2-xy1],xy1])[rTrianglePT];
{rTrianglePT,lTrianglePT}
];

