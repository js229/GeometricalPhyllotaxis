(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskXZ[Disk[{x_,z_},_]] := {x,z};
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;
diskTopZ[Disk[{_,z_},r_]] := z+r;


moveNumberRight[n_] := right[n];
moveNumberRight[left[n_]] := n;
moveNumberLeft[n_] := left[n];
moveNumberLeft[right[n_]] := n;
leftAndRightNumbers[n_List] := Join@@{n,moveNumberRight/@n,moveNumberLeft/@n};
bareNumber[left[n_]]  := n;
bareNumber[right[n_]] := n;
bareNumber[n_] := n;


moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];
moveDiskLeft[Disk[{x_,z_},r_]] :=
Disk[{x-1,z},r];
moveNumberedDiskRight[n_->d_] := moveNumberRight[n]->moveDiskRight[d];
moveNumberedDiskLeft[n_->d_] := moveNumberLeft[n]->moveDiskLeft[d];


getDisk[n_,run_] := If[
KeyExistsQ[run["CurrentDisks"],n],run["CurrentDisks"][n]
,If[KeyExistsQ[run["PastDisks"],n],run["PastDisks"][n],
Missing[StringTemplate["No disk ``"][{n}]]]
];
getDisk[right[n_],run_] := moveDiskRight[getDisk[n,run]];
getDisk[left[n_],run_] := moveDiskLeft[getDisk[n,run]];

diskIsLeft[Disk[{x_,z_},r_]] :=x<-1/2
diskIsRight[Disk[{x_,z_},r_]] :=x>1/2
diskIsNormalised[d_] := (! diskIsLeft[d]) && (! diskIsRight[d]);

diskAndVisibleCopies[Disk[{x_,z_},r_]] := {Disk[{x,z},r],If[x+r>1/2,moveDiskLeft[Disk[{x,z},r]],Nothing[]],If[x-r<-1/2,moveDiskRight[Disk[{x,z},r]],Nothing[]]};

nextRadius[run_] := Module[{highestZ},
highestZ=Max@Map[diskZ,Values@run["CurrentDisks"]];
run["Arena"]["rFunction"][highestZ]
];
nextDiskNumber[run_] := Max@Keys[run["CurrentDisks"]]+1;nextChainNumber[run_]:= Max[Keys[run["CompletedChainGraphs"]]]+1;


(* ::Input::Initialization:: *)
currentSupportDisks[run_,nextR_] :=  Module[{chain,lefts,rights},
chain = VertexList@Last@run["CompletedChainGraphs"];
chain = Join[chain,run["CurrentChain"]];
chain = SortBy[chain,diskX[getDisk[#,run]]&];
lefts = Map[moveNumberedDiskLeft[#->getDisk[#,run]]&,chain];
lefts = First /@ Select[lefts,diskRightX[Last[#]]+nextR>= -1/2 &];
rights =  Map[moveNumberedDiskRight[#->getDisk[#,run]]&,chain];
rights =First /@ Select[rights,diskLeftX[Last[#]]-nextR<= 1/2 &];
DeleteDuplicates@Join[lefts,chain,rights]
]

diskPairCanSupport[run_,nextR_,n1_,n2_] := (*
diskRightX[getDisk[n1,run]] + 2 * nextR <= diskRightX[getDisk[n2,run]] *)
diskLeftX[getDisk[n2,run]]-diskRightX[getDisk[n1,run]]<= 2*nextR



(* ::Input::Initialization:: *)
potentialHorizontalOverlaps[run_,nextR_] := Module[{supportDisks,supportPairs,can},
supportDisks = currentSupportDisks[run,nextR];

supportPairs = {};
For[i=1,i< Length[supportDisks],i++,
For[j=i+1,j<= Length[supportDisks],j++,
can = diskPairCanSupport[run,nextR,supportDisks[[i]],supportDisks[[j]]];

If[can,
supportPairs = Append[supportPairs,{supportDisks[[i]],supportDisks[[j]]}]
]
]
];

supportPairs

];

extendDisksRight[run_,nextR_] := Module[
{extendedDisks,extendedDisksRight},
extendedDisks= run["CurrentDisks"];
extendedDisksRight = 
Select[extendedDisks,diskLeftX[#]+1     <= 1/2 +nextR&];
extendedDisksRight = Association[Map[moveNumberedDiskRight,Normal[extendedDisksRight]]];
extendedDisksRight

];
extendDisksLeft[run_,nextR_] := Module[
{extendedDisks,extendedDisksLeft},
extendedDisks= run["CurrentDisks"];

extendedDisksLeft = Select[extendedDisks,diskRightX[#]-1 + nextR >=- 1/2 &];
extendedDisksLeft = Association[Map[moveNumberedDiskLeft,Normal[extendedDisksLeft]]];

extendedDisksLeft

];
extendDisksLeftRight[run_,nextR_]:= Module[{extendedDisks},
extendedDisks = 
Append[run["CurrentDisks"], extendDisksRight[run,nextR]];
extendedDisks = 
Append[extendedDisks, extendDisksLeft[run,nextR]];
extendedDisks 
];


(* ::Input::Initialization:: *)
initializeCurrentOverlaps[run_] := Module[{nextR,res},
nextR= nextRadius[run];

possibleOverlaps = potentialHorizontalOverlaps[run,nextR];
possibleOverlaps = Complement[possibleOverlaps,run["UsedOverlaps"]];
res=run;
res["CurrentOverlaps"]= possibleOverlaps;
res
];



(* ::Input::Initialization:: *)
disksMaximum[run_] := 
Max@Map[diskTopZ,run["CurrentDisks"]];

runCompletesArena[run_] := Module[{res},

If[run["Arena"]["ChainMax"]=="Fill",
res =disksMaximum[run]>run["Arena"]["CylinderLU"][[2]],
res = nextChainNumber[run] > run["Arena"]["ChainMax"];
];
res
];




executeRun[run_,chainMax_:Missing[]] := Module[{i,res},
res = run;
If[!MissingQ[chainMax],
res["Arena"]["ChainMax"]=chainMax];
Monitor[
For[i=1,i<= 500,i++,
res = completeChain[res];
If[runCompletesArena[res],Break[]];
];
,i
];
res
];

completeChain[run_] := Module[{res,i,complete=False},
res = run;

res = initializeCurrentOverlaps[res];

For[i=1,i<= 500,i++,

res= addNextDisk[res];

res = initializeCurrentOverlaps[res];
res = tryToCompleteCurrentChain[res];
complete = res["CurrentChainIsComplete"];
(*If[complete,Print["Completed chain ",
nextChainNumber[run],res["CurrentChainGraph"]]];
*)If[complete,Break[]];
temp = res;
];
If[!complete,
Print[StringTemplate["chain incomplete after `` iterations"][i]];
Abort[];
];



res = setUpNewChain[res];
res
];

setUpNewChain[run_] := Module[{res,chainNumber,completedChainGraph},

res = run;
completedChainGraph = res["CurrentChainGraph"];
chainNumber = nextChainNumber[res];

overlapStillPossible[{n1_,n2_}] :=
MemberQ[VertexList[completedChainGraph],n1] || 
MemberQ[VertexList[completedChainGraph],n2] ;
res["UsedOverlaps"]= Select[res["UsedOverlaps"],overlapStillPossible];


res["PastDisks"]= Append[res["PastDisks"],res["CurrentDisks"]];

res["CompletedChainGraphs"]= Append[res["CompletedChainGraphs"],
chainNumber->completedChainGraph];

res["CurrentDisks"]= KeyTake[
res["CurrentDisks"],res["CurrentChain"]];
res["CurrentChain"] = {};
res["CurrentOverlaps"] = {};


res["CurrentChainGraph"] = Graph[{}];

res

]


(* ::Input::Initialization:: *)
tryToCompleteCurrentChain[run_] := Module[{res,nodeList,lrNodes,lrCases,lrNodesAndCentral},
res = run;
res["CurrentChainIsComplete"]=False;
If[!ConnectedGraphQ[res["CurrentChainGraph"]],
Return[res]];


nodeList = VertexList@res["CurrentChainGraph"];
lrNodes = Cases[nodeList,left[_] | right[_]];
lrCases = Association@Map[#->MemberQ[nodeList,bareNumber[#]]&,lrNodes];
lrCases = Select[lrCases,TrueQ];

If[Length[lrCases]==0,Return[res]];
res["CurrentChainIsComplete"]=True;
lrNode=First[Keys[lrCases]];
path=First@FindPath[res["CurrentChainGraph"],lrNode,bareNumber[lrNode]];
res["CurrentChainGraph"]=subgraphPreservingCoordinates[res["CurrentChainGraph"],path];
unchainedDisks = Complement[nodeList,
path];

res["UnchainedDisks"] = Join[res["UnchainedDisks"] ,unchainedDisks];

Return[res];


];



(* ::Input::Initialization:: *)

addNextDisk[run_] := Module[{res,next,path,n,g},

next=findNextNormalizedDisk[run];
n= nextDiskNumber[run];
res= run;
res["CurrentDisks"] = Append[res["CurrentDisks"],n->next["Disk"]];

res["CurrentChain"] = Append[res["CurrentChain"],n];
res["CurrentChain"] = SortBy[res["CurrentChain"] ,diskX[getDisk[#,res]]&];

removeList = {next["RestsOn"] ,Reverse@next["RestsOn"],
moveNumberLeft/@next["RestsOn"],
moveNumberLeft/@ (Reverse@next["RestsOn"])
};
res["UsedOverlaps"] = Join[res["UsedOverlaps"],removeList];

g = res["ContactGraph"];

g = vertexAddWithCoordinates[g,n,diskXZ[getDisk[n,res]]];
g = vertexAddWithCoordinates[g,next["RestsOn"][[1]],diskXZ[getDisk[next["RestsOn"][[1]],res]]];
g = vertexAddWithCoordinates[g,next["RestsOn"][[2]],diskXZ[getDisk[next["RestsOn"][[2]],res]]];


g= EdgeAdd[g,
{next["RestsOn"][[1]] \[UndirectedEdge] n,
n \[UndirectedEdge] next["RestsOn"][[2]] }];

res["ContactGraph"]=g;
(*res = setGraphCoordinates[res];
*)
res["CurrentChainGraph"] = subgraphPreservingCoordinates[g,leftAndRightNumbers@res["CurrentChain"]];

res =initializeCurrentOverlaps[res];


res
];


(* ::Input::Initialization:: *)
vertexAddWithCoordinates[g_,v_,vxy_] := Module[{vc,res},
If[MemberQ[VertexList[g],v],Return[g]];
res = VertexAdd[g,v];
vc = AnnotationValue[g,VertexCoordinates];
vc = Append[vc,vxy];
res = Annotate[res,VertexCoordinates->vc];
res
]

subgraphPreservingCoordinates[g_,vList_] := Module[{res},
res = Subgraph[g,vList]
];


(* ::Input::Initialization:: *)
findNextNormalizedDisk[run_] := Module[{res},
res= findNextDisk[run];
If[diskIsLeft[res["Disk"]],
res["Disk"]=moveDiskRight[res["Disk"]];
res["RestsOn"]= Map[moveNumberRight,res["RestsOn"]]
];

If[diskIsRight[res["Disk"]],
res["Disk"]=moveDiskLeft[res["Disk"]];
res["RestsOn"]= Map[moveNumberLeft,res["RestsOn"]]
];
(*
Print["Adding ",nextDiskNumber[run], ": ",res];
*)
res

];

findNextDisk[run_] := Module[{nextR,locations,nextPair,nextDisk},
nextR= N@nextRadius[run];


locations = Association@Map[#->overlapLocations[#,nextR,run]&,run["CurrentOverlaps"]];
locations = DeleteMissing[locations];

locations = Select[locations,diskX[#]>=-1/2 && diskX[#]<=1/2 &];

locations = SortBy[locations,diskZ];

locations = deleteIntersectingDisks[run,locations,nextR];

If[Length[locations]==0,
Print["Can't find a location"];
Abort[];
];
locations= List@@First@Normal@locations;
{nextPair,nextDisk}=locations;
Return[<|"Disk"->nextDisk,"RestsOn"->nextPair|>]
];

dPrint[x__] := If[debug, Print[x]];

deleteIntersectingDisks[run_,locations_,nextR_] := Module[{extendedDisks,res},


extendedDisks = extendDisksLeftRight[run, nextR];
(*
tests = Map[ {#,extendedDisks}&,locations];
locationIntersectsDiskList[d_,diskList_] := Map[diskdiskIntersectionQ[d,#]&,diskList];
tests = Map[locationIntersectsDiskList[#[[1]],#[[2]]]&,tests];
tests = Map[Select[#,TrueQ]&,tests];

*)

locationIntersectsQ[d_] := 
Module[{vals},
vals = Map[diskdiskIntersectionQ[d,#]&,extendedDisks];
 vals
];

res = Select[locations,Not[Apply[Or,Values@locationIntersectsQ[#]]]&];

res
];

diskdiskIntersectionQ[Disk[xy1_,r1_],Disk[xy2_,r2_]]:= Norm[xy1-xy2,2] < (r1+ r2);

overlapLocations[{n1_,n2_},r_,run_] := Module[{res},
res = diskdiskUpperTouchingPoint[{getDisk[n1,run],getDisk[n2,run]},r];
If[MissingQ[res],Return[res]];
Disk[res,r]
];



(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= diskdiskTouchingPoint[pairDisks,r];
If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];

diskdiskTouchingPoint[pairDisks_,r_] := Module[{xy1,xy2,r1,r2,interdisk,sTriangle,triangle
,rTrianglePT,lTrianglePT,transform},
{{xy1,r1},{xy2,r2}}= List@@@ pairDisks;
interdisk = Norm[xy1-xy2];
If[interdisk > (r1+r) +( r2 + r),
Return[Missing["interdisk too large"]]];
(* if we knew r was decreasing could filter out this disk at this point *)

Off[SSSTriangle::tri];
sTriangle =SSSTriangle[r+r2,r+r1,interdisk];
On[SSSTriangle::tri];
If[Head[sTriangle]===SSSTriangle,
Return[Missing["not a triangle"]]
(*Abort[];*)
];
triangle = (List@sTriangle)[[1,1]];
transform =Composition[TranslationTransform[xy1],RotationTransform[{triangle[[2]]-triangle[[1]],xy2-xy1}]
];
rTrianglePT = (transform[triangle])[[3]];
lTrianglePT = (ReflectionTransform[RotationTransform[90 Degree][xy2-xy1],xy1])[rTrianglePT];
{rTrianglePT,lTrianglePT}
];

