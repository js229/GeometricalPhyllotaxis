(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

diskZ[Disk[{_,z_},_]] := z;
diskX[Disk[{x_,_},_]] := x;
diskRightX[Disk[{x_,_},r_]] := x+r;
diskLeftX[Disk[{x_,_},r_]] := x-r;

moveDiskRight[Disk[{x_,z_},r_]] :=
Disk[{x+1,z},r];

getDisk[n_,run_] := run["Chain"]["Disks"][n];
getDisk[right[n_],run_] := moveDiskRight[getDisk[n,run]];


nextRadius[run_] := Module[{highestZ},
highestZ=Max@Map[diskZ,Values@run["Chain"]["Disks"]];
run["Arena"]["rFunction"][highestZ]
];

initializeChainRun[run_] := Module[{nextR,extendedDisks,res},
extendedDisks= run["Chain"]["Disks"];
nextR= nextRadius[run];

disksMightOverlap = Select[extendedDisks,diskX[#]+1<= 1/2+nextR &];
disksMightOverlap = Join[Normal@extendedDisks,
KeyValueMap[right[#1]-> moveDiskRight[#2]&,disksMightOverlap]];

rightPossible[ n_-> d_Disk] := Module[{f},
f[x_] := diskX[x[[2]]]>diskX[d] &&
diskRightX[d]+2*nextR >= diskLeftX[x[[2]]];
Map[{n,First[#]}&,Select[ disksMightOverlap,f]]
];
possibleOverlaps = Flatten[Map[rightPossible,disksMightOverlap],1];
res=run;
res["Chain"]= Append[res["Chain"],
"Overlaps"->possibleOverlaps];
res
];
addNextDisk[run_] := Module[{next,path},
next=findNextDisk[run];
path= FindShortestPath[run["Chain"]["Graph"],next["RestsOn"][[1]],next["RestsOn"][[2]]];
path = UndirectedEdge@@@Partition[path,2,1];

res= run;
g= res["Chain"]["Graph"];
g =  EdgeDelete[g,path];
g= EdgeAdd[g,
{next["RestsOn"][[1]] \[UndirectedEdge] n,
n \[UndirectedEdge] next["RestsOn"][[2]] }];
res["Chain"]["Graph"]=g;

res
];

findNextDisk[run_] := Module[{nextR= nextRadius[run],locations,nextPair,nextCentre},
locations = Association@Map[#->overlapLocations[#,nextR,run]&,run["Chain"]["Overlaps"]];
locations = DeleteMissing[locations];
locations= List@@First@Normal@Sort@locations;
{nextPair,nextCentre}=locations;
Return[<|"Disk"->Disk[nextCentre,nextR],"RestsOn"->nextPair|>]
]

overlapLocations[{n1_,n2_},r_,run_] := Module[{},
diskdiskUpperTouchingPoint[{getDisk[n1,run],getDisk[n2,run]},r]
];



(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= diskdisktouchingPoint[pairDisks,r];
If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];

diskdisktouchingPoint[pairDisks_,r_] := Module[{xy1,xy2,r1,r2,interdisk,sTriangle,triangle
,rTrianglePT,lTrianglePT,transform},
{{xy1,r1},{xy2,r2}}= List@@@ pairDisks;
interdisk = Norm[xy1-xy2];
If[interdisk > (r1+r) +( r2 + r),Return[Missing[]]];
Off[SSSTriangle::tri];
sTriangle =SSSTriangle[r+r2,r+r1,interdisk];
On[SSSTriangle::tri];
If[Head[sTriangle]===SSSTriangle,
Return[Missing[]]
(*Abort[];*)
];
triangle = (List@sTriangle)[[1,1]];
transform =Composition[TranslationTransform[xy1],RotationTransform[{triangle[[2]]-triangle[[1]],xy2-xy1}]
];
rTrianglePT = (transform[triangle])[[3]];
lTrianglePT = (ReflectionTransform[RotationTransform[90 Degree][xy2-xy1],xy1])[rTrianglePT];
{rTrianglePT,lTrianglePT}
];

