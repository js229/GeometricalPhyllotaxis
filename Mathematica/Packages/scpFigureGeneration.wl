(* ::Package:: *)

(* ::Input:: *)
(*SetOptions[InputNotebook[],AutoGeneratedPackage->None];*)
(*left::usage = "Tag for disk copies outside of cylinder";*)
(*right::usage = "Tag for disk copies outside of cylinder";*)
(*hat::usage = "Tag for disk copies outside of cylinder";*)
(**)


(* ::Input:: *)
(*(* get the radius function right *)*)


(* ::Section:: *)
(*Styles and files*)


(* ::Input:: *)
(*runsToGenerate  = {"rcp-upto55-solo1","rcp-upto89-solo1","rcp-e55c","rcp-upto55-array","rcp-QSS","rcp-GHQ","rcp-Det813","rcp-Sch813"};*)
(*runsToGenerate  = {"rcp-GHQ"};*)
(*runsToGenerate  = {};*)


(* ::Input::Initialization:: *)
githubPath= PersistentSymbol["persistentGitHubPath","Local"];
AppendTo[$Path,FileNameJoin[{githubPath,"Packages"}]];
Needs["LatticePhyllotaxis`"];
Needs["DiskStacking`"];
Get["scpPaperStylings.m"]


(* ::Input::Initialization:: *)
gDrive = PersistentSymbol["persistentGDrive"];
runDirectory = FileNameJoin[{gDrive,"Work\\Textbook\\Stacked coin paper\\Mathematica\\Runs"}];
eSetDirectory = (* post processed runs, no real reason for this to be different from runDirectory *) FileNameJoin[{gDrive,"Work\\Textbook\\Stacked coin paper\\Mathematica\\Esets"}];

draftFigureDirectory = FileNameJoin[{gDrive,"Work\\Textbook\\Stacked coin paper\\DraftFigures"}];



getRunByTag[tag_] := Module[{file},
file = FileNameJoin[{runDirectory,StringJoin[tag,".mx"]}];
If[FileExistsQ[file],Return[Import[file]]];
Print["Can't load ", tag, " from ", file];
Abort[]
];





(* ::Input::Initialization:: *)



jParastichyColour[n_] := jStyle["ParastichyColour"][n];
jFont[n_] := {FontFamily->  jStyle["FontFamily"],FontSize-> n};
paraColours= <|Red-> jParastichyColour[1],Blue-> jParastichyColour[2]|>;
leftRightColours = <|"Left"-> jParastichyColour[1],"Right"-> jParastichyColour[2]|>;
jBaseStyle= jFont[12];

SetAttributes[jExport,HoldFirst];

jExport[fig_] := Module[{figname},
SetDirectory[draftFigureDirectory];
figname=SymbolName[Unevaluated[fig]];
Export[StringJoin[figname,".jpg"],fig,ImageResolution->300];Export[StringJoin[figname,".pdf"],fig,ImageResolution->300];
ResetDirectory[];
(*fig
*)];


(* ::Section:: *)
(*Multirun code*)


(* ::Input::Initialization:: *)
doOneRun[parameters_] := Module[{run},
run = DiskStacking`runFromLattice[parameters["Lattice"]];
run= readyRunFromParameter[run,parameters] ; 
run=doMonitoredRun[run];
saveRunByTag[run];
run
];
retrieveRFunction[savedRun_] := Module[{run,parameters},
parameters=savedRun["Arena"];
run = DiskStacking`runFromLattice[parameters["Lattice"]];
run= readyRunFromParameter[run,parameters] ; 
run["Arena"]["rFunction"]
];

restartOneRun[lastRun_] := Module[{run},
run=lastRun;
run = DiskStacking`restartRunFromRun[run];
run= readyRunFromParameter[run,lastRun["Arena"]] ; 
run=doMonitoredRun[run];
saveRunByTag[run];
run
]

doMonitoredRun[run_] := Module[{res},
SeedRandom[run["Arena"]["Run"]];
res=run;
monitorRun= res["Arena"]["Run"];
monitorPP = <|"Noise"->res["Arena"]["Noise"],"rSlope"->res["Arena"]["rSlope"]|>;
res = DiskStacking`executeRun[res]; 
res 
];


saveRunByTag[run_] :=  Module[{parameters,saveFile,saveRun,tag},
parameters=run["Arena"];
tag=parameters["Tag"];
If[MissingQ[tag],tag="runData"];
saveFile= FileNameJoin[ {runDirectory,tag <> ToString[parameters["Run"]] <> ".mx"}];
saveRun =<|"File"->saveFile,"Run"->run|>;
Export[saveFile,saveRun];
run
];


doRunSets[parameterSets_] := Module[{res,abortCheck,runSets,timing},
abortCheck[parameterSet_] := CheckAbort[doOneRun[parameterSet],Print["Abort running ",parameterSet["Run"]]; Missing[parameterSet["Run"]]];
monitorRunTotal = Length[parameterSets];
monitorRunNumber= 0;
{timing,res}= Timing[Monitor[runSets=Map[(monitorRunNumber++;abortCheck[#]&),parameterSets],{monitorRunTotal,monitorRunNumber,monitorRun,monitorPP}];];
runSets
];


runExtractNonOverlappingChains[file_] := Module[{res},
monitorFile=file;
res=Import[file]["Run"];
DiskStacking`postRunExtractNonOverlappingChains[res]
];


(* ::Input::Initialization:: *)
latestRadius[run_] := Last@Values[DiskStacking`runDisksRadius[run]];
latestCentre[run_] := Last@Values[DiskStacking`runDisksHeight[run]];

readyRunFromParameter[lastRun_,experimentParameters_] := Module[{runParameters,run,arena,initialRadius,finalRadius,initialZ,makef,finalZ,showArena},

(* set defaults *)
runParameters= <|
"rScale"->10,
"rSlope"->0.03,
"power"-> 1,
"Lattice"->LatticePhyllotaxis`latticeOrthogonal[{0,1}],
"zMax"->Missing[],
"runNumber"->1,
"diskMax"->\[Infinity],
"PostFixChains"->0,
"Run"->"",
"Noise"->Missing[]
|>;

runParameters= Append[runParameters,experimentParameters];
run=lastRun;

If[!KeyMemberQ[experimentParameters,"radiusFunctionParameters"],
run["Arena"] = createArena[run,runParameters]
,
run["Arena"] = createRFunctionArena[{latestCentre[run],latestRadius[run]},runParameters]
];
;
run
];

Clear[z,lookup];
createRFunctionArena[{initialZ_ ,initialRadius_},runParameters_] := Module[{arena,sectionStartRadius,sectionStartZ,functionCount,rFunctionPieces},

calcfunctionParameters[functionParameter_] := Switch[functionParameter["Type"],
"Constant",constFunctionParameters[functionParameter]
,
"LinearReduction",linearFunctionParameters[functionParameter]
,
"LinearCircumferenceIncrease",inverseLinearDecreaseFunctionParameters[functionParameter]
,
_,
 Print["Type not set ",functionParameter];Abort[];
];
inverseLinearDecreaseFunctionParameters[functionParameter_] := Module[{res,circumferenceStart,circumferenceScale,rStart,circumferenceEnd,rEnd,zEnd,func},
circumferenceStart = 1/sectionStartRadius;
circumferenceEnd = circumferenceStart* functionParameter["circumferenceScale"];
zEnd = sectionStartZ+functionParameter["zRange"];
res = Append[functionParameter,
<|"rStart"-> sectionStartRadius
,"rEnd"->  sectionStartRadius/functionParameter["circumferenceScale"]
,"rScale"-> 1/functionParameter["circumferenceScale"]
,"zStart"-> sectionStartZ
,"zEnd"-> zEnd|>
];
func = Function[{z},sectionStartRadius*(zEnd-sectionStartZ) / (-(z-zEnd) +(functionParameter["circumferenceScale"])*( z-sectionStartZ))];
res["rFunction"] = functionClosure[func];

sectionStartZ = res["zEnd"];
sectionStartRadius = res["rEnd"];
res
];
linearFunctionParameters[functionParameter_] := Module[{res,rStart,rEnd},
res = Append[functionParameter,
<|"rStart"-> sectionStartRadius,
"rEnd"-> sectionStartRadius/functionParameter["rScale"]
,"zStart"-> sectionStartZ|>
];
res = Append[res,linearFunctionProperties[ {res["rStart"],res["rEnd"]},res["rSlope"],sectionStartZ]];
sectionStartZ = res["zEnd"];
sectionStartRadius = res["rEnd"];
res
];
constFunctionParameters[functionParameter_] := Module[{res,finalRadius},
res = Append[functionParameter,
<|"rStart"-> sectionStartRadius
,"rEnd"-> sectionStartRadius
,"zStart"-> sectionStartZ
,"zEnd"-> sectionStartZ + functionParameter["ApproximateChains"]* 4* sectionStartRadius
|>];
res = Append[res,<|"rFunction"->Function[{z},Evaluate[sectionStartRadius]]|>];
sectionStartZ = res["zEnd"];
res
];
functionListToPieceWise[flist_] := Module[{piece,pieceFunction},
piece [z_] := KeyValueMap[{(lookup[#1]),#2["zStart"]<z< #2["zEnd"]}&,flist];
pieceFunction[z_] := Evaluate[Piecewise[piece[zq]] /. zq->z];
pieceFunction
];


sectionStartZ =  initialZ;
sectionStartRadius = initialRadius;
functionCount = 1;

arena = runParameters;
arena["rFunctionList"] = Association@Map[functionCount++->calcfunctionParameters[#]&,arena["radiusFunctionParameters"]];

bq=KeyValueMap[{(lookup[#1]),#2["zStart"]<z<= #2["zEnd"]}&,arena["rFunctionList"]];
bq = Prepend[bq,{arena["rFunctionList"][1]["rStart"],z<= arena["rFunctionList"][1]["zStart"]}];
bq = Append[bq,{Last[arena["rFunctionList"]]["rEnd"],z > (Last[arena["rFunctionList"]])["zEnd"]}];

rFunctionPieces = bq  /. lookup[i_] :> arena["rFunctionList"][i]["rFunction"][z];

arena["rFunctionPieces"] = rFunctionPieces ;
arena["rFunction"] := Function[{zq},Piecewise[arena["rFunctionPieces"]]/. z-> zq]; 
arena["zMax"] = (Last[arena["rFunctionList"]])["zEnd"]; 
arena

];






createArena[run_,runParameters_] := Module[{arena,initialRadius,finalRadius,initialZ,makef,finalZ,showArena},

(* create the r Function *)
initialRadius=latestRadius[run];
initialZ =  latestCentre[run];
finalRadius= initialRadius/runParameters["rScale"];

makef=powerFunctionProperties[ {initialRadius,finalRadius},runParameters["rSlope"],initialZ,
runParameters["power"]];
finalZ = makef["zEnd"];

arena=KeyDrop[runParameters,{"Lattice"}];
arena["rFunction"]= makef["Function"];
arena["zMax"]= finalZ + runParameters["PostFixChains"]* 4* finalRadius;
arena
];


linearFunctionProperties[ {rStart_,rEnd_},rSlope_,zStart_,power_:1] := Module[{zSlopeRange,zEnd,func,rDash,scaler},
rDash = -rSlope;
scaler = Sign[rDash]*(Abs[(zEnd-zStart) * rDash] )^ (power-1);
zEnd = zStart + ( (rEnd-rStart))/rDash ;

func = Function[{z},rStart+(((z-zStart) * Abs[rDash])^power)/scaler];
func  = functionClosure[func];
<|"rFunction"-> func, "zEnd"-> zEnd|>
]

powerFunctionProperties[ {rStart_,rEnd_},rSlope_,zStart_,power_] := Module[{zSlopeRange,zEnd,f,rDash,scaler},
rDash = -rSlope;
scaler = Sign[rDash]*(Abs[(zEnd-zStart) * rDash] )^ (power-1);
zEnd = zStart + ( (rEnd-rStart))/rDash ;

f = Function[{z}, rStart+ Piecewise[ {
{0,z< zStart}
,{(((z-zStart) * Abs[rDash])^power)/scaler, z< zEnd}
, { (((zEnd-zStart) *Abs[ rDash] ))^power/scaler,True}
}]];
f = functionClosure[f];
<|"Function"-> f, "zEnd"-> zEnd|>
]

functionClosure[f_] := Function[{z$},Evaluate[f[[2]]]]


(* ::Section::Closed:: *)
(*2 fig:scpNonOpposed Illustrative lattice plot*)


(* ::Input::Initialization:: *)

scpShowParastichyLines[lattice_,lineColourFunction_]  :=  Module[{ll,llines,paraset,plines,numbers,rise,divergence,glines},
ll =Take[Flatten[ LatticePhyllotaxis`latticeLabel[lattice]],2];
llines = Map[LatticePhyllotaxis`latticeParastichyLines[lattice,#]&,ll];
numbers= KeyValueMap[Style[Text[#1,#2],Background->White]&,KeyTake[lattice["namedLatticePoints"],Range[0,10]]];
rise= Translate[Arrow[{{lattice["namedLatticePoints"][1][[1]],lattice["namedLatticePoints"][0][[2]]},lattice["namedLatticePoints"][1]}],{0.05,0}];
divergence= {Arrow[{lattice["namedLatticePoints"][0],{lattice["namedLatticePoints"][1][[1]],lattice["namedLatticePoints"][0][[2]]}}]};
glines = {Line[{{-1/2,lattice["namedLatticePoints"][0][[2]]},{1/2,lattice["namedLatticePoints"][0][[2]]}}],
,Line[{{-1/2,lattice["namedLatticePoints"][1][[2]]},{1/2,lattice["namedLatticePoints"][1][[2]]}}]};
Graphics[{
{jStyle["CylinderColour"],LatticePhyllotaxis`latticeGraphicsCylinder[lattice]}
,{FaceForm[White],LatticePhyllotaxis`latticeCircles[lattice]/. Circle->Disk},
,{Thin,Gray,glines}
, {Thick,MapIndexed[{lineColourFunction[First[#2]],#1}&,llines]}
,{PointSize[Small],Point[LatticePhyllotaxis`latticePoints[lattice]]}
,Arrowheads[0.02],rise,divergence,
,numbers
,Text["Divergence \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)",{0.2,0},{0,1.5},Background->White]
,Text["Rise \!\(\*
StyleBox[\"h\",\nFontSlant->\"Italic\"]\)",{0.5,0.022},{-1.1,0},Background->White]
},PlotRange->{{-1/2,.6},{-0.05,0.4}}
,BaseStyle->Directive[FontFamily-> jStyle["FontFamily"],FontSize->Scaled[0.03]]
]
];

scpNonOpposed := Module[{lattice,dh},
dh=LatticePhyllotaxis`latticeDivergenceRiseForNonOpposedTC[{2,5}];
lattice = LatticePhyllotaxis`latticeFromDivergenceRise[dh, {-0.1,0.5}];

Legended[scpShowParastichyLines[lattice,jParastichyColour],LineLegend[{jParastichyColour[1],jParastichyColour[2]},{"2-parastichies","5-parastichies"},LabelStyle->Directive[FontFamily-> jStyle["FontFamily"],FontSize->Scaled[0.015]]]]
];





(* ::Input:: *)
(*jExport[scpNonOpposed]*)


(* ::Section::Closed:: *)
(*3 fig : scpVanIterson*)


(* ::Input::Initialization:: *)

viSwatch = <| "TouchingCircle"->  jParastichyColour[1]
,"OpposedTouchingCircle"-> jParastichyColour[1]
,"NonOpposedTouchingCircle"->jStyle["CylinderColour"]
,"FibonacciBranch"-> jParastichyColour[1]
,"NonFibonacciBranch"-> jStyle["CylinderColour"]
,"NonTouchingCircle"-> LightGray |>;

panelLabelBothSides [mn_,at_,scaling_:0.08] := Module[{obj,reflect},
reflect[{x_,y_}] := {1-x,y};
{panelLabel[mn,at,scaling],panelLabel[mn,reflect[at],scaling]}
];

panelLabel [{m_,n_},at_,scaling_:0.08] := Module[{textsize,obj},
textsize[{x_,y_}] := Scaled[scaling * Min[Sqrt[y],0.5]];
obj=Grid[
{{Style[StringTemplate["``,``"][m,n],jFont[textsize[at]]]}}
,Frame->None
];
Inset[obj,at]
];

scpTreePlot[mnPairs_,labelPairs_,scaling_,opts:OptionsPattern[]] := Module[{linelabels,hmax,plotRange,boundaries},

linelabels := Map[touchingCircleLabel,labelPairs];

hmax = 1.2;
plotRange = PlotRange  /. List@opts;

boundaries = {
{Thick,LightGray,Map[LatticePhyllotaxis`vanItersonTouchingCirclePrimaryNonOpposed,mnPairs]/. \[Infinity]-> plotRange[[2,2]]}
,{Thick,viSwatch["TouchingCircle"],Map[LatticePhyllotaxis`vanItersonTouchingCirclePrimaryOpposed,mnPairs]}
};
Graphics[
{  
{LightGray,Line[{{1,0},{1,hmax}}]}
,{boundaries}
,linelabels
},
Evaluate[FilterRules[{opts}, Options[Graphics]]]
]
];

pairsTodo[hmin_,imax_] := Module[{n,ntodo,hm,res,makeP},
ntodo[m_,hm_] := Ceiling[Sqrt[m^2+ 1/hm]];
makeP[i_,hm_] := Select[Table[{i,j},{j,i+1,ntodo[i,hm]}],CoprimeQ[i,#[[2]]]&];
res= Select[ Table[makeP[i,hmin],{i,imax}],Length[#]>0&];
res=Flatten[res,1];
res
];

 addSubTree[mnpairs_] := DeleteDuplicates@Flatten[Map[ {#,{#[[1]],#[[1]]+#[[2]]},{#[[2]],#[[1]]+#[[2]]}}&,mnpairs],1];

touchingCircleLabel[labelAssociation_] := Module[{mn,at,m,n,str1,gr,posx,posy},
mn= labelAssociation["Pair"];
{posx,posy}= labelAssociation["Position"];
If[posx=="Left",posx=1];
If[posx=="Right",posx=-1];
{m,n}= mn;
at =LatticePhyllotaxis`vanItersonRegionPoints[mn]["TouchingCircle"];
If[posy=="Terminal",at[[2]]= 0;posy=1];
str1 = Style[StringTemplate["``,``"][m,n],Background->None,jFont[12]];
gr  = Text[str1,at,{posx,posy}];
gr
];


(* ::Input:: *)
(**)


(* ::Input::Initialization:: *)
dh=LatticePhyllotaxis`latticeDivergenceRiseForNonOpposedTC[{2,5}];
nop25= N@ dh;

scpviTree := Module[{mnPairs,labelPairs,xcut,ymax},
mnPairs  = {{2,3},{2,5},{2,7},{3,4},{3,5},{3,8},{5,7},{5,8},{3,11},{8,11},{5,13},{8,13},{5,12},{7,12},{2,9},{7,9}};
labelPairs= {
<|"Pair"->{2,3},"Position"->{-2,-1}|>,
<|"Pair"->{2,5},"Position"->{-1,-1}|>,
<|"Pair"->{3,5},"Position"->{1,-1}|>,
<|"Pair"->{5,8},"Position"->{-1.2,-1.}|>,
<|"Pair"->{4,5},"Position"->{-2,-1}|>,
<|"Pair"->{2,7},"Position"->{-2.5,0}|>,
<|"Pair"->{5,7},"Position"->{1.5,0}|>,
<|"Pair"->{3,8},"Position"->{1.5,-.5}|>
};
xcut={0.348,0.45};
ymax =0.075;
Legended[Show[{scpTreePlot[ mnPairs,labelPairs,0.24
,PlotRange->{xcut,{-0.0,ymax}}
,Axes->True,AxesOrigin->{xcut[[1]],-0.0}
,AxesLabel->{"Divergence \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\)","Rise \!\(\*
StyleBox[\"h\",\nFontSlant->\"Italic\"]\)"},BaseStyle->jFont[12]
,Ticks->{{0.35,0.4,0.45},{0,0.025,0.05,0.075}}
,AspectRatio->Automatic
,PlotRangeClipping->True
,ImageSize->400
],
Graphics[{jParastichyColour[3],PointSize[Medium],Point[nop25]}]}],Placed[LineLegend[{Directive[Thick,LightGray],{Thick,viSwatch["TouchingCircle"]}},{"Non-opposed disk-lattices","Opposed disk-lattices"},LabelStyle->Directive[jFont[12]]],Scaled[{0.75,.9}]]
]
]


(* ::Input:: *)
(*(*scpVanIterson= GraphicsRow[{Image[viImage,ImageSize->150],scpviTree},ImageSize->550];*)
(**)*)
(*scpVanIterson=Show[scpviTree,ImageSize->400];*)
(**)
(*jExport[scpVanIterson]*)


(* ::Section::Closed:: *)
(*5 and 8 fig:scpDeterministicTransition and fig:scpParastichyCountsTo55*)


(* ::Subsection:: *)
(*Code to build  upto55 *)


(* ::Input::Initialization:: *)
expandParameterSets[parameterListAssociation_] := Module[{res,runCount=1,parameterNames,parameterLists,labelParameter},
parameterNames= Keys[parameterListAssociation];
parameterLists = Values[parameterListAssociation];
labelParameter[parameterList___] := Append[Association@Thread[parameterNames ->{parameterList}],"Run"->runCount++];
res=Flatten[Outer@@ Prepend[parameterLists,labelParameter]]
];



(* ::Input::Initialization:: *)

makescpParaTransitions55[] := (
pto55= expandParameterSets[<|"Tag"->{"rcp-upto55-solo"},"rSlope"->{0.03},"rScale"->{60},"PostFixChains"->{2},
"Noise"->Join[{0}],
"Lattice"->{LatticePhyllotaxis`latticeOrthogonal[{0,1},{0,2}]}|>];
monitorPP="Running";
doRunSets[pto55];
(* writes to "G:\\My Drive\\Work\\Textbook\\Stacked coin paper\\Mathematica\\Runs\\rcp-upto55-solo1.mx"
*)
);
makescpParaTransitions89[] := (
pto89= expandParameterSets[<|"Tag"->{"rcp-upto89-solo"},"rSlope"->{0.03},"rScale"->{100},"PostFixChains"->{2},
"Noise"->Join[{0}],
"Lattice"->{LatticePhyllotaxis`latticeOrthogonal[{0,1},{0,2}]}|>];

monitorPP="Running";
doRunSets[pto55];
(* writes to "G:\\My Drive\\Work\\Textbook\\Stacked coin paper\\Mathematica\\Runs\\rcp-upto89-solo1.mx"
*)
);




(* ::Input:: *)
(*If[MemberQ[runsToGenerate,"rcp-upto55-solo1"],makescpParaTransitions55[]];If[ MemberQ[runsToGenerate,"rcp-upto89-solo1"],makescpParaTransitions89[]];*)


(* ::Subsection:: *)
(*Graphics  shows*)


(* ::Input::Initialization:: *)

chainLines[run_,chainNumber_] := Module[{w},
w=run;
w["ContactGraph"]=run["RunChains"][chainNumber]["Chain"];
graphToContactLines[w,leftRightColours]
];

chainLineThickness= AbsoluteThickness[2];
contactLineThickness= AbsoluteThickness[.5];


(* ::Input::Initialization:: *)

scpExplain[run_,zRange_,toShow_,chainNumbers_,stackedDiskNumber_,chain_] := Module[{diskNumbers,disks,ffs,cylinder,stackedDisks,stackedRun,nextDisk,contacts,cylinderLU,diskDisks,diskShow,ghainLines,chainBox,g},
ffs= Directive[FaceForm[White],EdgeForm[Black]];
diskNumbers = DiskStacking`diskNumbersInRun[run];
disks =Association@Map[#->DiskStacking`getDiskFromRun[run,#]&,
diskNumbers];
If[MissingQ[stackedDiskNumber],
stackedDisks=disks;stackedRun=run;nextDisk=Nothing[];
,
stackedDisks=KeySelect[disks,#<= stackedDiskNumber&];
stackedRun= DiskStacking`pruneRunByDisks[run,{0,stackedDiskNumber}];
nextDisk =  disks[stackedDiskNumber+1]
];



cylinderLU = zRange;
cylinder = {jStyle["ParastichyColour"][3],Rectangle[{-1/2,cylinderLU[[1]]},{1/2,cylinderLU[[2]]}]};

diskDisks=Map[DiskStacking`diskAndVisibleCopies,Values@stackedDisks];
If[!MemberQ[toShow,"Circles"] || MemberQ[toShow,"Disks"],
diskShow= {}];
If[MemberQ[toShow,"Disks"],
diskShow={Directive[FaceForm[White],EdgeForm[None]],diskDisks}];
If[MemberQ[toShow,"Circles"],
diskShow={Directive[FaceForm[None],EdgeForm[Black]],diskDisks}];
If[MemberQ[toShow,"Circles"] && MemberQ[toShow,"Disks"],
diskShow={Directive[FaceForm[White],EdgeForm[Black]],diskDisks}];

contacts = graphToContactLines[stackedRun,leftRightColours];
ghainLines=Map[chainLines[run,#]&,chainNumbers];

chainBox = If[MissingQ[chain],Nothing[],{FaceForm[{Opacity[0.5],Gray}],EdgeForm[None],chainRectangle[chain]}];

g=Graphics[{
cylinder
,
diskShow
,{
{contactLineThickness,If[MemberQ[toShow,"Contacts"],contacts,Nothing[]]}}
,chainLineThickness,ghainLines
,{FaceForm[jParastichyColour[1]],EdgeForm[None],nextDisk}
,chainBox 
}
,Axes->False,PlotRangeClipping->True
,PlotRange->{{-1/2,1/2},cylinderLU}
]

];




(* ::Input::Initialization:: *)
graphToContactLines[run_,leftRightColours_] := graphToContactLines[run["ContactGraph"],run,leftRightColours];

graphToContactLines[g_,run_,leftRightColours_] := Module[{dlines,fsort,res},
dlines = Line/@Map[diskXZ[getDiskFromRun[run,#]]&,List@@@EdgeList[g],{2}];fsort[Line[{p1_,p2_}]] := If[First[p1]<First[p2],Line[{p1,p2}],Line[{p2,p1}]];dlines=Map[fsort,dlines];res = lineCylinderIntersectionColoured[#,leftRightColours]& /@dlines;
res
];


lineCylinderIntersectionColoured[Line[{{x1_,z1_},{x2_,z2_}}],leftRightColours_] :=
 Module[{slope,col},
slope= (z2-z1)/(x2-x1);
If[slope>0,col=leftRightColours["Left"],col=leftRightColours["Right"]];If[x1<-1/2,Return[
{col,
Line[{{-1/2, z2 - slope * (x2-(-1/2))},{x2,z2}}], Line[{{x1+1,z1},{1/2,z1+slope *( 1/2-(1+x1))}}]
}
]];
If[x2>1/2,Return[
{col,
Line[{{-1/2, z2- slope * (x2-1-(-1/2))},{x2-1,z2}}], Line[{{x1,z1},{1/2,z1+slope *( 1/2-(x1))}}]
}
]];
Return[{col,Line[{{x1,z1},{x2,z2}}]}] 
];
(*
diskAndVisibleCopies[Disk[{x_,z_},r_]] := {Disk[{x,z},r],If[x+r>1/2,moveDiskLeft[Disk[{x,z},r]],Nothing[]],If[x-r<-1/2,moveDiskRight[Disk[{x,z},r]],Nothing[]]};
*)



(* ::Input::Initialization:: *)
showZBar=False;
Clear[grainLines];
grainLines[run_,col_,zRange_,toShow_,chain_:Missing[],zBarRange_:Missing[]] := Module[{red,g,zTransitionRange,zBar,chainBox,centres,centrePoints},

(*zTransitionRange= Values[KeyTake[run["Arena"],{"rFixedBefore","rFixedAfter"}]];
*)
If[!Missing[zBarRange],
showZBar,zBar= {FaceForm[Gray],EdgeForm[None],Opacity[0.2],Rectangle[{-1/2,zBarRange[[1]]},{1/2,zBarRange[[2]]}]},zBar=Nothing[]];

g=graphToContactLines[run,leftRightColours];
chainBox = If[MissingQ[chain],Nothing[],{FaceForm[{Opacity[0.5],Gray}],EdgeForm[None],chainRectangle[chain]}];
centres= If[MemberQ[toShow,"Centres"],Map[DiskStacking`diskXZ[#Disk]&,Values[run["DiskData"]]],{}];
centrePoints= {PointSize[Small],Point[centres,VertexColors->White]};
centrePoints= Map[Inset[Graphics[{FaceForm[White],EdgeForm[None],Disk[]}],#,Center,0.005]&,centres];
red=Select[g,First[#]==col&];
Graphics[{zBar,contactLineThickness,red,centrePoints,chainBox},Axes->False,PlotRangeClipping->True
,PlotRange->{{-1/2,1/2},zRange}]
]

chainRectangle[chain_] := Rectangle @@{{-1/2,#[[1]]},{1/2,#[[2]]}}&@ MinMax@Map[AnnotationValue[{chain,#},VertexCoordinates][[2]]&,VertexList[chain]];

scpShowGrain[run_,zRange_,toShow_,mostRecentDisk_] := Module[{chain},
chain=run["RunChains"][mostRecentDisk]["Chain"];
GraphicsGrid[{{
panelInset[scpExplain[run,zRange,toShow,{mostRecentDisk},mostRecentDisk,chain],"a"]
,
panelInset[scpExplain[run,zRange,toShow,{},Missing[],chain],"b"]
},{
panelInset[grainLines[run,jParastichyColour[1],zRange,toShow,chain],"c"]
,
panelInset[grainLines[run,jParastichyColour[2],zRange,toShow,chain],"d"]
}}
]
];

panelInset[panel_,label_] := Show[panel,Graphics[Inset[Style[label,jFont[Scaled[.1]]],Scaled[{0,1}],Scaled[{0,1}],Background->White]]];



(* ::Subsection::Closed:: *)
(*fig : scpDeterministicTransition*)


(* ::Input:: *)
(*chainLineThickness= AbsoluteThickness[4];*)
(*contactLineThickness= AbsoluteThickness[1.5];*)
(*upto55= getRunByTag["rcp-upto55-solo1"]["Run"];*)
(**)
(*pun = DiskStacking`pruneRun[upto55,{14.75,15.7}];*)
(*cylinderLU={14.75,15.7}+{0.08,-0.08};*)
(**)
(*scpDeterministicTransition = scpShowGrain[pun,cylinderLU,{"Disks","Contacts","Centres"},199];*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*jExport[scpDeterministicTransition]*)
(**)


(* ::Subsection:: *)
(*8 fig:scpParastichyCountsTo55*)


(* ::Input::Initialization:: *)

chainStatistics[run_] := Module[{res,runChains,chainRadii,chainZ},
res=run;
runChains =res["RunChains"];
runChains  = Map[Append[#,<|"DiskNumbers"-> DeleteDuplicates[DiskStacking`bareNumber/@ VertexList[#Chain]]|>]&,runChains];
chainRadii[chain_] := Map[DiskStacking`diskR[res["DiskData"][#]["Disk"]]&,chain["DiskNumbers"]];
chainZ[chain_] := Mean@Map[DiskStacking`diskZ[res["DiskData"][#]["Disk"]]&,chain["DiskNumbers"]];
runChains  = Map[Append[#,<|"MeanZ"-> chainZ[#] |>]&,runChains];
runChains  = Map[Append[#,<|"MeanRadius"-> Mean[chainRadii[#] ]|>]&,runChains];
runChains = Map[KeyDrop[#,"Chain"]&,runChains];
res["RunChains"]=runChains;
res
];

pt[chain_] :={ {paraColours[RGBColor[1, 0, 0]],Point[{1/chain["MeanRadius"],chain["Parastichy"][RGBColor[1, 0, 0]]}]}
,{paraColours[RGBColor[0, 0, 1]],Point[{1/chain["MeanRadius"],chain["Parastichy"][RGBColor[0, 0, 1]]}]}
};

showParaTransitions[oChains_] := Module[{},
Legended[Graphics[{PointSize[Small],Map[pt,Values[oChains]]},
Ticks->{Automatic,Prepend[Table[Fibonacci[n],{n,7,11}],1]},
AxesLabel->{"\!\(\*SuperscriptBox[\(Radius\), \(-1\)]\)","Parastichy"},AxesStyle->{jFont[12],jFont[12]},
Axes->True,BaseStyle->jFont[12]
],Placed
[SwatchLegend[Directive[EdgeForm[None],FaceForm[paraColours[#]]]&/@{RGBColor[1, 0, 0],RGBColor[0, 0, 1]},{"Left parastichy count","Right parastichy count"},
LabelStyle->jFont[12]
],{0.25,0.8}]
]
];

(*chainRadiiPlot[runChains_] :=
ListPlot[Map[KeyTake[#,{"MeanZ","MeanRadius"}]&,runChains]];*)


(* ::Input:: *)
(*upto89=getRunByTag["rcp-upto89-solo1"]["Run"];*)
(*upto89RunChains = chainStatistics[upto89]["RunChains"];*)
(**)


(* ::Input:: *)
(*scpParastichyCountsTo89 = showParaTransitions[upto89RunChains];*)
(*jExport[scpParastichyCountsTo89]*)
(**)
(**)


(* ::Section:: *)
(*6 fig : scpConeTransformation *)


(* ::Subsection:: *)
(*Get run*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)
(*arena2= <|"runNumber"->1*)
(*,"Tag"->"radius-34bis-crecrease"*)
(*,"Run"->""*)
(*,"radiusFunctionParameters" -> {*)
(*<|"Type"->"LinearCircumferenceIncrease","circumferenceScale"->1.7,*)
(*"zRange"-> 0.1|>*)
(*,<|"Type"->"Constant","ApproximateChains"->1|>*)
(*,<|"Type"->"LinearCircumferenceIncrease","circumferenceScale"-> 0.9,"zRange"->0.02|>*)
(*,<|"Type"->"LinearCircumferenceIncrease","circumferenceScale"-> 0.4/0.9,"zRange"->0.15|>*)
(*,<|"Type"->"LinearCircumferenceIncrease","circumferenceScale"-> 0.2/(0.4/0.9),"zRange"->0.15|>*)
(*}*)
(*,"Noise"->0*)
(*,"Lattice"->LatticePhyllotaxis`latticeOrthogonal[{21,34},cylinderLU={-0.01,0.1}]*)
(*|>;*)
(*(**)
(*runCone2  = doOneRun[arena2];*)
(**)
(**)*)


(* ::Input:: *)
(**)
(**)


(* ::Input:: *)
(**)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*getf= retrieveRFunction[runCone] ; ht=runDisksHeight[runCone]; ra=runDisksRadius[runCone]; getr = Map[{ht[#],1/ra[#]}&,*)
(*Select[diskNumbersInRun[runCone],#>0&]];*)
(*Show[{Plot[1/getf[z],{z,0,1}],*)
(*ListPlot[getr,PlotStyle->Red]}]*)


(* ::Input:: *)
(* *)


(* ::Input:: *)
(**)


(* ::Subsection::Closed:: *)
(*Disk  map*)


(* ::Input::Initialization:: *)
diskTransform[{zMin_,zMax_}] := Module[{f},
f= Function[{xz},Module[{x,z,r},
{x,z}=xz;
r = zMax- z;
r= r/(zMax-zMin); (* outer ring radius 1 *)
r*{Cos[2 \[Pi] x],Sin [ 2 \[Pi] x]} 
]
];
f
];


(* ::Input::Initialization:: *)
makeDiskGraphics[run_] :=Module[{(*runDiskTransform,namedPolygons,namedType,namedPoints,colouredNodes,cropDisk,colouredPolygons,namedDiskNodes*)},
runDiskTransform := diskTransform[{stemParameters["ray"]["zStart"],stemParameters["inner"]["zEnd"]}];
namedDiskNodes = runTransformedNodes[run,runDiskTransform] ;
namedPolygons = namedPointsToVoronoiPolygons[namedDiskNodes];

namedType = nodeType /@  runTransformedNodes[run,Identity];
namedPoints = Point /@ runTransformedNodes[run,runDiskTransform];
colouredNodes= Association@Map[#->{nodeColour[namedType[#]],PointSize[Small],namedPoints[#]}&,Keys[namedPoints]];

cropDisk = {FaceForm[White],EdgeForm[White],MeshPrimitives[DiscretizeRegion[RegionDifference[Rectangle[1.2*{-1,-1},1.2*{1,1}],Disk[{0,0},1.02]]],2]};colouredPolygons =Map[{polygonColour[namedType[#]],EdgeForm[polygonBoundaryColour[namedType[#]]],namedPolygons[#]}&,
Keys@namedPolygons];

seedRun=DiskStacking`pruneRun[run,{stemParameters["seed"]["zStart"],stemParameters["seed"]["zEnd"]}];

seedParastichyLeft = Select[graphToContactLines[seedRun,leftRightColours],First[#]==leftRightColours[[1]]&];
seedDiskParastichy = seedParastichyLeft /. Line[line_]:> Line[Map[runDiskTransform,line]];
lColour = leftRightColours[[1]];
seedDiskParastichy = seedDiskParastichy /. lColour:>Directive[Opacity[0.5],leftRightColours[[1]]];

plotRange=1.02
*{{-1,1},{-1,1}};
diskShow  = Graphics[{
colouredPolygons
,seedDiskParastichy
,Values[colouredNodes]
,cropDisk
},
PlotRange->plotRange
]
];



runTransformedNodes[run_,transform_,bareOnly_:False] := Module[{g,nodeNames,namedNodes,namedDiskNodes},
g=run["ContactGraph"];
If[bareOnly,
nodeNames = diskNumbersInRun[run],
nodeNames = VertexList[g]
];

namedNodes = Association@Map[#->AnnotationValue[{g,#},VertexCoordinates]&,nodeNames];
namedNodes= Select[namedNodes,#=!= $Failed&];
namedDiskNodes = transform /@ namedNodes;
namedDiskNodes
];

namedPointsToVoronoiPolygons[namedPoints_] := Module[{voronoi,vPolygons,polygonToPoint},
voronoi= VoronoiMesh[Values[namedPoints]];
vPolygons = MeshPrimitives[voronoi,2];
polygonToPoint[polygon_] := Module[{f,node},
f=RegionMember[polygon];
node= First@Keys@Select[namedPoints,f];
node -> polygon
];
Association@Map[polygonToPoint,Take[vPolygons,All]]
];

namedPointsPeriodicToVoronoiPolygons[namedNodes_] := Module[{},
overlap=0.2;
leftNodes = KeyMap[left,Select[namedNodes,#[[1]]<=-0.5+overlap&]];
leftNodes = Map[#+{1,0}&,leftNodes];
rightNodes =  KeyMap[right,Select[namedNodes,#[[1]]>= 0.5 -overlap&]];
rightNodes = Map[#-{1,0}&,rightNodes];
vPoint = Join[namedNodes,leftNodes,rightNodes];
vPoly =namedPointsToVoronoiPolygons[vPoint];
nvPoly= KeySelect[vPoly,NumberQ];
nvPoly
];


(* ::Input::Initialization:: *)

baseColour =  <|
"cone"-> LightGray,
"bract"-> jParastichyColour[3],
"ray"->Darker[Yellow,0.1],
"seed" -> Lighter[ColorData["CoffeeTones"][0.3],0.9],
"inner"->Lighter[ColorData["CoffeeTones"][0.3],0.6]
|>;

polygonColour= baseColour;
polygonBoundaryColour = Map[None&,baseColour];
polygonBoundaryColour["seed"] = LightGray;

polygonColour3D = baseColour;
polygonColour3D["cone"] = Lighter[baseColour["bract"],0.2];

nodeColour = baseColour;
nodeColour["ray"] = White;
nodeColour["seed"] = ColorData["CoffeeTones"][0.3];

cylinderNodeColour = baseColour;
cylinderNodeColour["seed"] = nodeColour["seed"];
cylinderDiskColour = cylinderNodeColour;
cylinderDiskColour["seed"]= baseColour["seed"];
cylinderDiskColour["cone"]= White;
cylinderDiskBoundaryColour= Map[None&,baseColour];
cylinderDiskBoundaryColour["seed"]= LightGray;
cylinderDiskBoundaryColour["cone"]=LightGray;


(* ::Input::Initialization:: *)
nodeType[{x_,z_}] := 
Which[
z<stemParameters["cone"]["zEnd"],"cone"
,z<stemParameters["bract"]["zEnd"], "bract"
,z<stemParameters["ray"]["zEnd"], "ray"
,z<stemParameters["seed"]["zEnd"],"seed"
,z<\[Infinity],"inner"
, True, Missing[]
];


(* ::Input:: *)
(**)


(* ::Subsection:: *)
(*Cylinder*)


(* ::Input::Initialization:: *)
makeCylinderGraphics[run_] := Module[{},
namedPoints = Point /@ runTransformedNodes[run,Identity,bareOnly=True];
namedType = nodeType /@  runTransformedNodes[run,Identity];
colouredNodes= Association@Map[#->{cylinderNodeColour[namedType[#]],PointSize[Small],namedPoints[#]}&,Keys[namedPoints]];
namedDisks = runDisks[run];
colouredDisks= Association@Map[#->{
FaceForm[cylinderDiskColour[namedType[#]]]
,EdgeForm[cylinderDiskBoundaryColour[namedType[#]]]
,namedDisks[#]}&,Keys[namedDisks]];
textOffset[type_] := If[type==="bract",{-1,.75},{-1,0}];
partLabels =<|"cone"->"Uncommitted","bract"->"Bracts","ray"->"Ray florets","seed"-> "Seeds","inner"->"Unset seeds"|>;
partText =Style[KeyValueMap[Text[partLabels[#1],{0.55,Mean[{#2["zStart"],#2["zEnd"]}]},textOffset[#1]]&,stemParameters],jFont[12]];
cropRectangle = {FaceForm[White],EdgeForm[None],Rectangle[{1/2,-1},{2,10}]};
seedRun=DiskStacking`pruneRun[run,{stemParameters["seed"]["zStart"],stemParameters["seed"]["zEnd"]}];
seedParastichyLeft = Select[graphToContactLines[seedRun,leftRightColours],First[#]==leftRightColours[[1]]&];

Graphics[{Values@colouredDisks,seedParastichyLeft,cropRectangle,partText},PlotRange->{{-1/2,.9},{stemParameters["cone"]["zStart"],stemParameters["inner"]["zEnd"]}}]
];


(* ::Input:: *)
(*makescpConeTransformation :=Module[{},*)
(*runCone= getRunByTag["radius-34bis-crecrease"]["Run"];*)
(*stemParameters = runCone["Arena"]["rFunctionList"] ;*)
(*stemParameters = KeyMap[<|1->"cone",2->"bract",3->"ray",4->"seed",5->"inner"|>[#]&,stemParameters];*)
(*diskRun = DiskStacking`pruneRun[runCone,{stemParameters["bract"]["zStart"],stemParameters["inner"]["zEnd"]}];*)
(*diskShow :=makeDiskGraphics[diskRun];*)
(*cylinderRun = DiskStacking`pruneRun[runCone,{stemParameters["cone"]["zStart"],stemParameters["inner"]["zEnd"]}];*)
(*cylinderShow = makeCylinderGraphics[cylinderRun];*)
(* GraphicsColumn[{cylinderShow,diskShow},Frame->False]*)
(*];*)
(*scpConeTransformation=makescpConeTransformation*)
(*jExport[scpConeTransformation]*)
(**)


(* ::Subsection:: *)
(*Stem  map*)


(* ::Input:: *)
(*polygonTransform[p_Polygon,transform_]:= Module[{listTransform},*)
(*listTransform[x_] := Map[transform,x];*)
(*Polygon[listTransform /@ (List@@p)]*)
(*];*)


(* ::Input:: *)
(*makeStemGraphics[run_] := Module[{},*)
(*rzData = Transpose[{Values@runDisksHeight[run,bareOnly=True],Values@runDisksRadius[run,bareOnly=True]}];*)
(*rzFunction = Interpolation[rzData];*)
(*Off[InterpolatingFunction::dmval];*)
(**)
(*zFlatten[z_] := Module[{},*)
(*If[z<stemParameters["ray"]["rEnd"],Return[z]];*)
(*stemParameters["ray"]["rEnd"]+ (z - stemParameters["ray"]["rEnd"])/10*)
(*];*)
(**)
(*rzTransform  = Function[{xz},Module[{x,z,rScale},*)
(*{x,z}=xz;*)
(*rScale = rzFunction[z];*)
(*x = x/rScale;*)
(*{x,zFlatten[z]}*)
(*]*)
(*];*)
(*namedType = nodeType /@  runDisksDivergenceHeight[run,True];*)
(**)
(*cylinderNodes =  runDisksDivergenceHeight[run,True];*)
(*namedNodes = rzTransform /@ runDisksDivergenceHeight[run,True];*)
(*colouredNodes= Association@Map[#->{cylinderNodeColour[namedType[#]],PointSize[Small],Point[namedNodes[#]]}&,Keys[namedNodes]];*)
(**)
(*cylinderPolygons = namedPointsPeriodicToVoronoiPolygons[cylinderNodes];*)
(*stemPolygons = Map[polygonTransform[#,rzTransform]&,cylinderPolygons];*)
(*colouredPolygons =Map[{polygonColour[namedType[#]],EdgeForm[polygonBoundaryColour[namedType[#]]],stemPolygons[#]}&,*)
(*Keys@stemPolygons];*)
(* *)
(*(*namedDisks = runDisks[run];*)
(*colouredDisks= Association@Map[#->{*)
(*FaceForm[cylinderDiskColour[namedType[#]]]*)
(*,EdgeForm[cylinderDiskBoundaryColour[namedType[#]]]*)
(*,namedDisks[#]}&,Keys[namedDisks]];*)
(**)
(*seedRun=DiskStacking`pruneRun[run,{stemParameters["seed"]["zStart"],stemParameters["seed"]["zEnd"]}];*)
(*seedParastichyLeft = Select[graphToContactLines[seedRun,leftRightColours],First[#]==leftRightColours[[1]]&];*)
(**)*)
(*Graphics[{colouredPolygons,Values@colouredNodes}(*,PlotRange ->{{-70,70},{0,1}}*), AspectRatio->1,Axes->False]*)
(*];*)
(*makeStemGraphics[cylinderRun]*)


(* ::Input:: *)
(*makeStemGraphics3D[run_] := Module[{},*)
(*rzData = Transpose[{Values@runDisksHeight[run,bareOnly=True],Values@runDisksRadius[run,bareOnly=True]}];*)
(*minimumRadius = Min[Last/@rzData];*)
(*rzData = Map[{#[[1]],#[[2]]/minimumRadius}&,rzData];*)
(**)
(*rzFunction = Interpolation[rzData];*)
(*Off[InterpolatingFunction::dmval];*)
(**)
(*zFlatten[z_] := Module[{},*)
(*If[z<stemParameters["ray"]["zEnd"],Return[z]];*)
(*stemParameters["ray"]["zEnd"]+ (z - stemParameters["ray"]["zEnd"])/10*)
(*];*)
(**)
(**)
(*rz3Transform =  Function[{xz},Module[{x,z,stemRadius,theta},*)
(*{x,z}= xz;*)
(*stemRadius = 1/rzFunction[z];*)
(*theta = x * 2 \[Pi];*)
(*{stemRadius * Cos[theta],stemRadius*Sin[theta],zFlatten[z]}*)
(*]*)
(*];*)
(**)
(*namedType = nodeType /@  runDisksDivergenceHeight[run,True];*)
(**)
(*cylinderNodes =  runDisksDivergenceHeight[run,True];*)
(*namedNodes = rz3Transform /@ runDisksDivergenceHeight[run,True];*)
(*colouredNodes3D= Association@Map[#->{cylinderNodeColour[namedType[#]],PointSize[Small],Point[namedNodes[#]]}&,Keys[namedNodes]];*)
(**)
(*cylinderPolygons = namedPointsPeriodicToVoronoiPolygons[cylinderNodes];*)
(*stemPolygons = Map[polygonTransform[#,rz3Transform]&,cylinderPolygons];*)
(*colouredPolygons3D =Map[{polygonColour3D[namedType[#]],EdgeForm[polygonBoundaryColour[namedType[#]]],stemPolygons[#]}&,*)
(*Keys@stemPolygons];*)
(* *)
(**)
(*Graphics3D[{colouredPolygons3D,Values@colouredNodes3D},PlotRange->{0.13,0.26},BoxRatios->{1,1,1.5},ViewPoint->Front,Boxed->False]*)
(*];*)
(*(*makeStemGraphics3D[cylinderRun]*)*)


(* ::Input:: *)
(**)


(* ::Section::Closed:: *)
(*7 fig:scpMOSIhistogram*)


(* ::Text:: *)
(*from  textbook  code*)


(* ::Input::Initialization:: *)
countMOSI = {89,89,89,89,89,55,74,89,55,89,53,54,34,89,55,55,34,55,21,55,34,41,55,88,36,29,42,21,18,34,55,89,55,89,55,89,76,89,83,55,55,55,78,55,88,89,89,144,89,89,93,55,89,89,88,55,89,89,68,89,89,34,55,89,76,34,54,89,144,55,55,88,55,89,73,89,68,89,88,86,90,143,110,89,143,142,144,144,89,89,89,89,34,21,79,55,88,34,54,47,48,50,89,54,89,59,55,68,55,55,55,76,89,55,55,47,89,55,89,33,35,43,57,20,19,55,40,89,89,47,55,34,53,84,89,89,89,89,55,34,34,34,54,55,55,55,55,89,89,55,55,55,55,55,55,55,87,123,33,55,89,55,55,143,89,55,53,89,89,76,54,21,33,47,32,55,49,89,76,55,55,89,68,55,89,34,55,56,57,89,53,89,55,88,55,55,55,55,55,34,55,55,55,55,34,34,55,144,76,34,55,89,55,89,34,55,55,55,76,144,19,57,21,34,55,89,89,68,89,89,55,89,88,89,88,50,89,89,89,55,75,88,55,34,89,89,54,89,89,89,89,55,55,55,55,34,34,144,54,89,88,55,55,89,89,55,89,55,55,55,86,89,54,86,89,55,73,89,80,34,55,89,34,89,53,89,55,89,89,55,34,55,34,55,55,55,68,89,55,34,89,55,68,77,47,55,55,55,55,55,54,47,89,55,34,54,55,88,34,55,47,55,55,34,55,55,55,55,55,74,89,54,89,55,55,55,55,55,55,55,55,42,55,54,55,55,68,55,55,55,54,55,55,55,47,55,55,55,55,68,55,55,55,47,55,55,88,50,89,112,89,89,89,89,89,55,68,55,55,55,55,55,55,62,44,29,55,89,89,55,55,34,55,34,34,34,89,75,87,52,55,55,55,56,55,34,55,34,53,34,36,21,55,34,21,34,20,34,21,25,34,55,21,20,26,13,21,34,55,36,55,34,55,47,55,49,35,34,47,34,55,55,89,55,57,34,55,55,55,34,55,55,42,55,55,22,34,55,47,21,34,55,89,34,34,55,34,55,45,55,42,55,54,54,89,68,55,90,89,89,89,55,55,55,55,21,47,55,21,34,29,48,55,55,55,42,34,34,34,47,55,34,34,29,55,34,55,21,21,29,33,13,34,55,55,28,34,34,54,55,55,55,55,34,21,21,21,34,34,34,34,55,54,34,34,34,34,34,34,55,76,19,35,55,34,34,88,55,34,35,55,55,47,36,13,21,29,34,32,56,47,36,34,55,42,34,55,21,34,54,56,34,55,34,34,34,34,34,21,34,34,34,34,21,21,34,47,21,34,55,34,55,34,34,34,47,89,18,34,13,21,34,55,55,42,55,55,34,54,55,55,55,55,55,55,34,48,34,21,55,56,35,55,55,55,55,34,34,36,34,21,21,89,34,55,55,34,34,55,55,55,34,34,34,56,54,34,55,56,34,55,55,68,21,34,55,21,55,34,55,55,34,21,34,34,34,34,42,54,34,21,54,34,56,29,34,34,34,34,34,34,29,55,34,21,34,34,55,21,34,29,34,34,34,34,34,34,34,46,55,34,55,36,35,38,37,34,34,34,34,27,34,34,34,33,42,34,34,34,34,34,34,34,29,34,34,34,34,42,34,36,34,29,34,34,55,31,55,69,55,55,55,55,55,34,42,34,34,34,34,34,34,31,28,34,54,55,34,34,21,34,21,21,21,55,47,52,31};

fType[x_] := Which[
MemberQ[{13,21,34,55,89,144}-1,x],"Fibonacci \[PlusMinus]1",
MemberQ[{13,21,34,55,89,144}+1,x],"Fibonacci \[PlusMinus]1",
MemberQ[{1,4,5,9,14,23,37,60,97},x],"F4",
MemberQ[{1,3,4,7,11,18,29,47,76,123},x],"Lucas",
MemberQ[{2,4,6,10,16,26,42,68,110},x],"Fibonacci x2",
MemberQ[{1,2,3,5,8,13,21,34,55,89,144},x],"Fibonacci",
True,"Other"
];


scpPalette = <|
"Fibonacci"->Directive[FaceForm[None],EdgeForm[jStyle["ParastichyColour"][1]]]
,"Fibonacci x2"-> jStyle["ParastichyColour"][2]
,"Lucas"-> jStyle["ParastichyColour"][3]
,"F4" -> Directive[FaceForm[ jStyle["ParastichyColour"][4]],EdgeForm[{Black}]]
,"Fibonacci \[PlusMinus]1"-> jStyle["ParastichyColour"][5]
,"Other"-> jStyle["CylinderColour"]
|>;
bar[{spirals_,observed_}] := Module[{barColour},
barColour = scpPalette[fType[spirals]];
{barColour,Rectangle[ {spirals-0.45,0},{spirals+0.45,observed}]}
];

alabel ={"Parastichy number"," Seen"};
alabel = None;
legend =SwatchLegend[Values[scpPalette],Keys[scpPalette],LabelStyle->Directive[FontFamily-> jStyle["FontFamily"],FontSize->Scaled[0.02]]];
fticks = {{Automatic,None},{Automatic,{21,34,55,89,144}}};
frame ={{True,True},{True,True}};
fsize= Scaled[0.05];
scpHistogram1 :=Graphics[
{Map[bar,Tally[countMOSI]]},
Axes->True,
FrameTicks->fticks,AxesOrigin->{10,0},AspectRatio->1,
FrameLabel->alabel,Frame->frame,
LabelStyle->Directive[FontFamily-> jStyle["FontFamily"],FontSize->fsize]];





(* ::Input:: *)
(*scpMOSIHistogram:= Legended[Show[scpHistogram1,FrameLabel->{"Parastichy number","Occurrence"}],legend];*)
(*jExport[scpMOSIHistogram]*)


(* ::Section::Closed:: *)
(*9 & 10 runs to redo fig:scpTo55 and fig:scpAha, fig:scpDouble and fig:scpLucas Histograms  up  to  55*)


(* ::Input::Initialization:: *)


makeUpto55wxy := Module[{},
replicationCount=10;
noises =Join[{0},Table[0.01,replicationCount],Table[0.02,replicationCount],Table[0.05,replicationCount],Table[0.1,replicationCount]];
parsets = expandParameterSets[<|"Tag"->{"rcp-upto55-wxy"},"rSlope"-> {0.01,0.03,0.07,0.1,0.2,0.3},"rScale"->{60},"PostFixChains"->{10},
"Noise"->noises
,"Lattice"-> {LatticePhyllotaxis`latticeOrthogonal[{0,1},{0,2}]}|>];
doRunSets[parsets];
extractupto55;
];
extractupto55 := (
upto55wxyFiles =FileNames[FileNameJoin[{runDirectory,"rcp-upto55-wxy*.mx"}]];
upto55Results= Monitor[Map[runExtractNonOverlappingChains,upto55wxyFiles],monitorFile];
groupedupto55Results =GroupBy[upto55Results,KeyTake[#["Arena"],{"rSlope","Noise"}]&];
Export[FileNameJoin[{eSetDirectory,"rcp-esetupto55-wxy.mx"}],groupedupto55Results];
); 


(* ::Input:: *)
(*If[MemberQ[runsToGenerate,"rcp-upto55-array"],makeUpto55wxy];*)
(**)


(* ::Input:: *)
(**)


(* ::Subsection:: *)
(*Exploring  up to  55*)


(* ::Input:: *)
(**)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)
(*groupedupto55Results=Import[FileNameJoin[{eSetDirectory,"rcp-esetupto55-wxy.mx"}]];*)
(*upto55Show = KeySelect[groupedupto55Results,#rSlope< 0.15&];*)
(**)


(* ::Input::Initialization:: *)
histogramOverRun[run_] :=Module[{counts},
counts =Flatten[Values/@Values[run["ChainParastichies"]]];
counts= Flatten@ Normal[counts];
counts=GroupBy[counts, First->Last ,Total];
counts
];
histogramOverRuns[runList_] := Module[{counts},

counts=Map[histogramOverRun,runList];
counts =Flatten[Normal/@counts];
counts=GroupBy[counts, First->Last ,Total];
counts 
];
paraScaling[x_] := Log10[1+x];
paraScaling[x_] := x;
paraScaling[x_] := Log10[1+x];


countStyling[count_] := scpPalette[fType[count]];

histogramBars[runList_] :=  Module[{counts,bars},
If[MissingQ[runList],Return[{}]];
counts=histogramOverRuns[runList];
counts = N@ counts/Total[counts];
counts = paraScaling/@counts;
bars=KeyValueMap[{countStyling[#],Rectangle[{#1-0.4,0},{#1+0.4,#2}]}&,counts]
];
histogram[runList_] :=  Module[{counts},
Graphics[{jParastichyColour[1]
,histogramBars[runList]}
,PlotRange->{{12,56},{0,0.07}}
,PlotRangeClipping->True
,PlotRangePadding->None
,Ticks->{{13,21,34,55},None}
,BaseStyle->jFont[10]
,Axes->{True,False}
,AspectRatio->1
,Background->Lighter[Gray, 0.9]
]

];



(* ::Input::Initialization:: *)

panelEset[eset_] := Module[{noises,slopes,hpanel,titlerow,noiserow,changerow,panels},
noises= Sort@DeleteDuplicates@Map[#Noise&,Keys[eset]];
slopes = Sort@DeleteDuplicates@Map[#rSlope&,Keys[eset]];
hpanel[noise_,slope_] := Module[{res,highlight},
res=eset[<|"rSlope"->slope,"Noise"->noise|>];
highlight=(slope==0.03 && noise ==0.05);
res=Item[histogram[res],Background->If[highlight,Gray,None]];
res
];
hpanel[slope_] := Join[{slope},Map[hpanel[#,slope]&,noises]];
titlerow= {"","Noise \[Sigma]",Splice[Table[SpanFromLeft,Length[noises]]]};
noiserow= Join[{""},Map[Item[#,Frame->{True,False,False,False}]&,noises]];
changerow= {"Disk change \!\(\*
StyleBox[\"r\",\nFontSlant->\"Italic\"]\)" <> FromCharacterCode[39]};
panels = Grid[
Join[{titlerow,noiserow,changerow},Map[hpanel,slopes]]
,BaseStyle->jFont[12],Spacings->{.2,0}
]
];


(* ::Input:: *)
(*scpTo55 = panelEset[upto55Show];*)
(*jExport[scpTo55]*)


(* ::Input:: *)
(**)
(**)
(**)
(**)
(**)


(* ::Input:: *)
(*ahaRun= upto55Show[<|"rSlope"->0.03,"Noise"->0.05|>] ;*)
(*scpAha = Legended[*)
(*Show[histogram[ahaRun],Axes->{True,True},PlotRange->{{10,55},{0,0.04}},FrameLabel->{"Parastichy number","Frequency"},Frame->True,FrameTicks->{Automatic,Automatic},Background->None]*)
(*,Placed[legend,Right]];*)
(**)
(*xRange={19.5,57.5};*)
(*g2 = Graphics[*)
(*{Map[bar,Tally[countMOSI]]},*)
(*Axes->True,*)
(*AxesOrigin->{20,0},AspectRatio->1,PlotRangeClipping->True,*)
(*FrameLabel->{"Parastichy number","Observed"},Frame->frame,*)
(*BaseStyle->jFont[12],*)
(*PlotRange->{xRange,{0,25}}];*)
(*scpAhaPair = Legended[GraphicsRow[{g2,*)
(*Show[histogram[ahaRun],Axes->{True,True},PlotRange->{xRange,{0,0.04}},FrameLabel->{"Parastichy number","Simulated"},Frame->True,*)
(*BaseStyle->jFont[12],Background->None]*)
(*}],Placed[legend,Right]];*)
(*jExport[scpAhaPair]*)
(**)


(* ::Section::Closed:: *)
(*11 & 12   fig: scpDet813 and fig:scpSch813 *)


(* ::Input::Initialization:: *)
histobars[counts_] := KeyValueMap[{grainCountStyling[#1],Rectangle[{#1-0.4,0},{#1+0.4,#2}]}&,counts/Total[counts]];
paraScaling[x_] := Log10[1+x];
paraScaling[x_] := x;
textSize = jFont[9];
clabel[run_] := StringTemplate["r':`rSlope` \[Sigma]: `Noise`"][run["Arena"]]

grainCountStyling[count_] := scpPalette[fType[count]];

parastichyCounts[run_,col_] := Module[{paras,counts,clook},
paras=Map[#Parastichy&,run["RunChains"]];
If[col==={RGBColor[0, 0, 1],RGBColor[1, 0, 0]},
counts= Flatten@Values[Values /@ paras];
counts= Counts[counts]
,
clook= If[col==RGBColor[0, 0, 1],clook=RGBColor[1, 0, 0],clook=RGBColor[0, 0, 1]];
counts =Counts[Map[#[clook]&,paras]]
];
counts=paraScaling/@counts;
counts 
];
parastichyBars[run_,col_] := Module[{counts,bars},
counts =parastichyCounts[run,col]; 
bars= histobars[counts];
bars
]
parastichyBarGraph[run_,hRange_,col_] := Module[{g,axis},
If[Length[col]==0,
g={};axis=Transparent
,
g=parastichyBars[run,col];axis=Black];
Graphics[g,Axes->{True,False}
,AxesStyle->axis
,PlotRange->{hRange,{0,paraScaling[1]}},AspectRatio->1/2,
Ticks->{{5,8,13,21},{None}},
BaseStyle->textSize]
];

pcolumn[run_,hRange_,zRange_,col_] := GraphicsColumn[{
 parastichyBarGraph[run,hRange,col],
grainLines[run,paraColours[col],zRange,{}]
},Frame->None];

grainShow[run_,hRange_,zRange_] := GraphicsColumn[{clabel[run],GraphicsRow[{pcolumn[run,hRange,zRange,RGBColor[0, 0, 1]],pcolumn[run,hRange,zRange,RGBColor[1, 0, 0]]},Frame->None]},BaseStyle->textSize]




(* ::Subsection:: *)
(*scpDet813*)


(* ::Input::Initialization:: *)
makescpDet813 := (
d813b= expandParameterSets[<|"Tag"->{"rcp-d813-b"},"rSlope"->{0.05,0.1,0.5,1},"rScale"->{1.6},"PostFixChains"->{20},
"Noise"->{0},
"Lattice"-> {LatticePhyllotaxis`latticeOrthogonal[{8,13},{0,.4}]}|>];
doRunSets[d813b];);


(* ::Input:: *)
(*If[MemberQ[doRunSets,"rcp-Det813"],makescpDet813]*)


(* ::Input:: *)
(**)
(*(*det813= Map[Import[#]["Run"]&,FileNames[FileNameJoin[{runDirectory,"rcp-d813-b*"}]]];*)
(**)det813= Map[getRunByTag[#]["Run"]&,{"rcp-d813-b3","rcp-d813-b4"}];*)
(*showZBar=True;*)
(*contactLineThickness=AbsoluteThickness[0.5];*)
(*textSize= jFont[12];*)
(*paraScaling[x_] := Log10[1+x];*)
(*scpDet813=  GraphicsGrid[Partition[grainShow[#,{7,22},{0,2}]&/@det813,2]];*)


(* ::Input:: *)
(**)
(*jExport[scpDet813]*)
(**)


(* ::Subsection:: *)
(*scpSCH813*)


(* ::Input::Initialization:: *)
(* no replication here for example runs *)
pGHQ= expandParameterSets[<|"Tag"->{"rcp-GHQ"},"rSlope"->{0.1,0.5,1},"rScale"->{1.6},"PostFixChains"->{20},
"Noise"->{0.02,0.1},
"Lattice"-> {LatticePhyllotaxis`latticeOrthogonal[{8,13},{0,.4}]}|>];



(* ::Input:: *)
(*If[MemberQ[runsToGenerate,"rcp-Sch813"],doRunSets[pGHQ]]*)


(* ::Input:: *)
(*(*ghqFiles = FileNames[FileNameJoin[{runDirectory,"rcp-GHQ*.mx"}]];*)
(*ghqRuns= Map[Import[#]["Run"]&,ghqFiles];*)
(**)*)
(*ghqTags = {"rcp-GHQ2","rcp-GHQ2","rcp-GHQ3","rcp-GHQ4","rcp-GHQ5","rcp-GHQ6"};*)
(*ghqRuns = Map[getRunByTag[#]["Run"]&,ghqTags];*)
(*paraScaling[x_] := x;*)
(*gsch=Partition[grainShow[#,{7,22},{0,2}]&/@ghqRuns,2];*)
(*scpSch813=GraphicsGrid[gsch];*)
(*jExport[scpSch813]*)


(* ::Section::Closed:: *)
(*13 fig:scpColumn*)


(* ::Input::Initialization:: *)
grainColShow[run_,hRange_,zRange_] := GraphicsColumn[{GraphicsRow[
{pcolumn[run,hRange,zRange,RGBColor[0, 0, 1]],pcolumn[run,hRange,zRange,RGBColor[1, 0, 0]]
,qcolumn[run,hRange,zRange,Missing[]]},Frame->None]},BaseStyle->textSize];
qcolumn[run_,hRange_,zRange_,dRange_] := Module[{r},
If[MissingQ[dRange],r={},r=Rectangle[{dRange[[1]],zRange[[1]]},{dRange[[2]],zRange[[2]]}]];
GraphicsColumn[{
 parastichyBarGraph[run,hRange,{RGBColor[0, 0, 1],RGBColor[1, 0, 0]}],
Show[scpExplain[run,{0,2},{"Disks","Contacts"},{},Missing[],Missing[]]
,Graphics[{FaceForm[Opacity[0.1],Gray],r}]]
},Frame->None]
];
zColumn[run_,hRange_,zRange_,dRange_] := GraphicsColumn[{
 parastichyBarGraph[run,hRange,{}],
Show[scpExplain[run,{0,2},{"Disks","Contacts"},{},Missing[],Missing[]],
PlotRange->{dRange,zRange}]
},Frame->None];



(* ::Input::Initialization:: *)
pQSS= expandParameterSets[<|"Tag"->{"rcp-QSS"},"rSlope"->{0.1},"rScale"->{1.6},"PostFixChains"->{20},
"Noise"->{0.1},
"Lattice"-> {LatticePhyllotaxis`latticeOrthogonal[{8,13},{0,.4}]}|>];
(* this is the same as one of the GHQ runs...*)


(* ::Input:: *)
(*If[MemberQ[runsToGenerate,"rcp-QSS"],doRunSets[pQSS]];*)


(* ::Input:: *)
(*runQSS= getRunByTag["rcp-QSS1"]["Run"];*)


(* ::Input:: *)
(**)
(*scpColumn = grainColShow[runQSS,{12,22},{0,2}];*)
(*jExport[scpColumn]*)
(**)


(* ::Section:: *)
(*14 fig:scpfalling *)


(* ::Subsection:: *)
(*Restart   after   55  *)


(* ::Input:: *)
(*(* taken from a previous version of the scaling function *)*)
(*(* so we don't use restartOneRun *)*)
(*post55Arena = <|"Capped"->False,"zMax"->18.487149476879846`,"runNumber"->1,"diskMax"->\[Infinity],"Tag"->"rcp-upto55-solo-restart-power","rSlope"->0.03`,"rScale"->60,"PostFixChains"->2,"Noise"->0,"Run"->1,"InitialRadius"->0.5`,"rFixedBefore"->0,"rFunction"->Function[{h$},0.00833333333333336` +(\!\(\**)
(*TagBox[GridBox[{*)
(*{"\[Piecewise]", GridBox[{*)
(*{"0", *)
(*RowBox[{"h$", "<", "16.445908024560527`"}]},*)
(*{*)
(*SuperscriptBox[*)
(*RowBox[{"(", *)
(*RowBox[{*)
(*RowBox[{"(", *)
(*RowBox[{"h$", "-", "16.445908024560527`"}], ")"}], " ", "0.1`"}], ")"}], "2"], *)
(*RowBox[{"h$", "<", "18.487149476879846`"}]},*)
(*{*)
(*SuperscriptBox[*)
(*RowBox[{"(", *)
(*RowBox[{*)
(*RowBox[{"(", *)
(*RowBox[{"18.487149476879846`", " ", "-", "16.445908024560527`"}], ")"}], " ", "0.1`"}], ")"}], "2"], "True"}*)
(*},*)
(*AllowedDimensions->{2, Automatic},*)
(*Editable->True,*)
(*GridBoxAlignment->{"Columns" -> {{Left}}, "Rows" -> {{Baseline}}},*)
(*GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{1.}}},*)
(*GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}},*)
(*Selectable->True]}*)
(*},*)
(*GridBoxAlignment->{"Columns" -> {{Left}}, "Rows" -> {{Baseline}}},*)
(*GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{1.}}},*)
(*GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}}],*)
(*"Piecewise",*)
(*DeleteWithContents->True,*)
(*Editable->False,*)
(*SelectWithContents->True,*)
(*Selectable->False,*)
(*StripWrapperBoxes->True]\))],"rFixedAfter"->16.38888888888889`,"CylinderLU"->{16.445908024560527`,18.487149476879846`},"rFunctionType"->"DiskClosure"|>;*)


(* ::Input:: *)
(**)
(*If[MemberQ[runsToGenerate,"rcp-e55c"],*)
(*upto55=getRunByTag["rcp-upto55-solo1"]["Run"];*)
(*run = DiskStacking`restartRunFromRun[upto55];*)
(*run["Arena"] = post55Arena;*)
(*e55c=DiskStacking`executeRun[run];*)
(*(* e55c=restartOneRun[upto55]; *)*)
(*Export[FileNameJoin[{runDirectory,"rcp-e55c.mx"}],e55c]*)
(*];*)
(**)


(* ::Input::Initialization:: *)

debugGraph[g_] := Module[{res,nodes,edges,vc,es},
nodes= VertexList[g];
edges= EdgeList[g];
vc= Association@Map[#->AnnotationValue[{g,#},VertexCoordinates]&,nodes];
es= Association@Map[#->AnnotationValue[{g,#},EdgeStyle]&,edges];
Graph[nodes,edges,VertexCoordinates->Normal[vc],EdgeStyle->Normal[es]]
]

runToMappedGraph[run_,runMappingFunction_] := Module[{dzToDisk,g,vc},
g= debugGraph[run["ContactGraph"]];


vc=Association@Map[#->AnnotationValue[{g,#},VertexCoordinates]&,VertexList[g]];
vc= Normal@Map[runMappingFunction,vc];
AnnotationValue[g,VertexCoordinates]=vc;
AnnotationValue[g,EdgeStyle] = AnnotationValue[g,EdgeStyle]/. {Red->paraColours[Red],Blue->paraColours[Blue]};

g=Graph[g,VertexSize->Tiny,VertexStyle->Directive[EdgeForm[None],FaceForm[None]]];
g
];



dzToDisk[{d_,z_},{zMin_,zMax_},{capOuterRadius_,capInnerRadius_}] := Module[{\[Theta],\[Rho]},
\[Theta]= 2 \[Pi] d;
\[Rho]= capOuterRadius- (z-zMin)/(zMax-zMin) * (capOuterRadius-capInnerRadius);
\[Rho]*{Cos[\[Theta]],Sin[\[Theta]]}
];

runMapping[run_,zRange_,rRange_] := Module[{zMin,zMax,rMin,rMax,capOuterRadius,capInnerRadius},
{zMin,zMax}= MinMax[diskZ[#Disk]&/@ run["DiskData"]];
{zMin,zMax}= zRange;
{rMin,rMax}=  MinMax[diskR[#Disk]&/@ run["DiskData"]];
{rMin,rMax}= rRange;
capOuterRadius = 1;
capInnerRadius = capOuterRadius*(rMin/rMax);
Function[{dz},dzToDisk[dz,{zMin,zMax},{capOuterRadius,capInnerRadius}]]
];

edgesNotOfStyle[g_,styles_] := Module[{},
Select[EdgeList[g],!MemberQ[styles,AnnotationValue[{g,#},EdgeStyle]]&]
]

asymShow[run_,zRange_,voronoiRange_] := Module[{prunedRun},
prunedRun = DiskStacking`pruneRun[run,zRange];
g1=scpExplain[prunedRun,zRange,{"Circles","Disks","Contacts"},{},Missing[],Missing[]];
g2= grainLines[prunedRun,jParastichyColour[2],zRange,{},Missing[]];
g3= grainLines[prunedRun,jParastichyColour[1],zRange,{},Missing[]];
g123 = GraphicsRow[{g1,g2,g3}];
gshow[graph_] := Show[Graph[graph],Graphics[{FaceForm[None],EdgeForm[Gray],Disk[{0,0},1]}]];
rRange=  MinMax[diskR[#Disk]&/@ prunedRun["DiskData"]];

runMappingFunction =  runMapping[prunedRun,zRange,rRange];
graph = runToMappedGraph[prunedRun,runMappingFunction];
g4=gshow[EdgeDelete[graph,edgesNotOfStyle[graph,{paraColours[Blue],Blue}]]];
g5=gshow[EdgeDelete[graph,edgesNotOfStyle[graph,{paraColours[Red],Red}  ]]];

graphVoronoi = runToMappedGraph[ DiskStacking`pruneRun[run,voronoiRange],runMappingFunction];
g6= Show[showDiskMeshFromNodes[graphVoronoi],Graphics[{FaceForm[White],Disk[{0,0},First[runMappingFunction[{0,18}]]]}]];
g45 = GraphicsRow[{g6,g4,g5}];
GraphicsColumn[{g123,g45}]
];



(* ::Input::Initialization:: *)



(* ::Input:: *)
(**)


(* ::Input:: *)
(*e55c=getRunByTag["rcp-e55c"]; *)
(*scpFalling = asymShow[run=e55c,zRange={17.5,18},voronoiRange={17,18.5}];*)
(*jExport[scpFalling]*)


(* ::Input::Initialization:: *)
(*
showDiskMeshFromNodes[g_] := Module[{gstyle,nodes,vx,mask},
nodes=AnnotationValue[g,VertexCoordinates];
v=VoronoiMesh[nodes];
v=Region[Style[v,EdgeForm[Black],FaceForm[None]]];
mask= DiscretizeRegion@RegionDifference[Rectangle[{-2,-2},{2,2}],Disk[]];
mask=Region[Style[mask,White]];
gstyle=Graph[g,VertexSize->Large,VertexStyle->Gray];
Show[gstyle,v,mask,PlotRange->{{-1,1},{-1,1}}]
];
*)



(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input::Initialization:: *)
(*
stackGraphics[run_]:= Module[{disks,diskStyle,contactLines},
disks=Values[Map[#Disk&,run["DiskData"]]];
diskStyle[p:Disk[xz_,r_]] := {xStyle[nodeType[xz]],p};
contactLines= {,Last/@Select[graphToContactLines[run,leftRightColours],First[#]==&]};
 Graphics[{ffs,diskStyle/@disks,{contactLines}},PlotRange->{{-1/2,1/2},{4.3,5.1}},PlotRangeClipping->True]
];
*)


(* ::Input::Initialization:: *)
(*
diskGraphics[run_,transform_] := Module[{g,g2,lp,nodes,zRange,vMesh,runDiskTransform,colouredNodes},
g=run["ContactGraph"];
nodes=AnnotationValue[g,VertexCoordinates];
vMesh= voronoiMeshNoEdge[nodes,{stemParameters["zUpperRim"],stemParameters["zCutoff"]}];
lp=meshToTransformedGraphics[vMesh,transform];

colouredNodes= Map[{xStyle[nodeType[#]],PointSize[Medium],Point[transform[#]]}&,Select[nodes,!(MissingQ[nodeType[#]]
|| nodeType[#]=="Inner seeds") &]];

contactLines= Last/@Select[graphToContactLines[run,leftRightColours],First[#]==&];
diskContactLines ={,Map[meshToTransformedGraphics[#,transform]["Lines"]&,contactLines]};

g2=Graphics[{
{EdgeForm[None],FaceForm[White],lp["Polygons"]}
,lp["Lines"],diskContactLines,{FaceForm[White],Disk[{0,0},0.4]},
colouredNodes},Method->{"ShrinkWrap" -> True}];
g2
];
*)


(* ::Input::Initialization:: *)
(*
polygonTransform[Polygon[poly___],transform_] := (Polygon[Map[transform,poly]]);
lineTransform[Line[line___],transform_] := (Line[Map[transform,line]]);
*)


(* ::Input::Initialization:: *)
ffs= Directive[FaceForm[None],EdgeForm[Gray]];



(* ::Input::Initialization:: *)
(*
meshToTransformedGraphics[vMesh_,transform_] := Module[{lMesh,lMesh2,lines2,lines3,rmesh,polys2,polys3},
lMesh = MeshRegion[MeshCoordinates[vMesh],MeshCells[vMesh,1]];
lMesh2= DiscretizeRegion[lMesh,MaxCellMeasure\[Rule]{"Length"\[Rule].005}];
lines2= MeshPrimitives[lMesh2,1];
lines3= lineTransform[#,transform]&/@lines2;
rmesh =DiscretizeRegion[vMesh,MaxCellMeasure\[Rule]{"Length"\[Rule].01}];polys2= MeshPrimitives[rmesh,2];
polys3= Map[polygonTransform[#,transform]&,polys2];
<|"Lines"->lines3,"Polygons"->polys3|>
];
*)
