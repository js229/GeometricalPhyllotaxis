(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

Clear[coinD,coinZ];
coinNumber[{n_,coin_Disk}] := n;
bareCoinNumber[{n_,coin_Disk}] := bareNumber[n];
isPrincipal[coin_] := IntegerQ[coinNumber[coin]];
isBare[n_] := IntegerQ[n];
bareNumber[n_] := n;
bareNumber[left[n_]] := n;
bareNumber[right[n_]] := n;


highestCoinNumber[run_] :=  Max[Map[
bareNumber,Keys@run["State"][CoinAssociation]]];

getCoinFromRun[n_,run_] :=  Module[{coinSet,coinCollection,
coinAssociation,coin,cylinderCircumference},
coinAssociation = run["State"][CoinAssociation];
coin= coinAssociation[bareNumber[n]];
If[MissingQ[coin],Print["gCFR Can't find coin ", n,bareNumber[n],coin,coinAssociation];(*Abort[];*)Return[{}]];
cylinderCircumference =run["Arena"]["cylinderCircumferenceFunction"][coinH[coin]];

If[Head[n]== left,
coin  = coinTranslateL[coin,run["Arena"]["phi"],cylinderCircumference]];
If[Head[n]== right,
coin  = coinTranslateR[coin,run["Arena"]["phi"],cylinderCircumference]];

Return[coin];
];


getCoinAndCopiesFromRun[n_,run_] := Module[{nbare=bareNumber[n],coinset,coinCollection,res},
res = {getCoinFromRun[nbare,run],getCoinFromRun[left[nbare],run],
getCoinFromRun[right[nbare],run]};
res = Select[res,!MissingQ[#]&];
res

];


coinTranslateL[Disk[xy_,r_],phi_,cylinderCircumference_] := If[phi==0, Disk[xy-{cylinderCircumference,0},r],Disk[RotationTransform[2phi][xy],r]];
coinTranslateR[Disk[xy_,r_],phi_,cylinderCircumference_] :=  If[phi==0,Disk[xy+{cylinderCircumference,0},r],Disk[RotationTransform[-2phi][xy],r]];
coinTranslateL[{n_,coin_Disk},phi_,cylinderCircumference_] := {left[n],coinTranslateL[coin,phi,cylinderCircumference]};
coinTranslateR[{n_,coin_Disk},phi_,cylinderCircumference_] := {right[n],coinTranslateR[coin,phi,cylinderCircumference]};



coinH[Disk[xy_,r_]] := xy[[2]];
coinH[{n_,coin_Disk}] := coinH[coin];
coinD[Disk[xy_,r_]] := xy[[1]];
coinD[{n_,coin_Disk}] := coinD[coin];
coinR[Disk[xy_,r_]] := r;
coinR[{n_,coin_Disk}] := coinR[coin];
coinXY[{n_,Disk[xy_,r_]}] := xy;
coinXY[Disk[xy_,r_]] := xy;
coinZ[Disk[xy_,r_],phi_] := If[phi==0,xy[[2]],Sqrt[xy . xy]];
coinZ[{n_,coin_Disk},phi_] := coinZ[coin,phi];
coinTheta[Disk[{x_,y_},r_],phi_] := If[phi==0,2\[Pi] coinD[Disk[{x,y},r]],ArcTan[x,y]];
coinTheta[{n_,coin_Disk},phi_] := coinTheta[coin,phi];
coinDisk[{n_,coin_Disk}] := coin;
extendRadius[Disk[xy_,r_],inhibition_] := Disk[xy,r+inhibition];
extendRadius[{n_,coin_Disk},inhibition_] := extendRadius[coin,inhibition];


coinsOverZ[coinFront_,z_,phi_] :=  coinFront[[ Flatten@Position[Map[coinZ[#,phi]>z &,coinFront],True] ]];

coinDistance[Disk[xy1_,r1_],Disk[xy2_,r2_]] := Module[{v},v=xy1-xy2; Sqrt[v . v]];
coinDistance[{n1_,coin1_Disk},{n2_,coin2_Disk}] :=coinDistance[coin1,coin2];





whichMinConeRegionPoint[region_,phi_] := Module[{pts,hpts,x(*y,xy*)},
pts = MeshPrimitives[region,0];
If[phi==0,
hpts = Block[{y},pts /. Point[{x_,y_}] -> y],
hpts=  Block[{xy},pts /.Point[xy_] -> xy . xy]
];
pts[[Ordering[hpts][[1]]]]
];


nearestCoinPair[coin_,coinFront_] := Module[{coinDistances,nearestCoins},
coinDistances = Map[coinDistance[coin,#]&,coinFront];
nearestCoins = Take[coinFront[[ Ordering[coinDistances] ]],2];
nearestCoins
];

coinLowerPair[coin_,coinFront_] := Module[{nearestCoins ,res . nearestNumbers,angles},
nearestCoins = nearestCoinPair[coin,coinFront];
If[!isPrincipal[coin],
	nearestCoins= Select[nearestCoins, coinDistance[#,coin]< 2.1 coinR[#] &]];
nearestNumbers = Map[coinNumber,nearestCoins];
res = {coinNumber[coin],nearestNumbers};


angles = Map[coinPairAngle[coin,#]&,nearestCoins];
res ={coinNumber[coin],nearestNumbers,angles};
res
];



coinLowerNeighbourNumbers[state_,coin_,tolerance_] := Module[{coinDistances,nearestCoins ,coinFront,nearestNumbers},
(* only used when we don't have a chain *)
coinFront = Values[state[CoinAssociation]];
coinDistances =  Association@@Map[#->coinDistance[coin,#]&,coinFront];
coinDistances = Sort[coinDistances]-Min[coinDistances];
coinDistances = Select[coinDistances,#<tolerance &];
nearestCoins = Take[Keys[coinDistances],UpTo[3]];
nearestNumbers = Map[coinNumber,nearestCoins];
nearestNumbers
];


coinPairAngle[coinm_,coinn_] := Module[{xym,xyn,v,theta},

xym= coinXY[coinm];
xyn= coinXY[coinn];
v = xyn - xym;
theta = Apply[ArcTan,v];
theta = theta/(2\[Pi]);
If[theta<0,theta = theta+1];
theta =  1/4- theta ;
If[theta<0,theta=theta+1];
theta
];

thetac[angl_] := Module[{res},res=angl- 1/2; If[res<0,res=res+1];res];



(* ::Input::Initialization:: *)
(* not used by algo, but useful for ics and explains the cone geometry *)
toCone[{d_,h_},phi_] := Module[{},
If[phi==0,
{d,h},
(h ) * { Sin[ 2 d phi] ,Cos[ 2  d phi]}]
];



coinWithConeTranslations[nextCoin_,run_] := Module[{res,r,phi,cylinderCircumference},
r = run["Arena"]["rFunction"][run["State"][HighestCoinZ]];
r= coinR[nextCoin];
phi =  run["Arena"]["phi"];
cylinderCircumference =run["Arena"]["cylinderCircumferenceFunction"][coinH[nextCoin]];

res = {nextCoin};
If[coinD[nextCoin]+2 r > cylinderCircumference/2,
 res = Append[res,coinTranslateL[nextCoin,phi,cylinderCircumference]]
];
If[coinD[nextCoin] -2 r  < -cylinderCircumference/2,
 res = Append[res,coinTranslateR[nextCoin,phi,cylinderCircumference]]
];
res
];


iBoundary[coinFront_,distance_] := Map[extendRadius[#,distance]&,coinFront];


(* ::Input::Initialization:: *)
oldstylePlaceNextCoinCone[n_,coinFront_,coinRadius_,highestCoinZ_,phi_,cylinderLU_] := Module[{ib,iboundaryMesh,cyl,availableRegion,nextdh,d,h,nextCoin,x,y},
ib = iBoundary[coinFront,coinRadius];
iboundaryMesh = DiscretizeRegion@RegionUnion[ib];
cyl = coneRegion[phi,{highestCoinZ,cylinderLU[[2]]}];
availableRegion = RegionDifference[cyl,iboundaryMesh];
nextdh  = whichMinConeRegionPoint[availableRegion,phi]; (* returns Point *) 
nextCoin =  nextdh/. (Point[{x_,y_}] ->  {n,Disk[{x,y},coinRadius]});
If[Length[nextCoin!=2],Print["Can't place next coin with front\n",coinFront];Abort[]];
nextCoin 
]





(* ::Input::Initialization:: *)
moveNumberLeft[n_] := Which[Head[n]===left,Missing[],Head[n]=== right,n[[1]],True,left[n]];
moveNumberRight[n_] := Which[Head[n]===left,n[[1]],Head[n]=== right,Missing[],True,right[n]];


addInto[res_,n_,mangle_] := Module[{r},
r = res;
If[MissingQ[r[n]],r[n]={}];
AppendTo[r[n],mangle];
r[n]=SortBy[r[n],#[[2]]&];
r
];

symmetricAdd[angleResult_,n_,m_,angle_] := Module[{res},
(* n is the newly added coin so not left or right but m might be *)
res = angleResult;
res = addInto[res,n,{m,angle}];
res = addInto[res,m,{n,thetac[angle]}];

If[Head[m]=== right,
res = addInto[res,m[[1]],{ left[n],thetac[angle]}]
];
If[Head[m]=== left,
(*Print["Adding ", n , " connected to ",m];
*)res = addInto[res,m[[1]],{ right[n],thetac[angle]}]
];
res
];



(* ::Input::Initialization:: *)


coneRegion[phi_,{h0_,h1_}] := Module[{d1,d0},
If[phi==0,
Return[DiscretizeRegion[Rectangle[{-1/2,h0},{1/2,h1}]]]
];
{d1,d0}  = Map[DiscretizeRegion,{Disk[{0,0},h1, {\[Pi]/2 - phi, \[Pi]/2 + phi}],Disk[{0,0},h0]}];
Return[RegionDifference[d1,d0]]
];



(* ::Input::Initialization:: *)
edgesWithLR[n_,mList_] := Module[{newEdges},
newEdges = Map[{n,#}&,mList];
rightEdges = Map[moveNumberRight,Cases[newEdges,{a_,left[b_]}] ,{2}];
leftEdges = Map[moveNumberLeft,Cases[newEdges,{a_,right[b_]}] ,{2}];
newEdges = Join[newEdges,rightEdges,leftEdges];
newEdges = Join[newEdges,Reverse  /@ newEdges];
newEdges = DirectedEdge @@@newEdges;

DeleteDuplicates@newEdges
];



(* ::Input::Initialization:: *)

chainParastichyCount[front_,neighbourAssociations_] := Module[{pairs,lookup},
pairs = Map[bareNumber,front];
pairs = ( Partition[pairs,2,1] );
pairs = DirectedEdge @@@pairs;
pairs = Cases[pairs,Except[a_\[DirectedEdge]a_]];
lookup = KeyMap[Map[bareNumber,#]&,neighbourAssociations[DEdgeAngle]];
pairs =(Map[lookup[#]&,pairs]);
pairs = Map[If [#<1/4,Up,Down]&,pairs];
If[MissingQ[pairs],Return[Missing[]]];
Values@Counts[pairs]
];






(* ::Input::Initialization:: *)
rotateList[list_,element_] := Module[{res,pos},
If[!MemberQ[list,element],Return[list]];
pos = First@First@Position[list,element];
res = Join[Drop[list,pos-1],Take[list,pos-1]];
res
];



(* ::Input::Initialization:: *)
(* assumes each node sits on one to its left and one to its right, 
and we only allow going right *)
findGraphFront[firstNumber_,neighbourAssociations_] := Module[{lastNumber,nextCoinNumber,thisFront},

thisFront = {firstNumber};
For[k=0,k<50,k++,

lastNumber=  Last[ thisFront];
nextCoinNumber= nextInChainGraph[lastNumber,neighbourAssociations];
If[MissingQ[nextCoinNumber],Return[nextCoinNumber]];
thisFront = Append[thisFront,nextCoinNumber];
If[!IntegerQ[nextCoinNumber],
nextCoinNumber=bareNumber[nextCoinNumber];
thisFront = Append[thisFront,nextCoinNumber];
];
If[nextCoinNumber==firstNumber,
Break[]];
];
If[k==50,Print["fGF at 50 for",firstNumber];Return[Missing["k50"]]];


thisFront
];

nextInChainGraph[lastNumber_,neighbourAssociations_]  := Module[{allOutwardEdges,rightEdgesByAngle,nextEdge,nextCoinNumber},
allOutwardEdges=EdgeList[ neighbourAssociations[ContactGraph],bareNumber[lastNumber ]\[DirectedEdge] _  ];
rightEdgesByAngle = Sort[Association@@Map[#->neighbourAssociations[DEdgeAngle][#]&,allOutwardEdges]];
rightEdgesByAngle = Select[rightEdgesByAngle,#<1/2&];
If[Length[rightEdgesByAngle]==0,Return[Missing["noRightOutward"]]];
nextEdge =First@Keys[rightEdgesByAngle];
nextCoinNumber  = Last[nextEdge];
nextCoinNumber
];



(* ::Input::Initialization:: *)
addCoinsToState[state_,nextCoinSet_] := Module[{res},
res = state;

res[CoinAssociation] = Append[state[CoinAssociation],Association@Map[First[#]->#&,nextCoinSet]];
res[MostRecentCoin] =  Max@Map[bareCoinNumber,nextCoinSet];
res
];



(* ::Input::Initialization:: *)
updateNeighbourFunction[nextCoin_,nextCoinLowerNeighbours_,run_] := Module[
{n,coinCollection,newEdges,nextCoinSet,para2,nodeAssociation,thisChain,coinNumberPairAngle,newEdgeAngles,newRun},

n = coinNumber[nextCoin];
nextCoinSet = coinWithConeTranslations[nextCoin,run];

nodeAssociation =run["State"];
nodeAssociation = addCoinsToState[nodeAssociation,nextCoinSet];

newRun =run;
newRun["State"]= nodeAssociation; 
newEdges = edgesWithLR[n,nextCoinLowerNeighbours];

coinNumberPairAngle[coinm_,coinn_] := coinPairAngle[ getCoinFromRun[coinm,newRun],getCoinFromRun[coinn,newRun]];

newEdgeAngles =Association@@Map[#-> coinNumberPairAngle[ #[[1]],#[[2]]]&,newEdges];


nodeAssociation[DEdgeAngle]= Append[nodeAssociation[DEdgeAngle],newEdgeAngles];
nodeAssociation[ContactGraph]= EdgeAdd[nodeAssociation[ContactGraph],newEdges];
If[coinZ[nextCoin,run["Arena"]["phi"]]>nodeAssociation[HighestCoinZ],
nodeAssociation[HighestCoinZ]= coinZ[nextCoin,run["Arena"]["phi"]]
];


thisChain = findGraphFront[coinNumber[First[nextCoinSet]],nodeAssociation];



para2 = nodeAssociation[ChainsByCoinNumber];
para2 = Append[para2,coinNumber[nextCoin]->thisChain];
nodeAssociation[ChainsByCoinNumber] = para2;

para2 = nodeAssociation[Parastichy];
para2[coinNumber[nextCoin]] =chainParastichyCount[thisChain,nodeAssociation];
nodeAssociation[Parastichy] = para2;

Return[nodeAssociation];
];




(* ::Input::Initialization:: *)

chainRegionDistanceFunction[chainNumbers_,run_,dilation_:1] := Module[{chainAndLRcoins,disks,iboundaryMesh},
chainAndLRcoins= DeleteDuplicates[Flatten[Map[
(*getCoinAndCopiesByNumber[#,run["State"][Coins]]
*)getCoinAndCopiesFromRun[#,run]
&,chainNumbers],1]];
disks = Map[Last,chainAndLRcoins];
diskboxes =  Map[diskColumn,disks];
iboundaryMesh = DiscretizeRegion@RegionUnion[diskboxes];
RegionDistance[iboundaryMesh]
];

diskColumn[Disk[xy_,r_]] := Module[{xymin,xymax},
xymin= xy - {r,3 r};
xymax = xy+ {r,0};
RegionUnion[Disk[xy,r],Rectangle[xymin,xymax]]
];

nextCoinRadius[run_] := Module[{r,h1,h2},
h1= run["State"][HighestCoinZ];
r = run["Arena"]["rFunction"][h1];
r
];


(* ::Input::Initialization:: *)
oldstyleNextCoinAndContacts[n_,run_] := Module[{r,nextCoinByFront,phi},

r = run["Arena"]["rFunction"][run["State"][HighestCoinZ]];
phi = run["Arena"]["phi"];


nextCoinByFront =  oldstylePlaceNextCoinCone[  
n,
Values[run["State"][CoinAssociation]]
,r
,run["State"][HighestCoinZ]
,phi
, run["Arena"]["cylinderLU"]
];
<| "CoinNumber"->First[nextCoinByFront],"CoinDisk"->Last[nextCoinByFront],"CoinNeighbours"->Missing[]|>
];


(* ::Input::Initialization:: *)
(* function called by Chapter 8 code *)
stackFrontFromIC[icCoins_,arenaAssociation_] :=  Module[{arena,icRun},
arena = arenaAssociation;
If[MissingQ[arena["ArenaType"]],arena = Append[arena,"ArenaType"->
If[MissingQ[arena["phi"]] || arena["phi"]==0,"Cylinder","Cone"]]];
icRun = initializeRunFromIC[icCoins,arena];
executeStacking[icRun]
];

initializeRunFromIC[icCoins_,arenaAssociation_] := Module[
{run,highestCoinZ,nodeAssociation},

highestCoinZ = Max[Map[coinZ[#,arenaAssociation["phi"]]&,icCoins]];

nodeAssociation =  Association[
ContactGraph->Graph[{}]
,DEdgeAngle->Association[]
,Parastichy->Association[]
,ChainsByCoinNumber ->  Association[]
,InitialCoins->(*icCoins*) Association[]
,CoinAssociation->Association@Map[First[#]->#&,icCoins]
,MostRecentCoin -> First[Last[icCoins]]
,HighestCoinZ-> highestCoinZ];

run =<|"State"-> nodeAssociation,"Arena"->arenaAssociation|>;
run
];

restartRun[run_,extraCoinCount_] := Module[{res,arena},
res = pruneRunToLastChain[run];
arena = res["Arena"];
arena["coinMax"]=extraCoinCount;
arena["cylinderLU"]= {arena["cylinderLU"][[1]],100};
res["Arena"]=arena;

executeStacking[res]

];



(* ::Input::Initialization:: *)
executeStacking[icRun_] := Module[
{run,highestCoinZ,k,phi,parastichyTop},

run =icRun;

Monitor[
For[k=0,k<500,k++,
{tim,run } = Timing[ addNextCoinCone[run] ];
If[stoppingIndicator[run],Break[]]
],
monitorIndicator[run,tim]
];

run = makeRunContactGraphXY[run];
run
];

stoppingIndicator[run_] := Module[{highestCoinZ,arenaAssociation,nodeAssociation,res},
nodeAssociation=run["State"];
arenaAssociation=run["Arena"];highestCoinZ =  nodeAssociation[HighestCoinZ];

res = If[highestCoinZ+ 2 arenaAssociation["rFunction"][highestCoinZ]> (arenaAssociation["cylinderLU"])[[2]],True,False];
res = res || nodeAssociation[MostRecentCoin]>=run["Arena"]["coinMax"];
res
];

monitorIndicator[run_,tim_] := Module[{parastichyTop,highestCoinZ,
arenaAssociation,nodeAssociation},
nodeAssociation=run["State"];
arenaAssociation=run["Arena"];
parastichyTop = KeyTake[nodeAssociation[Parastichy],Last[Keys@nodeAssociation[Parastichy]]];
highestCoinZ =  nodeAssociation[HighestCoinZ];
{ProgressIndicator[
highestCoinZ,{0,(arenaAssociation["cylinderLU"])[[2]]}],
"coin"-> nodeAssociation[MostRecentCoin],
"h"->highestCoinZ,"r"->arenaAssociation["rFunction"][highestCoinZ], parastichyTop,tim}
];

currentChain[run_] := Module[{n,chainNumbers},
n= highestCoinNumber[run];
chainNumbers=run["State"][ChainsByCoinNumber][n];
chainNumbers
];

currentChainLR[run_] := Module[{chain},
chain = currentChain[run];
If[Last[chain]!=First[chain],
Print["chain unlooped"];Abort[]
];
chain=Drop[chain,1];
rightCoin=Select[chain,!isBare[#]&];
If[Length[rightCoin]!=1,
Print["multiple rights"];Abort[]];
rightCoin=bareNumber@First[rightCoin];
rightCoin=FirstPosition[chain,rightCoin,Missing[],1];
chain=RotateLeft[chain,rightCoin-1];
chain
];


addNextCoinCone[run_] := Module[
{chainNumbers,state,res},

chainNumbers=currentChain[run];
If[MissingQ[chainNumbers],
Print["Doing unchained at ",highestCoinNumber[run]];
state = unchainedNextState[run]
,
state = chainedNextState[run]
];
res =<|"State"-> state,"Arena"->run["Arena"]|>;
res
];

chainedNextState[run_] := Module[{r,chainNumbers,lowest,lowestOld,lowestNew,nextCoin,nextCoinLowerNeighbours,nAres},
chainNumbers=currentChain[run];

(*r= nextCoinRadius[run];lowestOld  = nextCoinAndContacts[chainNumbers,r,run];
*)
lowestNew = newnextCoinAndContacts[run];
(*Print[lowestNew];
*)lowest =lowestNew;
If[MissingQ[lowest],
Print["chain cannot be added to after coin ", highestCoinNumber[run] ];
Abort[]
];

nextCoin = {lowest["CoinNumber"],lowest["CoinDisk"]};
nextCoinLowerNeighbours = lowest["CoinNeighbours"];
nAres = updateNeighbourFunction[nextCoin,nextCoinLowerNeighbours,run];
nAres
];


(* ::Input::Initialization:: *)
shiftRight[left[n_]] := n;
shiftRight[n_] := right[n];
shiftLeft[right[n_]] := n;
shiftLeft[n_] := left[n];

calcShift[diskPair_] := Module[{res=diskPair},
res = Append[res,"Shift"->"None"];
If[First[diskPair["Point"]]<-1/2,
res["Point"]=diskPair["Point"]+{1,0};
res["Shift"] = "Right";
res["Pair"]= Map[shiftRight,res["Pair"]]
(*Print["shifting diskpair right:",diskPair]
*)];
If[First[diskPair["Point"]]> 1/2,
res["Point"]=diskPair["Point"]-{1,0};
res["Shift"] = "Left";
res["Pair"] = Map[shiftLeft,res["Pair"]]
];
res
];

allDistinctSortedPairs[list_] := DeleteDuplicates@(Sort/@Select[Tuples[list,2],!SameQ@@#&]);

nextCoinOptions[run_,r_] :=  Module[
{chainNumbers,localDisks,diskPairNumbers,yMax,extendedDisk,pointInDisks,
chainAndLeftNumbers,localAndLeftDisks
},
chainNumbers=currentChain[run];

(*Print["Options for coin ",highestCoinNumber[run]+ 1," r = ",r];
*)localDisks = Association@Map[#->Last@getCoinFromRun[#,run]&,chainNumbers];

chainAndLeftNumbers =chainNumbers;
chainAndLeftNumbers = DeleteDuplicates[Join[chainNumbers,
Map[left[bareNumber[#]]&,chainNumbers]]];
chainAndLeftRightNumbers = DeleteDuplicates[Join[chainNumbers,
Map[left[bareNumber[#]]&,chainNumbers],Map[right[bareNumber[#]]&,chainNumbers]]];
(*Print["chain:" ,chainNumbers];
Print["chainAndLeft:", chainAndLeftNumbers];
*)
localAndLeftDisks = Association@Map[#->Last@getCoinFromRun[#,run]&,chainAndLeftNumbers];

yMax= Max@Map[#[[1,2]]&,localDisks];
yMax = yMax - r; (* heuristic - to exclude intersections below the chain, but misses holes when r varying fast if too strict *)
yMax = -\[Infinity];

diskPairNumbers = allDistinctSortedPairs[chainAndLeftNumbers];

diskPairNumbers = Association@Map[#->Map[localAndLeftDisks,#]&,diskPairNumbers];
diskPairNumbers = Map[diskdiskUpperTouchingPoint[#,r]&,diskPairNumbers];
diskPairNumbers = DeleteMissing[diskPairNumbers];


diskPairNumbers = Select[diskPairNumbers,Last[#]>=yMax&];
diskPairNumbers = KeyValueMap[<|"Pair"->#1,"Point"->#2|>&,diskPairNumbers];
diskPairNumbers = Map[calcShift,diskPairNumbers];

diskPairNumbers=computeExclusions[diskPairNumbers,chainAndLeftRightNumbers,run,r] ; 
dp=diskPairNumbers;
diskPairNumbers = Select[diskPairNumbers,!TrueQ[#Excluded]&];
diskPairNumbers
];

computeExclusions[diskPairNumbersA_,chainAndLeftNumbers_,run_,r_] := Module[{diskPairNumbers=diskPairNumbersA,extendedDisk,pointInDisks},
diskPairNumbers = Map[Append[#,<|
"RestOfChain"->Complement[chainAndLeftNumbers,#Pair]|>]&,diskPairNumbers];
extendedDisk[number_] := extendRadius[getCoinFromRun[number,run],r];
pointInDisks[point_,diskNumbers_] := Module[{res},
res=Association@Map[#->RegionMember[extendedDisk[#],point]&,diskNumbers];
res= Select[res,TrueQ]
];
diskPairNumbers = Map[Append[#,"ExcludedBy"->pointInDisks[#Point,#RestOfChain]]&,
diskPairNumbers
];
diskPairNumbers = Map[Append[#,
"Excluded"->Or@@Values[#ExcludedBy]]&,diskPairNumbers];
diskPairNumbers
];
newnextCoinAndContacts[run_] := Module[{r,diskPairNumbers,lowestPair,lowerNeighbours},
r= nextCoinRadius[run];
diskPairNumbers =nextCoinOptions[run,r];
lowestPair = First@SortBy[diskPairNumbers,Last[#Point]&];


If[lowestPair["Shift"]=="None",
lowerNeighbours= lowestPair["Pair"],
(*Print["Shift at ",highestCoinNumber[run]+ 1,":",lowestPair];
*)lowerNeighbours= lowestPair["Pair"]
];
<| 
"CoinNumber"-> highestCoinNumber[run]+ 1
,"CoinDisk"-> Disk[lowestPair["Point"],r]
,"CoinNeighbours"-> lowerNeighbours |>
];





(* ::Input::Initialization:: *)
(* for some ics, couldn't guarantee the lower one is discardable,
but should be provided pattern is a dropped coin one *)
diskdiskUpperTouchingPoint[pairDisks_,r_] := Module[
{lrPoints},
lrPoints= diskdisktouchingPoint[pairDisks,r];
If[MissingQ[lrPoints],Return[lrPoints]];
Last[SortBy[lrPoints,N@Last[#]&]]
];

diskdisktouchingPoint[pairDisks_,r_] := Module[{xy1,xy2,r1,r2,interdisk},
{{xy1,r1},{xy2,r2}}= List@@@ pairDisks;
interdisk = Norm[xy1-xy2];
If[interdisk > (r1+r) +( r2 + r),Return[Missing[]]];
Off[SSSTriangle::tri];
sTriangle =SSSTriangle[r+r2,r+r1,interdisk];
On[SSSTriangle::tri];
If[Head[sTriangle]===SSSTriangle,
Return[Missing[]]
(*Abort[];*)
];
triangle = (List@sTriangle)[[1,1]];
transform =Composition[TranslationTransform[xy1],RotationTransform[{triangle[[2]]-triangle[[1]],xy2-xy1}]
];
rTrianglePT = (transform[triangle])[[3]];
lTrianglePT = (ReflectionTransform[RotationTransform[90 Degree][xy2-xy1],xy1])[rTrianglePT];
{rTrianglePT,lTrianglePT}
(*Graphics[{pairDisks,{Red,Disk[rTrianglePT,r]},{Blue,Disk[lTrianglePT,r]} ,{Yellow,transform[sTriangle]}}]
*)];



(* ::Input::Initialization:: *)
nextCoinAndContacts[chainNumbers_,r_,run_] := Module[{n,chainAndLR,touchingDisksXY
,chainRDF,diskChainDistance,disksNotOverlappingChain,lowerNeighbours},
n=highestCoinNumber[run]+ 1;
chainAndLR= DeleteDuplicates[Flatten[Map[
getCoinAndCopiesFromRun[#,run]
&,chainNumbers],1]];

touchingDisksXY = (Association@@Map[First[#]->Last[#]&,Map[Transpose,Subsets[chainAndLR,{2}]]]);
touchingDisksXY = Map[diskdisktouchingPoint[#,r]&,touchingDisksXY];
touchingDisksXY = Select[touchingDisksXY,Not[MissingQ[#]]&];
touchingDisksXY = Map[Last@SortBy[#,Last]&,touchingDisksXY];  (* assumes lower touching point no good *)

touchingDisksXY = Select[touchingDisksXY,First[#]>= -1/2 && First[#]<= 1/2 &];
(* now exclude the ones that overlap with the chain *)
chainRDF=  chainRegionDistanceFunction[chainNumbers,run];
diskChainDistance = Map[chainRDF,touchingDisksXY];
disksNotOverlappingChain = Keys@Select[diskChainDistance,#>=r&];
touchingDisksXY= KeyTake[touchingDisksXY,disksNotOverlappingChain];

(* exclude any that have support on the wrong side *)

cx[np_] := coinDisk@getCoinFromRun[np,run] ;
angleLR[angle_] := If[angle<1/2,right,left];
bothLLorRR  = Association@@KeyValueMap[ #1-> (
angleLR@coinPairAngle[cx[#1[[1]]],Disk[#2,1]]===
angleLR@coinPairAngle[cx[#1[[2]]],Disk[#2,1]]
)&,touchingDisksXY];
bothLLorRR = Keys@ Select[bothLLorRR,TrueQ];
touchingDisksXY = KeyDrop[touchingDisksXY,bothLLorRR];

If[Length[touchingDisksXY]==0,Return[Missing["No touching disks"]]];

touchingDisksXY  = SortBy[touchingDisksXY,Last];
lowerNeighbours = First[Keys[touchingDisksXY]];
touchingDisksXY = KeyTake[touchingDisksXY,{First[Keys[touchingDisksXY]]}];
<| "CoinNumber"-> n,
"CoinDisk"-> Disk[touchingDisksXY[lowerNeighbours],r],
"CoinNeighbours"-> lowerNeighbours |>
];



(* ::Input::Initialization:: *)
unchainedNextState[run_] := Module[{oldLowest,nextCoin,nextCoinLowerNeighbours,nAres},
oldLowest =oldstyleNextCoinAndContacts[highestCoinNumber[run]+ 1,run];
If[MissingQ[oldLowest],
Print["Can't go oldstyle"];
Abort[];
];
nextCoin ={oldLowest["CoinNumber"],oldLowest["CoinDisk"]};
nextCoinLowerNeighbours = 
coinLowerNeighbourNumbers[ run["State"],nextCoin,0.01];
nAres = updateNeighbourFunction[nextCoin,nextCoinLowerNeighbours,run];
Return[nAres]
];


makeRunContactGraphXY[run_] := Module[{newRun,g,graphNodeXY},
g= run["State"][ContactGraph];
graphNodeXY = Map[coinXY[getCoinFromRun[#,run]]&,VertexList[g]];
newRun=run;
newRun["State"][ContactGraph] = Graph[g,VertexCoordinates->graphNodeXY];
newRun
];



(* ::Input::Initialization:: *)
exampleRisingRun[s_,r_,coinMax_] := Module[{arenaAssociation,cylinderLU,rFunction,phi,cylinderCircumferenceFunction,d1,d1T,d2,icCoins,nANew},
cylinderLU = {0,20};
rFunction[h_]  := r * (  (1-1/10)  *(1-h/20) + 1/10) ;
phi = 0;
cylinderCircumferenceFunction[h_] :=  1; 

arenaAssociation = <| 
"rFunction"->rFunction
,"phi"->phi
,"coinMax"-> coinMax
,"cylinderCircumferenceFunction"->cylinderCircumferenceFunction 
,"cylinderLU"-> cylinderLU
|>;


d1 = Disk[toCone[{-1/2,cylinderLU[[1]]},phi] ,r]; 
d1T = Disk[toCone[{  1/2,cylinderLU[[1]]},phi] ,r]; 
d2 = Disk[toCone[{s,cylinderLU[[1]]},phi],r];
icCoins = {{-101,d1},{-102,d1T},{1,d2}};
stackFrontFromIC[icCoins,arenaAssociation]

];

makeProfile := (
kmax=50;r0=0.2;
exampleRisingRun[0.0,r0,kmax];
);




(* ::Input::Initialization:: *)
(* this is called _after_ the run has completed *) 
graphPolygonsFromRun [run_] :=  Module[{polys,nodes},
nodes = Select[VertexList[run["State"][ContactGraph]],IntegerQ];
polys= Map[graphPolygonsAboveNodeFromRun[run,#]&,nodes];
polys = Select[polys,Not[MissingQ[#]]&];
polys = Association@@polys;
polys
];


graphPolygonsAboveNodeFromRun[run_,node_] := Module[{edgePairs,xyN,res,state},

xyN[n_]  := (coinXY[getCoinFromRun[n, run]]);
state= run["State"];
edgePairs =edgesAboveNode[state,node];
If[Length[edgePairs]==0,Return[Missing[]]];
res = MapIndexed[<| "node"-> node,"nodeXY"->xyN[node],"h"->Last[xyN[node]],
"nodeCount"-> {node,First[#2]},"edgePair"-> #1|>&,edgePairs];
res = Association@Map[ #["nodeCount"]-> #&,res];
res =  Map[ polygonsFrom2EdgesRun[run,#]&,res];
res = Normal@res;
res
];

edgesAboveNode[state_,node_] := Module[{aboveNodeAngles},
edges = KeySelect[state[DEdgeAngle],First[#]==node&];
edges = Select[edges,#<1/4 || #>3/4 &];
If[Length[edges]<2,Return[{}]];
edges = Map[If[#>1/2,#-1,#]&,edges];
edges = Keys@Sort[edges];
edges = Partition[edges,2,1];
edges
];


polygonsFrom2EdgesRun[run_,poly_] := Module[{polys,brokenres,state},
state=run["State"];
polys= barePolygonsFrom2Edges[state,node=poly["node"],poly["edgePair"]];
If[MissingQ[polys],Return[polys]];
bC = brokenGraphContacts[state];
breakContacts[ab_] := If[MemberQ[Keys[bC],ab],bC[ab],ab];

polys  = Append[poly,computeCylinderEdgesRun[run,#,breakContacts]]& /@ polys;
polys = Select[polys,TrueQ[#closed]&];
If[Length[polys]!=1,Return[Missing["No unique closed poly"]]];
polys= First[polys];
polys
];

barePolygonsFrom2Edges[state_,node_,{edgeA_,edgeB_}] := Module[{bareA,bareB},

runContacts =bareGraphContacts[state];


a = Last[edgeA];b=Last[edgeB];
bareA= bareNumber[a];bareB=bareNumber[b];
If[MissingQ[runContacts[bareA]],Return[runContacts[bareA]]];
If[MissingQ[runContacts[bareB]],Return[runContacts[bareB]]];
aContacts = Complement[runContacts[bareA],{node}];
bContacts = Complement[ runContacts[bareB],{node}];

isTriangle = MemberQ[ aContacts,bareB];
If[isTriangle,
Return[{{node,bareA,bareB}}]];
fourthPoint = Complement[Intersection[aContacts,bContacts],{node}];
If[Length[fourthPoint] > 0,
rhombuses = Map[{node,bareA,#,bareB}&,fourthPoint];
Return[rhombuses]
];


aContactContacts = Flatten[Map[runContacts,aContacts]];
bContactContacts =Flatten[Map[runContacts,bContacts]];
fifthPoint = Complement[Intersection[aContactContacts,bContacts],{node,bareA,bareB}];
If[Length[fifthPoint]==1,
fourthPoint = Complement[Intersection[bContactContacts,aContacts],{node,bareA,bareB}];
Return[{{node,bareA,First@fourthPoint,First@fifthPoint,bareB}}]
];
Return[Missing["Hexagon or more"]]
];


bareGraphContacts[state_] :=  Module[{conts},
conts =GroupBy[EdgeList[state[ContactGraph]],First->Last];
conts = Map[ DeleteDuplicates@Map[bareNumber,#]&,conts];
conts =KeySelect[conts,IntegerQ];
conts 
];

brokenGraphContacts[state_] :=  Module[{conts},
conts = List@@@ EdgeList[state[ContactGraph]];
conts = Select[conts,!IntegerQ[Last[#]]&];
conts = Association@@ Map[ Map[bareNumber,#]-> # &,conts];
conts 
];

computeCylinderEdgesRun[run_,poly_,breakContacts_] := Module[{brokenres,res},
brokenres = Map[breakContacts,Partition[poly,2,1,1]];
res = <| "polygonBare"-> poly,"edges"-> brokenres|>;
res = derivedPolysFromRun[res,run]
];
 


derivedPolysFromRun[poly_,run_] := Module[{res,linePairs},
xyN[n_]  := coinXY[getCoinFromRun[n, run]];
res= poly;
linePairs =If[MissingQ[res["edges"]],res["edges"],Map[xyN,res["edges"],{2}]];
vector=  If[MissingQ[linePairs],linePairs,Map[ (Last[#]-First[#])&,linePairs]];
polygon=  If[MissingQ[vector],vector, Polygon[Accumulate@Prepend[Drop[vector,-1],{0,0}]]];
area= If[MissingQ[polygon],polygon,Area[polygon]];
closed = If[MissingQ[vector],vector,Abs@First[Apply[Plus,vector]] <  0.5];

res=Append[res,"line"-> If[MissingQ[linePairs],linePairs,Line[linePairs]]];
res=Append[res,"vector"->vector];
res =Append[res,"zeroPolygon"->polygon];
res = Append[res,"area"->area];
res= Append[res,"closed"->closed];

res
];



(* ::Input::Initialization:: *)
(*filterFourthPoint[state_,node_,bareA_,fourthPointList_,bareB_] := Module[{res},
res= Map[#->{node,bareA,#,bareB}&,fourthPointList];
(* multiple fourthpoints can happen when poly winds around cylinder *)
res= First[fourthPointList];
{res}
];*)
(*
barePolygonsFrom2EdgesRun[run_,node_,{edgeA_,edgeB_}] := Module[{bareA,bareB,state},
state=run["State"];
runContacts =bareGraphContacts[state];


a = Last[edgeA];b=Last[edgeB];
bareA= bareNumber[a];bareB=bareNumber[b];
If[MissingQ[runContacts[bareA]],Return[runContacts[bareA]]];
If[MissingQ[runContacts[bareB]],Return[runContacts[bareB]]];
aContacts = Complement[runContacts[bareA],{node}];
bContacts = Complement[ runContacts[bareB],{node}];

isTriangle = MemberQ[ aContacts,bareB];
If[isTriangle,
Return[{{node,bareA,bareB}}]];
fourthPoint = Complement[Intersection[aContacts,bContacts],{node}];
If[Length[fourthPoint] > 0,
rhombuses = Map[{node,bareA,#,bareB}&,fourthPoint];
Return[rhombuses]
];


aContactContacts = Flatten[Map[runContacts,aContacts]];
bContactContacts =Flatten[Map[runContacts,bContacts]];
fifthPoint = Complement[Intersection[aContactContacts,bContacts],{node,bareA,bareB}];
If[Length[fifthPoint]==1,
fourthPoint = Complement[Intersection[bContactContacts,aContacts],{node,bareA,bareB}];
Return[{{node,bareA,First@fourthPoint,First@fifthPoint,bareB}}]
];
Return[Missing["Hexagon or more"]]
];
*)


(* ::Input::Initialization:: *)

pruneNodeAssociation[nodeAssociation_,pruneNumbers_]  := Module[{res, bare},
res = nodeAssociation;
res[Parastichy]= KeyTake[res[Parastichy],pruneNumbers];
res[Parastichy]= Association[];
res[DEdgeAngle]= KeySelect[res[DEdgeAngle],MemberQ[pruneNumbers,First[#]]&];
res[InitialCoins]= Association[];

res[CoinAssociation] = KeyTake[res[CoinAssociation],pruneNumbers];
res[ChainsByCoinNumber]=  KeyTake[res[ChainsByCoinNumber],pruneNumbers];
res[ChainsByCoinNumber]=  KeyTake[res[ChainsByCoinNumber],Last@Keys@res[ChainsByCoinNumber]];
withLRNumbers = Join[pruneNumbers,left/@pruneNumbers,right /@ pruneNumbers];
res[ContactGraph] = Subgraph[res[ContactGraph],withLRNumbers,AnnotationRules->Inherited];
res
];

pruneRun[run_,pruneNumbers_] := Module[{prunedRun},
prunedRun = run;
prunedRun["State"] = pruneNodeAssociation[prunedRun["State"],pruneNumbers];
prunedRun
];

pruneRunByFunction[run_,pruneFunction_] := Module[{pruneNumbers},
pruneNumbers =  Map[bareCoinNumber , Keys[run["State"][CoinAssociation]]];
pruneRun[run,Select[pruneNumbers,pruneFunction[#]&]]
];

pruneRunToLastChain[run_] := Module[{chainNumbers},
chainNumbers=currentChain[run];
pruneRun[run,chainNumbers]
]
