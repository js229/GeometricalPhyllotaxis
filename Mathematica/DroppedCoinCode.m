(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetOptions[EvaluationNotebook[],AutoGeneratedPackage->Automatic];



(* ::Input::Initialization:: *)

Clear[coinD,coinZ];
coinNumber[{n_,coin_Disk}] := n;
bareCoinNumber[{n_,coin_Disk}] := bareNumber[n];
isPrincipal[coin_] := IntegerQ[coinNumber[coin]];
isBare[n_] := IntegerQ[n];
bareNumber[n_] := n;
bareNumber[left[n_]] := n;
bareNumber[right[n_]] := n;

lastCoinNumber[coinCollection_] := Max[Select[Map[coinNumber,coinCollection],IntegerQ]];

subsetCoinCollection[coinCollection_,coinNumbers_] := Select[coinCollection,MemberQ[coinNumbers,coinNumber[#] ]&];

getCoinByNumber[n_,coinCollection_] := Module[{coinSet},
coinSet = Select[coinCollection,coinNumber[#]==n &];
If[Length[coinSet]==0,Print["Can't find coin ", n];Return[{}]];
Return[First[coinSet]];
];

getCoinAndCopiesByNumber[ n_,coinCollection_] := Module[{nbare=bareNumber[n],coinset},
Select[coinCollection,MemberQ[{nbare,left[nbare],right[nbare]},coinNumber[#] ] &]
];

coinTranslateL[Disk[xy_,r_],phi_,cylinderCircumference_] := If[phi==0, Disk[xy-{cylinderCircumference,0},r],Disk[RotationTransform[2phi][xy],r]];
coinTranslateR[Disk[xy_,r_],phi_,cylinderCircumference_] :=  If[phi==0,Disk[xy+{cylinderCircumference,0},r],Disk[RotationTransform[-2phi][xy],r]];
coinTranslateL[{n_,coin_Disk},phi_,cylinderCircumference_] := {left[n],coinTranslateL[coin,phi,cylinderCircumference]};
coinTranslateR[{n_,coin_Disk},phi_,cylinderCircumference_] := {right[n],coinTranslateR[coin,phi,cylinderCircumference]};



coinH[Disk[xy_,r_]] := xy[[2]];
coinH[{n_,coin_Disk}] := coinH[coin];
coinD[Disk[xy_,r_]] := xy[[1]];
coinD[{n_,coin_Disk}] := coinD[coin];
coinR[Disk[xy_,r_]] := r;
coinR[{n_,coin_Disk}] := coinR[coin];
coinXY[{n_,Disk[xy_,r_]}] := xy;
coinXY[Disk[xy_,r_]] := xy;
coinZ[Disk[xy_,r_],phi_] := If[phi==0,xy[[2]],Sqrt[xy . xy]];
coinZ[{n_,coin_Disk},phi_] := coinZ[coin,phi];
coinTheta[Disk[{x_,y_},r_],phi_] := If[phi==0,2\[Pi] coinD[Disk[{x,y},r]],ArcTan[x,y]];
coinTheta[{n_,coin_Disk},phi_] := coinTheta[coin,phi];
coinDisk[{n_,coin_Disk}] := coin;
extendRadius[Disk[xy_,r_],inhibition_] := Disk[xy,r+inhibition];
extendRadius[{n_,coin_Disk},inhibition_] := extendRadius[coin,inhibition];


leftOf[n_,m_, coinCollection_,phi_] := If[phi>0,coinTheta[getCoinByNumber[n,coinCollection],phi] >  coinTheta[getCoinByNumber[m,coinCollection],phi],
 coinXY[getCoinByNumber[n,coinCollection]][[1]] < coinXY[getCoinByNumber[m,coinCollection]][[1]] ];

coinsOverZ[coinFront_,z_,phi_] :=  coinFront[[ Flatten@Position[Map[coinZ[#,phi]>z &,coinFront],True] ]];

coinDistance[Disk[xy1_,r1_],Disk[xy2_,r2_]] := Module[{v},v=xy1-xy2; Sqrt[v . v]];
coinDistance[{n1_,coin1_Disk},{n2_,coin2_Disk}] :=coinDistance[coin1,coin2];





whichMinConeRegionPoint[region_,phi_] := Module[{pts,hpts,x(*y,xy*)},
pts = MeshPrimitives[region,0];
If[phi==0,
hpts = Block[{y},pts /. Point[{x_,y_}] -> y],
hpts=  Block[{xy},pts /.Point[xy_] -> xy . xy]
];
pts[[Ordering[hpts][[1]]]]
];


nearestCoinPair[coin_,coinFront_] := Module[{coinDistances,nearestCoins},
coinDistances = Map[coinDistance[coin,#]&,coinFront];
nearestCoins = Take[coinFront[[ Ordering[coinDistances] ]],2];
nearestCoins
];

coinLowerPair[coin_,coinFront_] := Module[{nearestCoins ,res},
nearestCoins = nearestCoinPair[coin,coinFront];
If[!isPrincipal[coin],
	nearestCoins= Select[nearestCoins, coinDistance[#,coin]< 2.1 coinR[#] &]];
nearestNumbers = Map[coinNumber,nearestCoins];
res = {coinNumber[coin],nearestNumbers};


angles = Map[coinPairAngle[coin,#]&,nearestCoins];
res ={coinNumber[coin],nearestNumbers,angles};
res
];



coinLowerNeighbourNumbers[coin_,coinFront_,tolerance_] := Module[{nearestCoins ,res},

coinDistances =  Association@@Map[#->coinDistance[coin,#]&,coinFront];
coinDistances = Sort[coinDistances]-Min[coinDistances];
coinDistances = Select[coinDistances,#<tolerance &];
nearestCoins = Take[Keys[coinDistances],UpTo[3]];
(*If[!isPrincipal[coin],
	nearestCoins= Select[nearestCoins, coinDistance[#,coin]< 2.1 coinR[#] &]];
*)
nearestNumbers = Map[coinNumber,nearestCoins];

nearestNumbers

];


coinPairAngle[coinm_,coinn_] := Module[{xym,xyn,v,theta},

xym= coinXY[coinm];
xyn= coinXY[coinn];
v = xyn - xym;
theta = Apply[ArcTan,v];
theta = theta/(2\[Pi]);
If[theta<0,theta = theta+1];
theta =  1/4- theta ;
If[theta<0,theta=theta+1];
theta
];

thetac[angl_] := Module[{res},res=angl- 1/2; If[res<0,res=res+1];res];



(* ::Input::Initialization:: *)
(* not used by algo, but useful for ics and explains the cone geometry *)
toCone[{d_,h_},phi_] := Module[{},
If[phi==0,
{d,h},
(h ) * { Sin[ 2 d phi] ,Cos[ 2  d phi]}]
];



coinWithConeTranslations[nextCoin_,run_] := Module[{res,r,phi,cylinderCircumference},
r = run["Arena"]["rFunction"][run["State"][LastCoinZ]];
phi =  run["Arena"]["phi"];
cylinderCircumference =run["Arena"]["cylinderCircumferenceFunction"][coinH[nextCoin]];

res = {nextCoin};
If[coinD[nextCoin]+2 r > cylinderCircumference/2,
 res = Append[res,coinTranslateL[nextCoin,phi,cylinderCircumference]]
];
If[coinD[nextCoin] -2 r  < -cylinderCircumference/2,
 res = Append[res,coinTranslateR[nextCoin,phi,cylinderCircumference]]
];
res
];


iBoundary[coinFront_,distance_] := Map[extendRadius[#,distance]&,coinFront];

placeNextCoinCone[coinFront_,coinRadius_,lastCoinZ_,phi_,cylinderLU_] := Module[{ib,iboundaryMesh,cyl,availableRegion,nextdh,d,h,nextCoin,x,y},
ib = iBoundary[coinFront,coinRadius];
iboundaryMesh = DiscretizeRegion@RegionUnion[ib];
cyl = coneRegion[phi,{lastCoinZ,cylinderLU[[2]]}];
availableRegion = RegionDifference[cyl,iboundaryMesh];
nextdh  = whichMinConeRegionPoint[availableRegion,phi]; (* returns Point *) 
nextCoin =  nextdh/. (Point[{x_,y_}] ->  {lastCoinNumber[coinFront]+1,Disk[{x,y},coinRadius]});
If[Length[nextCoin!=2],Print["Can't place next coin with front\n",coinFront];Abort[]];
nextCoin 
]





(* ::Input::Initialization:: *)
moveNumberLeft[n_] := Which[Head[n]===left,Missing[],Head[n]=== right,n[[1]],True,left[n]];
moveNumberRight[n_] := Which[Head[n]===left,n[[1]],Head[n]=== right,Missing[],True,right[n]];


addInto[res_,n_,mangle_] := Module[{r},
r = res;
If[MissingQ[r[n]],r[n]={}];
AppendTo[r[n],mangle];
r[n]=SortBy[r[n],#[[2]]&];
r
];

symmetricAdd[angleResult_,n_,m_,angle_] := Module[{res},
(* n is the newly added coin so not left or right but m might be *)
res = angleResult;
res = addInto[res,n,{m,angle}];
res = addInto[res,m,{n,thetac[angle]}];

If[Head[m]=== right,
res = addInto[res,m[[1]],{ left[n],thetac[angle]}]
];
If[Head[m]=== left,
(*Print["Adding ", n , " connected to ",m];
*)res = addInto[res,m[[1]],{ right[n],thetac[angle]}]
];
res
];



(* ::Input::Initialization:: *)


coneRegion[phi_,{h0_,h1_}] := Module[{d1,d0},
If[phi==0,
Return[DiscretizeRegion[Rectangle[{-1/2,h0},{1/2,h1}]]]
];
{d1,d0}  = Map[DiscretizeRegion,{Disk[{0,0},h1, {\[Pi]/2 - phi, \[Pi]/2 + phi}],Disk[{0,0},h0]}];
Return[RegionDifference[d1,d0]]
];



(* ::Input::Initialization:: *)
edgesWithLR[n_,mList_] := Module[{newEdges},
newEdges = Map[{n,#}&,mList];
rightEdges = Map[moveNumberRight,Cases[newEdges,{a_,left[b_]}] ,{2}];
leftEdges = Map[moveNumberLeft,Cases[newEdges,{a_,right[b_]}] ,{2}];
newEdges = Join[newEdges,rightEdges,leftEdges];
newEdges = Join[newEdges,Reverse  /@ newEdges];
newEdges = DirectedEdge @@@newEdges;

DeleteDuplicates@newEdges
];



(* ::Input::Initialization:: *)

chainParastichyCount[front_,neighbourAssociations_] := Module[{transitions},
pairs = Map[bareNumber,front];
pairs = ( Partition[pairs,2,1] );
pairs = DirectedEdge @@@pairs;
pairs = Cases[pairs,Except[a_\[DirectedEdge]a_]];
lookup = KeyMap[Map[bareNumber,#]&,neighbourAssociations[DEdgeAngle]];
pairs =(Map[lookup[#]&,pairs]);
pairs = Map[If [#<1/4,Up,Down]&,pairs];
If[MissingQ[pairs],Return[Missing[]]];
Values@Counts[pairs]
];






(* ::Input::Initialization:: *)
rotateList[list_,element_] := Module[{},
If[!MemberQ[list,element],Return[list]];
pos = First@First@Position[list,element];
Join[Drop[list,pos-1],Take[list,pos-1]]
];



(* ::Input::Initialization:: *)
(* assumes each node sits on one to its left and one to its right, 
and we only allow going right *)
findGraphFront[firstNumber_,neighbourAssociations_] := Module[{lastNumber,nextCoinNumber,thisFront},

thisFront = {firstNumber};
For[k=0,k<50,k++,

lastNumber=  Last[ thisFront];
nextCoinNumber= nextInChainGraph[lastNumber,neighbourAssociations];
If[MissingQ[nextCoinNumber],Return[nextCoinNumber]];
thisFront = Append[thisFront,nextCoinNumber];
If[!IntegerQ[nextCoinNumber],
nextCoinNumber=bareNumber[nextCoinNumber];
thisFront = Append[thisFront,nextCoinNumber];
];
If[nextCoinNumber==firstNumber,
Break[]];
];
If[k==50,Print["fGF at 50"];Return[Missing["k50"]]];


thisFront
];

nextInChainGraph[lastNumber_,neighbourAssociations_]  := Module[{allOutwardEdges,rightEdgesByAngle,nextEdge,nextCoinNumber},
allOutwardEdges=EdgeList[ neighbourAssociations[ContactGraph],bareNumber[lastNumber ]\[DirectedEdge] _  ];
rightEdgesByAngle = Sort[Association@@Map[#->neighbourAssociations[DEdgeAngle][#]&,allOutwardEdges]];
rightEdgesByAngle = Select[rightEdgesByAngle,#<1/2&];
If[Length[rightEdgesByAngle]==0,Return[Missing["noRightOutward"]]];
nextEdge =First@Keys[rightEdgesByAngle];
nextCoinNumber  = Last[nextEdge];
nextCoinNumber
];



(* ::Input::Initialization:: *)

findFront[firstNumber_,neighbourAssociations_] := Module[{lastNumberCoinAdded,lastNumberBare,nextInFrontList,nextCoinNumber,nextCoinBare,thisFront,oldfront},

thisFront = {firstNumber};
For[k=0,k<Infinity,k++,
lastNumberCoinAdded = thisFront[[ -1 ]] ;
lastNumberBare =  bareNumber[lastNumberCoinAdded ];
(* we have come in on a neighbour connection (usually but not always from the left). We want the next outward collection clockwise from that *)
allOutward = Map[First,neighbourAssociations[ContactAngle][lastNumberBare]];
Print[allOutward];


If[Length[thisFront]==1,
If[Length[allOutward]==0,Print["No outwarda at ", firstNumber]];
nextCoinNumber = First[allOutward],
(* Length>1:  we came from somewhere *)
previousNumberCoinAdded = thisFront[[-2]];
(* reorder clockwise from there *)

If[Head[lastNumberCoinAdded]==right ,
thisFront = Append[thisFront,bareNumber[lastNumberCoinAdded]];
previousNumberCoinAdded=left[bareNumber[previousNumberCoinAdded]];
];
If[Head[lastNumberCoinAdded]==left ,
If[MemberQ[Keys[neighbourAssociations[ContactAngle]],lastNumberCoinAdded],allOutward = Map[First,neighbourAssociations[ContactAngle][lastNumberCoinAdded]]]; 
];
allOutward = rotateList[allOutward,previousNumberCoinAdded];
allOutward = Cases[allOutward,Except[previousNumberCoinAdded]];
If[Length[allOutward]== 0,
(* can't finish thisFront *)
thisFront = Append[thisFront,"KeyAbsent"];
Break[]];

nextCoinNumber = First[allOutward];
];

nextCoinBare = bareNumber[nextCoinNumber ];
If[nextCoinBare == firstNumber,
thisFront = Append[thisFront,nextCoinNumber];
If[Head[nextCoinNumber]=== right,
thisFront = Append[thisFront,nextCoinBare]];
Break[]];
If[MemberQ[thisFront,nextCoinBare],
Print["Front loop from ",firstNumber, " at ",nextCoinNumber];Return[Missing["Front loop"]]
];
thisFront = Append[thisFront,nextCoinNumber];
];

thisFront
];



(* ::Input::Initialization:: *)
updateNeighbourFunction[nextCoinSet_,nextCoinLowerNeighbours_,arenaAssociation_,nodeAssociation_] := Module[
{lowerN,neighbourAssociationsres,n,i,coinCollection,angles,angleResult,nextCoin,para2},

coinCollection= nodeAssociation[Coins];
nextCoin=First@nextCoinSet;

n = coinNumber[nextCoin];

neighbourAssociationsres= nodeAssociation;

(* use pair to update ContactAngle as front finding is bodged but works for that *)

lowerN = coinLowerPair[nextCoin,coinCollection][[2]];
angles= coinLowerPair[nextCoin,coinCollection][[3]];

angleResult = nodeAssociation[ContactAngle];
For[i=1,i<= Length[lowerN],i++,
angleResult = symmetricAdd[angleResult,n,lowerN[[i]],angles[[i]]]; 
];
neighbourAssociationsres[ContactAngle]=angleResult;

If[MissingQ[nextCoinLowerNeighbours],
Print["Missing lN"];
];

coinCollection = Join[coinCollection,nextCoinSet];
newEdges = edgesWithLR[n,nextCoinLowerNeighbours];

coinNumberPairAngle[coinm_,coinn_] := coinPairAngle[ getCoinByNumber[coinm,coinCollection],getCoinByNumber[coinn,coinCollection]];

newEdgeAngles =Association@@Map[#-> coinNumberPairAngle[ #[[1]],#[[2]]]&,newEdges];

neighbourAssociationsres[ContactAngle]=angleResult;
neighbourAssociationsres[DEdgeAngle]= Append[neighbourAssociationsres[DEdgeAngle],newEdgeAngles];
neighbourAssociationsres[ContactGraph]= EdgeAdd[neighbourAssociationsres[ContactGraph],newEdges];
neighbourAssociationsres[Coins]=Join[nodeAssociation[Coins],nextCoinSet];
neighbourAssociationsres[LastCoinZ]=coinZ[nextCoin,arenaAssociation["phi"]];


thisChain = findGraphFront[coinNumber[First[nextCoinSet]],neighbourAssociationsres];
neighbourAssociationsres[ChainNumbers] = thisChain;

para2 = neighbourAssociationsres[ChainsByCoinNumber];
para2 = Append[para2,coinNumber[nextCoin]->thisChain];
neighbourAssociationsres[ChainsByCoinNumber] = para2;

para2 = neighbourAssociationsres[Parastichy];
para2[coinNumber[nextCoin]] =chainParastichyCount[neighbourAssociationsres[ChainNumbers],neighbourAssociationsres];
neighbourAssociationsres[Parastichy] = para2;

Return[neighbourAssociationsres];
];

findFrontNumbersFromNodes[n_,arenaAssociation_,nAres_]  := Module[{nextCoinS,coinFront2,lastFrontNumbers,res},
Print["fFN"];

lastFrontNumbers =findFront[n,nAres];
Print[lastFrontNumbers];
Print["fFN"];
If[MissingQ[lastFrontNumbers],Return[lastFrontNumbers]];

nextCoinS = getCoinAndCopiesByNumber[n,nAres[Coins]];
If[MissingQ[lastFrontNumbers],Print[nextCoinS];Print[lastFrontNumbers]];

If[!MemberQ[lastFrontNumbers,"KeyAbsent"],
(* main way *)
coinFront2 = Map[getCoinAndCopiesByNumber[#,nAres[Coins]]&,lastFrontNumbers];
coinFront2 = DeleteDuplicates@Flatten[coinFront2,1]
,
(* initially or after a restart *)
coinFront2 = Join[ nAres[Coins],nextCoinS];
];
res = SortBy[coinFront2,#[[2,1,1]]&];

coinNumber /@res
];





(* ::Input::Initialization:: *)

chainRegionDistanceFunction[chainNumbers_,run_,dilation_:1] := Module[{chainAndLRcoins,disks,iboundaryMesh},
chainAndLRcoins= DeleteDuplicates[Flatten[Map[getCoinAndCopiesByNumber[#,run["State"][Coins]]&,chainNumbers],1]];
disks = Map[Last,chainAndLRcoins];
iboundaryMesh = DiscretizeRegion@RegionUnion[disks];
RegionDistance[iboundaryMesh]
];

nextCoinAndContacts[chainNumbers_,run_] := Module[{r,chainAndLR,touchingDisksXY
,chainRDF,diskChainDistance,disksNotOverlappingChain,lowerNeighbours},
r = run["Arena"]["rFunction"][run["State"][LastCoinZ]];


chainAndLR= DeleteDuplicates[Flatten[Map[getCoinAndCopiesByNumber[#,run["State"][Coins]]&,chainNumbers],1]];

touchingDisksXY = (Association@@Map[First[#]->Last[#]&,Map[Transpose,Subsets[chainAndLR,{2}]]]);
touchingDisksXY = Map[diskdisktouchingPoint[#,r]&,touchingDisksXY];
touchingDisksXY = Select[touchingDisksXY,Not[MissingQ[#]]&];
touchingDisksXY = Map[Last@SortBy[#,Last]&,touchingDisksXY];  (* assumes lower touching point no good *)

touchingDisksXY = Select[touchingDisksXY,First[#]>= -1/2 && First[#]<= 1/2 &];
(* now exclude the ones that overlap with the chain *)
chainRDF=  chainRegionDistanceFunction[chainNumbers,run];
diskChainDistance = Map[chainRDF,touchingDisksXY];
disksNotOverlappingChain = Keys@Select[diskChainDistance,#>=r&];
touchingDisksXY= KeyTake[touchingDisksXY,disksNotOverlappingChain];

(* exclude any that have support on the wrong side *)
cx[n_] := coinDisk@getCoinByNumber[n,run["State"][Coins]] ;
angleLR[angle_] := If[angle<1/2,right,left];
bothLLorRR  = Association@@KeyValueMap[ #1-> (
angleLR@coinPairAngle[cx[#1[[1]]],Disk[#2,1]]===
angleLR@coinPairAngle[cx[#1[[2]]],Disk[#2,1]]
)&,touchingDisksXY];
bothLLorRR = Keys@ Select[bothLLorRR,TrueQ];
touchingDisksXY = KeyDrop[touchingDisksXY,bothLLorRR];

touchingDisksXY  = SortBy[touchingDisksXY,Last];
If[Length[touchingDisksXY]==0,Return[Missing["No touching disks"]]];
lowerNeighbours = First[Keys[touchingDisksXY]];
touchingDisksXY = KeyTake[touchingDisksXY,{First[Keys[touchingDisksXY]]}];
<| "CoinNumber"-> Max[Map[bareNumber,chainNumbers]]+1,
"CoinDisk"-> Disk[touchingDisksXY[lowerNeighbours],r],
"CoinNeighbours"-> lowerNeighbours |>
];


diskdisktouchingPoint[pairDisks_,r_] := Module[{xy1,xy2,r1,r2,interdisk},
{{xy1,r1},{xy2,r2}}= List@@@ pairDisks;
interdisk = Norm[xy1-xy2];
If[interdisk > r1 + r2 + 2r,Return[Missing[]]];
sTriangle =SSSTriangle[r+r2,r+r1,interdisk];
triangle = (List@sTriangle)[[1,1]];
transform =Composition[TranslationTransform[xy1],RotationTransform[{triangle[[2]]-triangle[[1]],xy2-xy1}]
];
rTrianglePT = (transform[triangle])[[3]];
lTrianglePT = (ReflectionTransform[RotationTransform[90 Degree][xy2-xy1],xy1])[rTrianglePT];
{rTrianglePT,lTrianglePT}
(*Graphics[{pairDisks,{Red,Disk[rTrianglePT,r]},{Blue,Disk[lTrianglePT,r]} ,{Yellow,transform[sTriangle]}}]
*)];



(* ::Input::Initialization:: *)
(*frontFromFrontNumbers[nodeAssociation_] := Module[{res},
res = Map[getCoinByNumber[#,nodeAssociation[Coins]]&,nodeAssociation[FrontNumbers]];
If[MissingQ[res],nodeAssociation[Coins],res]
];*)


(* ::Input::Initialization:: *)
oldstyleNextCoinAndContacts[run_] := Module[{r,nextCoinByFront,phi},

r = run["Arena"]["rFunction"][run["State"][LastCoinZ]];
phi = run["Arena"]["phi"];


frontDisks = run["State"][Coins];

nextCoinByFront =  placeNextCoinCone[  
frontDisks
,r
,run["State"][LastCoinZ]
,phi
, run["Arena"]["cylinderLU"]
];
<| "CoinNumber"->First[nextCoinByFront],"CoinDisk"->Last[nextCoinByFront],"CoinNeighbours"->Missing[]|>
];


(* ::Input::Initialization:: *)
addNextCoinCone[arenaAssociation_,nodeAssociation_] := Module[{r,nextCoin,nextCoinSet,nAres,para2,phi},
run= <|"State"->nodeAssociation,"Arena"-> arenaAssociation|>;



chainNumbers= run["State"][ChainNumbers];
lowest= Missing[];
If[!MissingQ[chainNumbers],
lowest  = nextCoinAndContacts[chainNumbers,run];

];
If[!MissingQ[lowest],
nextCoin = {lowest["CoinNumber"],lowest["CoinDisk"]};
nextCoinLowerNeighbours = lowest["CoinNeighbours"];
,
oldLowest =oldstyleNextCoinAndContacts[run];
If[MissingQ[oldLowest],
Print["Can't go oldstyle", chainNumbers];
Abort[];
];
nextCoin ={oldLowest["CoinNumber"],oldLowest["CoinDisk"]};
Print["Going oldstyle at ", oldLowest];
nextCoinLowerNeighbours = coinLowerNeighbourNumbers[nextCoin, nodeAssociation[Coins],0.01];

];
nextCoinSet = coinWithConeTranslations[nextCoin,run];

nAres = updateNeighbourFunction[nextCoinSet,nextCoinLowerNeighbours,arenaAssociation,nodeAssociation];
nAres

];




(* ::Input::Initialization:: *)
stackFrontFromIC[icCoins_,arenaAssociation_] := Module[
{lastCoinZ,k,phi,parastichyTop,nodeAssociation},

lastCoinZ = Max[Map[coinZ[#,arenaAssociation["phi"]]&,icCoins]];


nodeAssociation =  Association[
ContactAngle->Association[]
,ContactGraph->Graph[{}]
,DEdgeAngle->Association[]
,Parastichy->Association[]
,ChainNumbers-> Missing[]
,ChainsByCoinNumber ->  Association[]
,Coins->icCoins
,LastCoinZ-> lastCoinZ];




Monitor[
For[k=0,k< arenaAssociation["coinMax"],k++,
{tim,nodeAssociation } = Timing[ 
addNextCoinCone[arenaAssociation,nodeAssociation] 
];

parastichyTop = KeyTake[nodeAssociation[Parastichy],Last[Keys@nodeAssociation[Parastichy]]];
lastCoinZ =  nodeAssociation[LastCoinZ];
If[lastCoinZ+ 2 arenaAssociation["rFunction"][lastCoinZ]> (arenaAssociation["cylinderLU"])[[2]],Break[]];
],
 {ProgressIndicator[lastCoinZ,{0,(arenaAssociation["cylinderLU"])[[2]]}],parastichyTop,tim}
];
graphNodes = nodeAssociation[ContactGraph];
graphNodeXY = Map[coinXY[getCoinByNumber[#,nodeAssociation[Coins]]]&,VertexList[graphNodes]];
nodeAssociation[ContactGraph] = Graph[nodeAssociation[ContactGraph],VertexCoordinates->graphNodeXY];

<|"State"-> nodeAssociation,"Arena"->arenaAssociation|>
];


